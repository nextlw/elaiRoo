const __vite__mapDeps = (
	i,
	m = __vite__mapDeps,
	d = m.f ||
		(m.f = [
			"./angular-html-Bbf3ZyxA.js",
			"./html-B8pBdPMQ.js",
			"./javascript-BMMyXqK5.js",
			"./css-DPfMkruS.js",
			"./angular-ts-C26w9mnW.js",
			"./scss-OYdSNvt2.js",
			"./apl-e980N3t4.js",
			"./xml-sdJ4AIDG.js",
			"./java-CylS5w8V.js",
			"./json-Cp-IABpG.js",
			"./astro-DAp1zUbp.js",
			"./typescript-DlfHMoPT.js",
			"./postcss-CXtECtnM.js",
			"./blade-DGJDb2eD.js",
			"./html-derivative-ZQ8onl8Z.js",
			"./sql-B9xm8XSJ.js",
			"./bsl-BO_Y6i37.js",
			"./sdbl-DVxCFoDh.js",
			"./cairo-KRGpt6FW.js",
			"./python-B6aJPvgy.js",
			"./cobol-CCPHrsME.js",
			"./coffee-JUOWOZUj.js",
			"./cpp-ChttZZSa.js",
			"./regexp-CDVJQ6XC.js",
			"./glsl-DplSGwfg.js",
			"./c-BIGW1oBm.js",
			"./crystal-CfkhwHAQ.js",
			"./shellscript-Yzrsuije.js",
			"./edge-CKszZCnI.js",
			"./elixir-Cc7HHYVZ.js",
			"./elm-DbKCFpqz.js",
			"./erb-D3EuUlpm.js",
			"./ruby-C5MNRm7z.js",
			"./haml-AZXGPtNI.js",
			"./graphql-Caa12_AY.js",
			"./jsx-g9-lgVsj.js",
			"./tsx-COt5Ahok.js",
			"./lua-BbnMAYS6.js",
			"./yaml-Buea-lGh.js",
			"./fortran-fixed-form-BZjJHVRy.js",
			"./fortran-free-form-D22FLkUw.js",
			"./fsharp-DQy8In2x.js",
			"./markdown-RrBGtqGR.js",
			"./gdresource-BSDf9Pz1.js",
			"./gdshader-DkwncUOv.js",
			"./gdscript-Bty6elJm.js",
			"./git-commit-F4YmCXRG.js",
			"./diff-D97Zzqfu.js",
			"./git-rebase-r7XF79zn.js",
			"./glimmer-js-Dz9X99Cm.js",
			"./glimmer-ts-aQ3p29eY.js",
			"./hack-C1oSbnf3.js",
			"./handlebars-YebKLiTq.js",
			"./http-C38VWM-o.js",
			"./hxml-B2Z6b3nn.js",
			"./haxe-BP3HzMA6.js",
			"./jinja-BJmZiE_F.js",
			"./jison-BCRtk9Os.js",
			"./julia-Db79kMu7.js",
			"./r-C2tOF0e5.js",
			"./latex-okZ41ve_.js",
			"./tex-mQPFytnq.js",
			"./liquid-C1lUkxsO.js",
			"./marko-C0z8HR23.js",
			"./less-B1dDrJ26.js",
			"./mdc-02rxpBA4.js",
			"./nginx-DknmC5AR.js",
			"./nim-ANgMEeb1.js",
			"./perl-EWVMYlR0.js",
			"./php-9PMsNEzE.js",
			"./pug-Ch9lOoSd.js",
			"./qml-CHzV51_b.js",
			"./razor-CNXmhs1n.js",
			"./csharp-CHadp7IV.js",
			"./rst-DHpKpUMA.js",
			"./cmake-D1j8_8rp.js",
			"./sas-Dlf3BogE.js",
			"./shaderlab-Dg9Lc6iA.js",
			"./hlsl-D3lLCCz7.js",
			"./shellsession-BADoaaVG.js",
			"./soy-B_7ge1HE.js",
			"./sparql-rVzFXLq3.js",
			"./turtle-BsS91CYL.js",
			"./stata-C5TGba-T.js",
			"./svelte-BFkwb7XM.js",
			"./templ-kZcegUSt.js",
			"./go-PEFJdsE-.js",
			"./ts-tags-CHnADXob.js",
			"./twig-febACT8g.js",
			"./vue-xz9K_ZKN.js",
			"./vue-html-dOMv_FQ0.js",
			"./xsl-CtQFsRM5.js",
		]),
) => i.map((i) => d[i])
var Du = Object.defineProperty
var Nu = (e, t, n) => (t in e ? Du(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n))
var R = (e, t, n) => Nu(e, typeof t != "symbol" ? t + "" : t, n)
import { j as D } from "./jsx-runtime-ClZEHPQQ.js"
import { r as we, R as $, g as ra } from "./index-Cqyox1Tj.js"
import { c as Ir } from "./utils-CytzSlOG.js"
import { h as Mu } from "./index-C2TgfdXk.js"
import { i as ia, x as oa, y as zu, B as Vu, z as Bu, A as Fu } from "./tooltip-BZ0lSD2s.js"
import { c as sa, B as _i } from "./createLucideIcon-B4nlfPec.js"
import { A as ju } from "./autosize-textarea-69dnNYfc.js"
import { _ as g } from "./iframe-BrPxLo_6.js"
import "./index-D-LGQApf.js"
/**
 * @license lucide-react v0.513.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Hu = [
		[
			"path",
			{ d: "M12 5a3 3 0 1 0-5.997.125 4 4 0 0 0-2.526 5.77 4 4 0 0 0 .556 6.588A4 4 0 1 0 12 18Z", key: "l5xja" },
		],
		["path", { d: "M9 13a4.5 4.5 0 0 0 3-4", key: "10igwf" }],
		["path", { d: "M6.003 5.125A3 3 0 0 0 6.401 6.5", key: "105sqy" }],
		["path", { d: "M3.477 10.896a4 4 0 0 1 .585-.396", key: "ql3yin" }],
		["path", { d: "M6 18a4 4 0 0 1-1.967-.516", key: "2e4loj" }],
		["path", { d: "M12 13h4", key: "1ku699" }],
		["path", { d: "M12 18h6a2 2 0 0 1 2 2v1", key: "105ag5" }],
		["path", { d: "M12 8h8", key: "1lhi5i" }],
		["path", { d: "M16 8V5a2 2 0 0 1 2-2", key: "u6izg6" }],
		["circle", { cx: "16", cy: "13", r: ".5", key: "ry7gng" }],
		["circle", { cx: "18", cy: "3", r: ".5", key: "1aiba7" }],
		["circle", { cx: "20", cy: "21", r: ".5", key: "yhc1fs" }],
		["circle", { cx: "20", cy: "8", r: ".5", key: "1e43v0" }],
	],
	Gu = sa("brain-circuit", Hu)
/**
 * @license lucide-react v0.513.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const $u = [
		["path", { d: "M18 20a6 6 0 0 0-12 0", key: "1qehca" }],
		["circle", { cx: "12", cy: "10", r: "4", key: "1h16sb" }],
		["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
	],
	Uu = sa("circle-user-round", $u)
var aa = ((e) => ((e.BADGE = "badge"), e))(aa || {})
const la = we.createContext(null),
	qu = la.Provider,
	Tr = 0,
	At = 1,
	nn = 2,
	ua = 4
function Co(e) {
	return () => e
}
function Wu(e) {
	e()
}
function ca(e, t) {
	return (n) => e(t(n))
}
function Ao(e, t) {
	return () => e(t)
}
function Ku(e, t) {
	return (n) => e(t, n)
}
function Hi(e) {
	return e !== void 0
}
function Yu(...e) {
	return () => {
		e.map(Wu)
	}
}
function rn() {}
function Cr(e, t) {
	return t(e), e
}
function Xu(e, t) {
	return t(e)
}
function _e(...e) {
	return e
}
function ce(e, t) {
	return e(At, t)
}
function ee(e, t) {
	e(Tr, t)
}
function Gi(e) {
	e(nn)
}
function Me(e) {
	return e(ua)
}
function U(e, t) {
	return ce(e, Ku(t, Tr))
}
function ht(e, t) {
	const n = e(At, (r) => {
		n(), t(r)
	})
	return n
}
function Ro(e) {
	let t, n
	return (r) => (i) => {
		;(t = i),
			n && clearTimeout(n),
			(n = setTimeout(() => {
				r(t)
			}, e))
	}
}
function ma(e, t) {
	return e === t
}
function ge(e = ma) {
	let t
	return (n) => (r) => {
		e(t, r) || ((t = r), n(r))
	}
}
function K(e) {
	return (t) => (n) => {
		e(n) && t(n)
	}
}
function G(e) {
	return (t) => ca(t, e)
}
function mt(e) {
	return (t) => () => {
		t(e)
	}
}
function O(e, ...t) {
	const n = Qu(...t)
	return (r, i) => {
		switch (r) {
			case nn:
				Gi(e)
				return
			case At:
				return ce(e, n(i))
		}
	}
}
function pt(e, t) {
	return (n) => (r) => {
		n((t = e(t, r)))
	}
}
function Zt(e) {
	return (t) => (n) => {
		e > 0 ? e-- : t(n)
	}
}
function Tt(e) {
	let t = null,
		n
	return (r) => (i) => {
		;(t = i),
			!n &&
				(n = setTimeout(() => {
					;(n = void 0), r(t)
				}, e))
	}
}
function ne(...e) {
	const t = new Array(e.length)
	let n = 0,
		r = null
	const i = Math.pow(2, e.length) - 1
	return (
		e.forEach((o, s) => {
			const a = Math.pow(2, s)
			ce(o, (l) => {
				const u = n
				;(n = n | a), (t[s] = l), u !== i && n === i && r && (r(), (r = null))
			})
		}),
		(o) => (s) => {
			const a = () => {
				o([s].concat(t))
			}
			n === i ? a() : (r = a)
		}
	)
}
function Qu(...e) {
	return (t) => e.reduceRight(Xu, t)
}
function Ju(e) {
	let t, n
	const r = () => (t == null ? void 0 : t())
	return function (i, o) {
		switch (i) {
			case At:
				return o ? (n === o ? void 0 : (r(), (n = o), (t = ce(e, o)), t)) : (r(), rn)
			case nn:
				r(), (n = null)
				return
		}
	}
}
function F(e) {
	let t = e
	const n = ie()
	return (r, i) => {
		switch (r) {
			case Tr:
				t = i
				break
			case At: {
				i(t)
				break
			}
			case ua:
				return t
		}
		return n(r, i)
	}
}
function ze(e, t) {
	return Cr(F(t), (n) => U(e, n))
}
function ie() {
	const e = []
	return (t, n) => {
		switch (t) {
			case Tr:
				e.slice().forEach((r) => {
					r(n)
				})
				return
			case nn:
				e.splice(0, e.length)
				return
			case At:
				return (
					e.push(n),
					() => {
						const r = e.indexOf(n)
						r > -1 && e.splice(r, 1)
					}
				)
		}
	}
}
function Xe(e) {
	return Cr(ie(), (t) => U(e, t))
}
function ae(e, t = [], { singleton: n } = { singleton: !0 }) {
	return { constructor: e, dependencies: t, id: Zu(), singleton: n }
}
const Zu = () => Symbol()
function ec(e) {
	const t = new Map(),
		n = ({ constructor: r, dependencies: i, id: o, singleton: s }) => {
			if (s && t.has(o)) return t.get(o)
			const a = r(i.map((l) => n(l)))
			return s && t.set(o, a), a
		}
	return n(e)
}
function Te(...e) {
	const t = ie(),
		n = new Array(e.length)
	let r = 0
	const i = Math.pow(2, e.length) - 1
	return (
		e.forEach((o, s) => {
			const a = Math.pow(2, s)
			ce(o, (l) => {
				;(n[s] = l), (r = r | a), r === i && ee(t, n)
			})
		}),
		function (o, s) {
			switch (o) {
				case nn: {
					Gi(t)
					return
				}
				case At:
					return r === i && s(n), ce(t, s)
			}
		}
	)
}
function Y(e, t = ma) {
	return O(e, ge(t))
}
function Lo(...e) {
	return function (t, n) {
		switch (t) {
			case nn:
				return
			case At:
				return Yu(...e.map((r) => ce(r, n)))
		}
	}
}
var Qe = ((e) => (
	(e[(e.DEBUG = 0)] = "DEBUG"),
	(e[(e.INFO = 1)] = "INFO"),
	(e[(e.WARN = 2)] = "WARN"),
	(e[(e.ERROR = 3)] = "ERROR"),
	e
))(Qe || {})
const tc = { 0: "debug", 3: "error", 1: "log", 2: "warn" },
	nc = () => (typeof globalThis > "u" ? window : globalThis),
	Rt = ae(
		() => {
			const e = F(3)
			return {
				log: F((t, n, r = 1) => {
					var i
					const o = (i = nc().VIRTUOSO_LOG_LEVEL) != null ? i : Me(e)
					r >= o &&
						console[tc[r]](
							"%creact-virtuoso: %c%s %o",
							"color: #0253b3; font-weight: bold",
							"color: initial",
							t,
							n,
						)
				}),
				logLevel: e,
			}
		},
		[],
		{ singleton: !0 },
	)
function jt(e, t, n) {
	return $i(e, t, n).callbackRef
}
function $i(e, t, n) {
	const r = $.useRef(null)
	let i = (s) => {}
	const o = $.useMemo(
		() =>
			typeof ResizeObserver < "u"
				? new ResizeObserver((s) => {
						const a = () => {
							const l = s[0].target
							l.offsetParent !== null && e(l)
						}
						n ? a() : requestAnimationFrame(a)
					})
				: null,
		[e, n],
	)
	return (
		(i = (s) => {
			s && t
				? (o == null || o.observe(s), (r.current = s))
				: (r.current && (o == null || o.unobserve(r.current)), (r.current = null))
		}),
		{ callbackRef: i, ref: r }
	)
}
function rc(e, t, n, r, i, o, s, a, l) {
	const u = $.useCallback(
		(m) => {
			const c = ic(m.children, t, a ? "offsetWidth" : "offsetHeight", i)
			let h = m.parentElement
			for (; !h.dataset.virtuosoScroller; ) h = h.parentElement
			const p = h.lastElementChild.dataset.viewportType === "window"
			let f
			p && (f = h.ownerDocument.defaultView)
			const y = s
					? a
						? s.scrollLeft
						: s.scrollTop
					: p
						? a
							? f.scrollX || f.document.documentElement.scrollLeft
							: f.scrollY || f.document.documentElement.scrollTop
						: a
							? h.scrollLeft
							: h.scrollTop,
				x = s
					? a
						? s.scrollWidth
						: s.scrollHeight
					: p
						? a
							? f.document.documentElement.scrollWidth
							: f.document.documentElement.scrollHeight
						: a
							? h.scrollWidth
							: h.scrollHeight,
				d = s
					? a
						? s.offsetWidth
						: s.offsetHeight
					: p
						? a
							? f.innerWidth
							: f.innerHeight
						: a
							? h.offsetWidth
							: h.offsetHeight
			r({ scrollHeight: x, scrollTop: Math.max(y, 0), viewportHeight: d }),
				o == null ||
					o(
						a
							? Po("column-gap", getComputedStyle(m).columnGap, i)
							: Po("row-gap", getComputedStyle(m).rowGap, i),
					),
				c !== null && e(c)
		},
		[e, t, i, o, s, r, a],
	)
	return $i(u, n, l)
}
function ic(e, t, n, r) {
	const i = e.length
	if (i === 0) return null
	const o = []
	for (let s = 0; s < i; s++) {
		const a = e.item(s)
		if (a.dataset.index === void 0) continue
		const l = parseInt(a.dataset.index),
			u = parseFloat(a.dataset.knownSize),
			m = t(a, n)
		if ((m === 0 && r("Zero-sized element, this should not happen", { child: a }, Qe.ERROR), m === u)) continue
		const c = o[o.length - 1]
		o.length === 0 || c.size !== m || c.endIndex !== l - 1
			? o.push({ endIndex: l, size: m, startIndex: l })
			: o[o.length - 1].endIndex++
	}
	return o
}
function Po(e, t, n) {
	return (
		t !== "normal" &&
			!(t != null && t.endsWith("px")) &&
			n(`${e} was not resolved to pixel value correctly`, t, Qe.WARN),
		t === "normal" ? 0 : parseInt(t ?? "0", 10)
	)
}
function pa(e, t, n) {
	const r = $.useRef(null),
		i = $.useCallback(
			(l) => {
				if (!(l != null && l.offsetParent)) return
				const u = l.getBoundingClientRect(),
					m = u.width
				let c, h
				if (t) {
					const p = t.getBoundingClientRect(),
						f = u.top - p.top
					;(h = p.height - Math.max(0, f)), (c = f + t.scrollTop)
				} else {
					const p = s.current.ownerDocument.defaultView
					;(h = p.innerHeight - Math.max(0, u.top)), (c = u.top + p.scrollY)
				}
				;(r.current = { offsetTop: c, visibleHeight: h, visibleWidth: m }), e(r.current)
			},
			[e, t],
		),
		{ callbackRef: o, ref: s } = $i(i, !0, n),
		a = $.useCallback(() => {
			i(s.current)
		}, [i, s])
	return (
		$.useEffect(() => {
			var l
			if (t) {
				t.addEventListener("scroll", a)
				const u = new ResizeObserver(() => {
					requestAnimationFrame(a)
				})
				return (
					u.observe(t),
					() => {
						t.removeEventListener("scroll", a), u.unobserve(t)
					}
				)
			} else {
				const u = (l = s.current) == null ? void 0 : l.ownerDocument.defaultView
				return (
					u == null || u.addEventListener("scroll", a),
					u == null || u.addEventListener("resize", a),
					() => {
						u == null || u.removeEventListener("scroll", a), u == null || u.removeEventListener("resize", a)
					}
				)
			}
		}, [a, t, s]),
		o
	)
}
const He = ae(
		() => {
			const e = ie(),
				t = ie(),
				n = F(0),
				r = ie(),
				i = F(0),
				o = ie(),
				s = ie(),
				a = F(0),
				l = F(0),
				u = F(0),
				m = F(0),
				c = ie(),
				h = ie(),
				p = F(!1),
				f = F(!1),
				y = F(!1)
			return (
				U(
					O(
						e,
						G(({ scrollTop: x }) => x),
					),
					t,
				),
				U(
					O(
						e,
						G(({ scrollHeight: x }) => x),
					),
					s,
				),
				U(t, i),
				{
					deviation: n,
					fixedFooterHeight: u,
					fixedHeaderHeight: l,
					footerHeight: m,
					headerHeight: a,
					horizontalDirection: f,
					scrollBy: h,
					scrollContainerState: e,
					scrollHeight: s,
					scrollingInProgress: p,
					scrollTo: c,
					scrollTop: t,
					skipAnimationFrameInResizeObserver: y,
					smoothScrollTargetReached: r,
					statefulScrollTop: i,
					viewportHeight: o,
				}
			)
		},
		[],
		{ singleton: !0 },
	),
	En = { lvl: 0 }
function ha(e, t) {
	const n = e.length
	if (n === 0) return []
	let { index: r, value: i } = t(e[0])
	const o = []
	for (let s = 1; s < n; s++) {
		const { index: a, value: l } = t(e[s])
		o.push({ end: a - 1, start: r, value: i }), (r = a), (i = l)
	}
	return o.push({ end: 1 / 0, start: r, value: i }), o
}
function he(e) {
	return e === En
}
function vn(e, t) {
	if (!he(e)) return t === e.k ? e.v : t < e.k ? vn(e.l, t) : vn(e.r, t)
}
function st(e, t, n = "k") {
	if (he(e)) return [-1 / 0, void 0]
	if (Number(e[n]) === t) return [e.k, e.v]
	if (Number(e[n]) < t) {
		const r = st(e.r, t, n)
		return r[0] === -1 / 0 ? [e.k, e.v] : r
	}
	return st(e.l, t, n)
}
function Ye(e, t, n) {
	return he(e)
		? ga(t, n, 1)
		: t === e.k
			? Se(e, { k: t, v: n })
			: t < e.k
				? Oo(Se(e, { l: Ye(e.l, t, n) }))
				: Oo(Se(e, { r: Ye(e.r, t, n) }))
}
function Xt() {
	return En
}
function Ar(e, t, n) {
	if (he(e)) return []
	const r = st(e, t)[0]
	return oc(xi(e, r, n))
}
function yi(e, t) {
	if (he(e)) return En
	const { k: n, l: r, r: i } = e
	if (t === n) {
		if (he(r)) return i
		if (he(i)) return r
		{
			const [o, s] = da(r)
			return tr(Se(e, { k: o, l: fa(r), v: s }))
		}
	} else return t < n ? tr(Se(e, { l: yi(r, t) })) : tr(Se(e, { r: yi(i, t) }))
}
function zt(e) {
	return he(e) ? [] : [...zt(e.l), { k: e.k, v: e.v }, ...zt(e.r)]
}
function xi(e, t, n) {
	if (he(e)) return []
	const { k: r, l: i, r: o, v: s } = e
	let a = []
	return (
		r > t && (a = a.concat(xi(i, t, n))),
		r >= t && r <= n && a.push({ k: r, v: s }),
		r <= n && (a = a.concat(xi(o, t, n))),
		a
	)
}
function tr(e) {
	const { l: t, lvl: n, r } = e
	if (r.lvl >= n - 1 && t.lvl >= n - 1) return e
	if (n > r.lvl + 1) {
		if (Hr(t)) return _a(Se(e, { lvl: n - 1 }))
		if (!he(t) && !he(t.r)) return Se(t.r, { l: Se(t, { r: t.r.l }), lvl: n, r: Se(e, { l: t.r.r, lvl: n - 1 }) })
		throw new Error("Unexpected empty nodes")
	} else {
		if (Hr(e)) return bi(Se(e, { lvl: n - 1 }))
		if (!he(r) && !he(r.l)) {
			const i = r.l,
				o = Hr(i) ? r.lvl - 1 : r.lvl
			return Se(i, { l: Se(e, { lvl: n - 1, r: i.l }), lvl: i.lvl + 1, r: bi(Se(r, { l: i.r, lvl: o })) })
		} else throw new Error("Unexpected empty nodes")
	}
}
function Se(e, t) {
	return ga(
		t.k !== void 0 ? t.k : e.k,
		t.v !== void 0 ? t.v : e.v,
		t.lvl !== void 0 ? t.lvl : e.lvl,
		t.l !== void 0 ? t.l : e.l,
		t.r !== void 0 ? t.r : e.r,
	)
}
function fa(e) {
	return he(e.r) ? e.l : tr(Se(e, { r: fa(e.r) }))
}
function Hr(e) {
	return he(e) || e.lvl > e.r.lvl
}
function da(e) {
	return he(e.r) ? [e.k, e.v] : da(e.r)
}
function ga(e, t, n, r = En, i = En) {
	return { k: e, l: r, lvl: n, r: i, v: t }
}
function Oo(e) {
	return bi(_a(e))
}
function _a(e) {
	const { l: t } = e
	return !he(t) && t.lvl === e.lvl ? Se(t, { r: Se(e, { l: t.r }) }) : e
}
function bi(e) {
	const { lvl: t, r: n } = e
	return !he(n) && !he(n.r) && n.lvl === t && n.r.lvl === t ? Se(n, { l: Se(e, { r: n.l }), lvl: t + 1 }) : e
}
function oc(e) {
	return ha(e, ({ k: t, v: n }) => ({ index: t, value: n }))
}
function ya(e, t) {
	return !!(e && e.startIndex === t.startIndex && e.endIndex === t.endIndex)
}
function Sn(e, t) {
	return !!(e && e[0] === t[0] && e[1] === t[1])
}
const Ui = ae(() => ({ recalcInProgress: F(!1) }), [], { singleton: !0 })
function xa(e, t, n) {
	return e[sr(e, t, n)]
}
function sr(e, t, n, r = 0) {
	let i = e.length - 1
	for (; r <= i; ) {
		const o = Math.floor((r + i) / 2),
			s = e[o],
			a = n(s, t)
		if (a === 0) return o
		if (a === -1) {
			if (i - r < 2) return o - 1
			i = o - 1
		} else {
			if (i === r) return o
			r = o + 1
		}
	}
	throw new Error(`Failed binary finding record in array - ${e.join(",")}, searched for ${t}`)
}
function sc(e, t, n, r) {
	const i = sr(e, t, r),
		o = sr(e, n, r, i)
	return e.slice(i, o + 1)
}
function Ct(e, t) {
	return Math.round(e.getBoundingClientRect()[t])
}
function Rr(e) {
	return !he(e.groupOffsetTree)
}
function qi({ index: e }, t) {
	return t === e ? 0 : t < e ? -1 : 1
}
function ac() {
	return {
		groupIndices: [],
		groupOffsetTree: Xt(),
		lastIndex: 0,
		lastOffset: 0,
		lastSize: 0,
		offsetTree: [],
		sizeTree: Xt(),
	}
}
function lc(e, t) {
	let n = he(e) ? 0 : 1 / 0
	for (const r of t) {
		const { endIndex: i, size: o, startIndex: s } = r
		if (((n = Math.min(n, s)), he(e))) {
			e = Ye(e, 0, o)
			continue
		}
		const a = Ar(e, s - 1, i + 1)
		if (a.some(dc(r))) continue
		let l = !1,
			u = !1
		for (const { end: m, start: c, value: h } of a)
			l ? (i >= c || o === h) && (e = yi(e, c)) : ((u = h !== o), (l = !0)),
				m > i && i >= c && h !== o && (e = Ye(e, i + 1, h))
		u && (e = Ye(e, s, o))
	}
	return [e, n]
}
function uc(e) {
	return typeof e.groupIndex < "u"
}
function cc({ offset: e }, t) {
	return t === e ? 0 : t < e ? -1 : 1
}
function In(e, t, n) {
	if (t.length === 0) return 0
	const { index: r, offset: i, size: o } = xa(t, e, qi),
		s = e - r,
		a = o * s + (s - 1) * n + i
	return a > 0 ? a + n : a
}
function ba(e, t) {
	if (!Rr(t)) return e
	let n = 0
	for (; t.groupIndices[n] <= e + n; ) n++
	return e + n
}
function ka(e, t, n) {
	if (uc(e)) return t.groupIndices[e.groupIndex] + 1
	{
		const r = e.index === "LAST" ? n : e.index
		let i = ba(r, t)
		return (i = Math.max(0, i, Math.min(n, i))), i
	}
}
function mc(e, t, n, r = 0) {
	return r > 0 && (t = Math.max(t, xa(e, r, qi).offset)), ha(sc(e, t, n, cc), fc)
}
function pc(e, [t, n, r, i]) {
	t.length > 0 && r("received item sizes", t, Qe.DEBUG)
	const o = e.sizeTree
	let s = o,
		a = 0
	if (n.length > 0 && he(o) && t.length === 2) {
		const h = t[0].size,
			p = t[1].size
		s = n.reduce((f, y) => Ye(Ye(f, y, h), y + 1, p), s)
	} else [s, a] = lc(s, t)
	if (s === o) return e
	const { lastIndex: l, lastOffset: u, lastSize: m, offsetTree: c } = ki(e.offsetTree, a, s, i)
	return {
		groupIndices: n,
		groupOffsetTree: n.reduce((h, p) => Ye(h, p, In(p, c, i)), Xt()),
		lastIndex: l,
		lastOffset: u,
		lastSize: m,
		offsetTree: c,
		sizeTree: s,
	}
}
function hc(e) {
	return zt(e).map(({ k: t, v: n }, r, i) => {
		const o = i[r + 1]
		return { endIndex: o ? o.k - 1 : 1 / 0, size: n, startIndex: t }
	})
}
function Do(e, t) {
	let n = 0,
		r = 0
	for (; n < e; ) (n += t[r + 1] - t[r] - 1), r++
	return r - (n === e ? 0 : 1)
}
function ki(e, t, n, r) {
	let i = e,
		o = 0,
		s = 0,
		a = 0,
		l = 0
	if (t !== 0) {
		;(l = sr(i, t - 1, qi)), (a = i[l].offset)
		const u = st(n, t - 1)
		;(o = u[0]), (s = u[1]), i.length && i[l].size === st(n, t)[1] && (l -= 1), (i = i.slice(0, l + 1))
	} else i = []
	for (const { start: u, value: m } of Ar(n, t, 1 / 0)) {
		const c = u - o,
			h = c * s + a + c * r
		i.push({ index: u, offset: h, size: m }), (o = u), (a = h), (s = m)
	}
	return { lastIndex: o, lastOffset: a, lastSize: s, offsetTree: i }
}
function fc(e) {
	return { index: e.index, value: e }
}
function dc(e) {
	const { endIndex: t, size: n, startIndex: r } = e
	return (i) => i.start === r && (i.end === t || i.end === 1 / 0) && i.value === n
}
const gc = { offsetHeight: "height", offsetWidth: "width" },
	ft = ae(
		([{ log: e }, { recalcInProgress: t }]) => {
			const n = ie(),
				r = ie(),
				i = ze(r, 0),
				o = ie(),
				s = ie(),
				a = F(0),
				l = F([]),
				u = F(void 0),
				m = F(void 0),
				c = F((S, b) => Ct(S, gc[b])),
				h = F(void 0),
				p = F(0),
				f = ac(),
				y = ze(O(n, ne(l, e, p), pt(pc, f), ge()), f),
				x = ze(
					O(
						l,
						ge(),
						pt((S, b) => ({ current: b, prev: S.current }), { current: [], prev: [] }),
						G(({ prev: S }) => S),
					),
					[],
				)
			U(
				O(
					l,
					K((S) => S.length > 0),
					ne(y, p),
					G(([S, b, T]) => {
						const P = S.reduce((z, v, L) => Ye(z, v, In(v, b.offsetTree, T) || L), Xt())
						return { ...b, groupIndices: S, groupOffsetTree: P }
					}),
				),
				y,
			),
				U(
					O(
						r,
						ne(y),
						K(([S, { lastIndex: b }]) => S < b),
						G(([S, { lastIndex: b, lastSize: T }]) => [{ endIndex: b, size: T, startIndex: S }]),
					),
					n,
				),
				U(u, m)
			const d = ze(
				O(
					u,
					G((S) => S === void 0),
				),
				!0,
			)
			U(
				O(
					m,
					K((S) => S !== void 0 && he(Me(y).sizeTree)),
					G((S) => [{ endIndex: 0, size: S, startIndex: 0 }]),
				),
				n,
			)
			const _ = Xe(
				O(
					n,
					ne(y),
					pt(({ sizes: S }, [b, T]) => ({ changed: T !== S, sizes: T }), { changed: !1, sizes: f }),
					G((S) => S.changed),
				),
			)
			ce(
				O(
					a,
					pt((S, b) => ({ diff: S.prev - b, prev: b }), { diff: 0, prev: 0 }),
					G((S) => S.diff),
				),
				(S) => {
					const { groupIndices: b } = Me(y)
					if (S > 0) ee(t, !0), ee(o, S + Do(S, b))
					else if (S < 0) {
						const T = Me(x)
						T.length > 0 && (S -= Do(-S, T)), ee(s, S)
					}
				},
			),
				ce(O(a, ne(e)), ([S, b]) => {
					S < 0 &&
						b(
							"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value",
							{ firstItemIndex: a },
							Qe.ERROR,
						)
				})
			const w = Xe(o)
			U(
				O(
					o,
					ne(y),
					G(([S, b]) => {
						const T = b.groupIndices.length > 0,
							P = [],
							z = b.lastSize
						if (T) {
							const v = vn(b.sizeTree, 0)
							let L = 0,
								M = 0
							for (; L < S; ) {
								const C = b.groupIndices[M],
									j = b.groupIndices.length === M + 1 ? 1 / 0 : b.groupIndices[M + 1] - C - 1
								P.push({ endIndex: C, size: v, startIndex: C }),
									P.push({ endIndex: C + 1 + j - 1, size: z, startIndex: C + 1 }),
									M++,
									(L += j + 1)
							}
							const B = zt(b.sizeTree)
							return (
								L !== S && B.shift(),
								B.reduce(
									(C, { k: j, v: Z }) => {
										let le = C.ranges
										return (
											C.prevSize !== 0 &&
												(le = [
													...C.ranges,
													{ endIndex: j + S - 1, size: C.prevSize, startIndex: C.prevIndex },
												]),
											{ prevIndex: j + S, prevSize: Z, ranges: le }
										)
									},
									{ prevIndex: S, prevSize: 0, ranges: P },
								).ranges
							)
						}
						return zt(b.sizeTree).reduce(
							(v, { k: L, v: M }) => ({
								prevIndex: L + S,
								prevSize: M,
								ranges: [
									...v.ranges,
									{ endIndex: L + S - 1, size: v.prevSize, startIndex: v.prevIndex },
								],
							}),
							{ prevIndex: 0, prevSize: z, ranges: [] },
						).ranges
					}),
				),
				n,
			)
			const I = Xe(
				O(
					s,
					ne(y, p),
					G(([S, { offsetTree: b }, T]) => {
						const P = -S
						return In(P, b, T)
					}),
				),
			)
			return (
				U(
					O(
						s,
						ne(y, p),
						G(([S, b, T]) => {
							if (b.groupIndices.length > 0) {
								if (he(b.sizeTree)) return b
								let P = Xt()
								const z = Me(x)
								let v = 0,
									L = 0,
									M = 0
								for (; v < -S; ) {
									M = z[L]
									const B = z[L + 1] - M - 1
									L++, (v += B + 1)
								}
								if (
									((P = zt(b.sizeTree).reduce(
										(B, { k: C, v: j }) => Ye(B, Math.max(0, C + S), j),
										P,
									)),
									v !== -S)
								) {
									const B = vn(b.sizeTree, M)
									P = Ye(P, 0, B)
									const C = st(b.sizeTree, -S + 1)[1]
									P = Ye(P, 1, C)
								}
								return { ...b, sizeTree: P, ...ki(b.offsetTree, 0, P, T) }
							} else {
								const P = zt(b.sizeTree).reduce(
									(z, { k: v, v: L }) => Ye(z, Math.max(0, v + S), L),
									Xt(),
								)
								return { ...b, sizeTree: P, ...ki(b.offsetTree, 0, P, T) }
							}
						}),
					),
					y,
				),
				{
					beforeUnshiftWith: w,
					data: h,
					defaultItemSize: m,
					firstItemIndex: a,
					fixedItemSize: u,
					gap: p,
					groupIndices: l,
					itemSize: c,
					listRefresh: _,
					shiftWith: s,
					shiftWithOffset: I,
					sizeRanges: n,
					sizes: y,
					statefulTotalCount: i,
					totalCount: r,
					trackItemSizes: d,
					unshiftWith: o,
				}
			)
		},
		_e(Rt, Ui),
		{ singleton: !0 },
	)
function _c(e) {
	return e.reduce((t, n) => (t.groupIndices.push(t.totalCount), (t.totalCount += n + 1), t), {
		groupIndices: [],
		totalCount: 0,
	})
}
const wa = ae(
		([{ groupIndices: e, sizes: t, totalCount: n }, { headerHeight: r, scrollTop: i }]) => {
			const o = ie(),
				s = ie(),
				a = Xe(O(o, G(_c)))
			return (
				U(
					O(
						a,
						G((l) => l.totalCount),
					),
					n,
				),
				U(
					O(
						a,
						G((l) => l.groupIndices),
					),
					e,
				),
				U(
					O(
						Te(i, t, r),
						K(([l, u]) => Rr(u)),
						G(([l, u, m]) => st(u.groupOffsetTree, Math.max(l - m, 0), "v")[0]),
						ge(),
						G((l) => [l]),
					),
					s,
				),
				{ groupCounts: o, topItemsIndexes: s }
			)
		},
		_e(ft, He),
	),
	Lt = ae(
		([{ log: e }]) => {
			const t = F(!1),
				n = Xe(
					O(
						t,
						K((r) => r),
						ge(),
					),
				)
			return (
				ce(t, (r) => {
					r && Me(e)("props updated", {}, Qe.DEBUG)
				}),
				{ didMount: n, propsReady: t }
			)
		},
		_e(Rt),
		{ singleton: !0 },
	),
	yc = typeof document < "u" && "scrollBehavior" in document.documentElement.style
function Ea(e) {
	const t = typeof e == "number" ? { index: e } : e
	return t.align || (t.align = "start"), (!t.behavior || !yc) && (t.behavior = "auto"), t.offset || (t.offset = 0), t
}
const Dn = ae(
	([
		{ gap: e, listRefresh: t, sizes: n, totalCount: r },
		{
			fixedFooterHeight: i,
			fixedHeaderHeight: o,
			footerHeight: s,
			headerHeight: a,
			scrollingInProgress: l,
			scrollTo: u,
			smoothScrollTargetReached: m,
			viewportHeight: c,
		},
		{ log: h },
	]) => {
		const p = ie(),
			f = ie(),
			y = F(0)
		let x = null,
			d = null,
			_ = null
		function w() {
			x && (x(), (x = null)), _ && (_(), (_ = null)), d && (clearTimeout(d), (d = null)), ee(l, !1)
		}
		return (
			U(
				O(
					p,
					ne(n, c, r, y, a, s, h),
					ne(e, o, i),
					G(([[I, S, b, T, P, z, v, L], M, B, C]) => {
						const j = Ea(I),
							{ align: Z, behavior: le, offset: xe } = j,
							Ee = T - 1,
							k = ka(j, S, Ee)
						let pe = In(k, S.offsetTree, M) + z
						Z === "end"
							? ((pe += B + st(S.sizeTree, k)[1] - b + C), k === Ee && (pe += v))
							: Z === "center"
								? (pe += (B + st(S.sizeTree, k)[1] - b + C) / 2)
								: (pe -= P),
							xe && (pe += xe)
						const Le = (E) => {
							w(),
								E
									? (L("retrying to scroll to", { location: I }, Qe.DEBUG), ee(p, I))
									: (ee(f, !0), L("list did not change, scroll successful", {}, Qe.DEBUG))
						}
						if ((w(), le === "smooth")) {
							let E = !1
							;(_ = ce(t, (Pe) => {
								E = E || Pe
							})),
								(x = ht(m, () => {
									Le(E)
								}))
						} else x = ht(O(t, xc(150)), Le)
						return (
							(d = setTimeout(() => {
								w()
							}, 1200)),
							ee(l, !0),
							L("scrolling from index to", { behavior: le, index: k, top: pe }, Qe.DEBUG),
							{ behavior: le, top: pe }
						)
					}),
				),
				u,
			),
			{ scrollTargetReached: f, scrollToIndex: p, topListHeight: y }
		)
	},
	_e(ft, He, Rt),
	{ singleton: !0 },
)
function xc(e) {
	return (t) => {
		const n = setTimeout(() => {
			t(!1)
		}, e)
		return (r) => {
			r && (t(!0), clearTimeout(n))
		}
	}
}
function Wi(e, t) {
	e == 0
		? t()
		: requestAnimationFrame(() => {
				Wi(e - 1, t)
			})
}
function Ki(e, t) {
	const n = t - 1
	return typeof e == "number" ? e : e.index === "LAST" ? n : e.index
}
const Nn = ae(
	([
		{ defaultItemSize: e, listRefresh: t, sizes: n },
		{ scrollTop: r },
		{ scrollTargetReached: i, scrollToIndex: o },
		{ didMount: s },
	]) => {
		const a = F(!0),
			l = F(0),
			u = F(!0)
		return (
			U(
				O(
					s,
					ne(l),
					K(([m, c]) => !!c),
					mt(!1),
				),
				a,
			),
			U(
				O(
					s,
					ne(l),
					K(([m, c]) => !!c),
					mt(!1),
				),
				u,
			),
			ce(
				O(
					Te(t, s),
					ne(a, n, e, u),
					K(([[, m], c, { sizeTree: h }, p, f]) => m && (!he(h) || Hi(p)) && !c && !f),
					ne(l),
				),
				([, m]) => {
					ht(i, () => {
						ee(u, !0)
					}),
						Wi(4, () => {
							ht(r, () => {
								ee(a, !0)
							}),
								ee(o, m)
						})
				},
			),
			{ initialItemFinalLocationReached: u, initialTopMostItemIndex: l, scrolledToInitialItem: a }
		)
	},
	_e(ft, He, Dn, Lt),
	{ singleton: !0 },
)
function va(e, t) {
	return Math.abs(e - t) < 1.01
}
const Tn = "up",
	_n = "down",
	bc = "none",
	kc = {
		atBottom: !1,
		notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
		state: { offsetBottom: 0, scrollHeight: 0, scrollTop: 0, viewportHeight: 0 },
	},
	wc = 0,
	Mn = ae(
		([
			{ footerHeight: e, headerHeight: t, scrollBy: n, scrollContainerState: r, scrollTop: i, viewportHeight: o },
		]) => {
			const s = F(!1),
				a = F(!0),
				l = ie(),
				u = ie(),
				m = F(4),
				c = F(wc),
				h = ze(O(Lo(O(Y(i), Zt(1), mt(!0)), O(Y(i), Zt(1), mt(!1), Ro(100))), ge()), !1),
				p = ze(O(Lo(O(n, mt(!0)), O(n, mt(!1), Ro(200))), ge()), !1)
			U(
				O(
					Te(Y(i), Y(c)),
					G(([_, w]) => _ <= w),
					ge(),
				),
				a,
			),
				U(O(a, Tt(50)), u)
			const f = Xe(
					O(
						Te(r, Y(o), Y(t), Y(e), Y(m)),
						pt((_, [{ scrollHeight: w, scrollTop: I }, S, b, T, P]) => {
							const z = I + S - w > -P,
								v = { scrollHeight: w, scrollTop: I, viewportHeight: S }
							if (z) {
								let M, B
								return (
									I > _.state.scrollTop
										? ((M = "SCROLLED_DOWN"), (B = _.state.scrollTop - I))
										: ((M = "SIZE_DECREASED"), (B = _.state.scrollTop - I || _.scrollTopDelta)),
									{ atBottom: !0, atBottomBecause: M, scrollTopDelta: B, state: v }
								)
							}
							let L
							return (
								v.scrollHeight > _.state.scrollHeight
									? (L = "SIZE_INCREASED")
									: S < _.state.viewportHeight
										? (L = "VIEWPORT_HEIGHT_DECREASING")
										: I < _.state.scrollTop
											? (L = "SCROLLING_UPWARDS")
											: (L = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM"),
								{ atBottom: !1, notAtBottomBecause: L, state: v }
							)
						}, kc),
						ge((_, w) => _ && _.atBottom === w.atBottom),
					),
				),
				y = ze(
					O(
						r,
						pt(
							(_, { scrollHeight: w, scrollTop: I, viewportHeight: S }) => {
								if (va(_.scrollHeight, w))
									return { changed: !1, jump: 0, scrollHeight: w, scrollTop: I }
								{
									const b = w - (I + S) < 1
									return _.scrollTop !== I && b
										? { changed: !0, jump: _.scrollTop - I, scrollHeight: w, scrollTop: I }
										: { changed: !0, jump: 0, scrollHeight: w, scrollTop: I }
								}
							},
							{ changed: !1, jump: 0, scrollHeight: 0, scrollTop: 0 },
						),
						K((_) => _.changed),
						G((_) => _.jump),
					),
					0,
				)
			U(
				O(
					f,
					G((_) => _.atBottom),
				),
				s,
			),
				U(O(s, Tt(50)), l)
			const x = F(_n)
			U(
				O(
					r,
					G(({ scrollTop: _ }) => _),
					ge(),
					pt(
						(_, w) =>
							Me(p)
								? { direction: _.direction, prevScrollTop: w }
								: { direction: w < _.prevScrollTop ? Tn : _n, prevScrollTop: w },
						{ direction: _n, prevScrollTop: 0 },
					),
					G((_) => _.direction),
				),
				x,
			),
				U(O(r, Tt(50), mt(bc)), x)
			const d = F(0)
			return (
				U(
					O(
						h,
						K((_) => !_),
						mt(0),
					),
					d,
				),
				U(
					O(
						i,
						Tt(100),
						ne(h),
						K(([_, w]) => !!w),
						pt(([_, w], [I]) => [w, I], [0, 0]),
						G(([_, w]) => w - _),
					),
					d,
				),
				{
					atBottomState: f,
					atBottomStateChange: l,
					atBottomThreshold: m,
					atTopStateChange: u,
					atTopThreshold: c,
					isAtBottom: s,
					isAtTop: a,
					isScrolling: h,
					lastJumpDueToItemResize: y,
					scrollDirection: x,
					scrollVelocity: d,
				}
			)
		},
		_e(He),
	),
	ar = "top",
	lr = "bottom",
	No = "none"
function Mo(e, t, n) {
	return typeof e == "number"
		? (n === Tn && t === ar) || (n === _n && t === lr)
			? e
			: 0
		: n === Tn
			? t === ar
				? e.main
				: e.reverse
			: t === lr
				? e.main
				: e.reverse
}
function zo(e, t) {
	var n
	return typeof e == "number" ? e : (n = e[t]) != null ? n : 0
}
const Yi = ae(
	([{ deviation: e, fixedHeaderHeight: t, headerHeight: n, scrollTop: r, viewportHeight: i }]) => {
		const o = ie(),
			s = F(0),
			a = F(0),
			l = F(0),
			u = ze(
				O(
					Te(Y(r), Y(i), Y(n), Y(o, Sn), Y(l), Y(s), Y(t), Y(e), Y(a)),
					G(([m, c, h, [p, f], y, x, d, _, w]) => {
						const I = m - _,
							S = x + d,
							b = Math.max(h - I, 0)
						let T = No
						const P = zo(w, ar),
							z = zo(w, lr)
						return (
							(p -= _),
							(p += h + d),
							(f += h + d),
							(f -= _),
							p > m + S - P && (T = Tn),
							f < m - b + c + z && (T = _n),
							T !== No ? [Math.max(I - h - Mo(y, ar, T) - P, 0), I - b - d + c + Mo(y, lr, T) + z] : null
						)
					}),
					K((m) => m != null),
					ge(Sn),
				),
				[0, 0],
			)
		return { increaseViewportBy: a, listBoundary: o, overscan: l, topListHeight: s, visibleRange: u }
	},
	_e(He),
	{ singleton: !0 },
)
function Ec(e, t, n) {
	if (Rr(t)) {
		const r = ba(e, t)
		return [
			{ index: st(t.groupOffsetTree, r)[0], offset: 0, size: 0 },
			{ data: n == null ? void 0 : n[0], index: r, offset: 0, size: 0 },
		]
	}
	return [{ data: n == null ? void 0 : n[0], index: e, offset: 0, size: 0 }]
}
const Gr = {
	bottom: 0,
	firstItemIndex: 0,
	items: [],
	offsetBottom: 0,
	offsetTop: 0,
	top: 0,
	topItems: [],
	topListHeight: 0,
	totalCount: 0,
}
function nr(e, t, n, r, i, o) {
	const { lastIndex: s, lastOffset: a, lastSize: l } = i
	let u = 0,
		m = 0
	if (e.length > 0) {
		u = e[0].offset
		const y = e[e.length - 1]
		m = y.offset + y.size
	}
	const c = n - s,
		h = a + c * l + (c - 1) * r,
		p = u,
		f = h - m
	return {
		bottom: m,
		firstItemIndex: o,
		items: Vo(e, i, o),
		offsetBottom: f,
		offsetTop: u,
		top: p,
		topItems: Vo(t, i, o),
		topListHeight: t.reduce((y, x) => x.size + y, 0),
		totalCount: n,
	}
}
function Sa(e, t, n, r, i, o) {
	let s = 0
	if (n.groupIndices.length > 0)
		for (const m of n.groupIndices) {
			if (m - s >= e) break
			s++
		}
	const a = e + s,
		l = Ki(t, a),
		u = Array.from({ length: a }).map((m, c) => ({ data: o[c + l], index: c + l, offset: 0, size: 0 }))
	return nr(u, [], a, i, n, r)
}
function Vo(e, t, n) {
	if (e.length === 0) return []
	if (!Rr(t)) return e.map((u) => ({ ...u, index: u.index + n, originalIndex: u.index }))
	const r = e[0].index,
		i = e[e.length - 1].index,
		o = [],
		s = Ar(t.groupOffsetTree, r, i)
	let a,
		l = 0
	for (const u of e) {
		;(!a || a.end < u.index) && ((a = s.shift()), (l = t.groupIndices.indexOf(a.start)))
		let m
		u.index === a.start ? (m = { index: l, type: "group" }) : (m = { groupIndex: l, index: u.index - (l + 1) + n }),
			o.push({ ...m, data: u.data, offset: u.offset, originalIndex: u.index, size: u.size })
	}
	return o
}
const Ht = ae(
		([
			{ data: e, firstItemIndex: t, gap: n, sizes: r, totalCount: i },
			o,
			{ listBoundary: s, topListHeight: a, visibleRange: l },
			{ initialTopMostItemIndex: u, scrolledToInitialItem: m },
			{ topListHeight: c },
			h,
			{ didMount: p },
			{ recalcInProgress: f },
		]) => {
			const y = F([]),
				x = F(0),
				d = ie()
			U(o.topItemsIndexes, y)
			const _ = ze(
				O(
					Te(p, f, Y(l, Sn), Y(i), Y(r), Y(u), m, Y(y), Y(t), Y(n), e),
					K(([b, T, , P, , , , , , , z]) => {
						const v = z && z.length !== P
						return b && !T && !v
					}),
					G(([, , [b, T], P, z, v, L, M, B, C, j]) => {
						const Z = z,
							{ offsetTree: le, sizeTree: xe } = Z,
							Ee = Me(x)
						if (P === 0) return { ...Gr, totalCount: P }
						if (b === 0 && T === 0) return Ee === 0 ? { ...Gr, totalCount: P } : Sa(Ee, v, z, B, C, j || [])
						if (he(xe)) return Ee > 0 ? null : nr(Ec(Ki(v, P), Z, j), [], P, C, Z, B)
						const k = []
						if (M.length > 0) {
							const Ge = M[0],
								me = M[M.length - 1]
							let Fe = 0
							for (const V of Ar(xe, Ge, me)) {
								const X = V.value,
									se = Math.max(V.start, Ge),
									ke = Math.min(V.end, me)
								for (let be = se; be <= ke; be++)
									k.push({ data: j == null ? void 0 : j[be], index: be, offset: Fe, size: X }),
										(Fe += X)
							}
						}
						if (!L) return nr([], k, P, C, Z, B)
						const pe = M.length > 0 ? M[M.length - 1] + 1 : 0,
							Le = mc(le, b, T, pe)
						if (Le.length === 0) return null
						const E = P - 1,
							Pe = Cr([], (Ge) => {
								for (const me of Le) {
									const Fe = me.value
									let V = Fe.offset,
										X = me.start
									const se = Fe.size
									if (Fe.offset < b) {
										X += Math.floor((b - Fe.offset + C) / (se + C))
										const be = X - me.start
										V += be * se + be * C
									}
									X < pe && ((V += (pe - X) * se), (X = pe))
									const ke = Math.min(me.end, E)
									for (let be = X; be <= ke && !(V >= T); be++)
										Ge.push({ data: j == null ? void 0 : j[be], index: be, offset: V, size: se }),
											(V += se + C)
								}
							})
						return nr(Pe, k, P, C, Z, B)
					}),
					K((b) => b !== null),
					ge(),
				),
				Gr,
			)
			U(
				O(
					e,
					K(Hi),
					G((b) => (b == null ? void 0 : b.length)),
				),
				i,
			),
				U(
					O(
						_,
						G((b) => b.topListHeight),
					),
					c,
				),
				U(c, a),
				U(
					O(
						_,
						G((b) => [b.top, b.bottom]),
					),
					s,
				),
				U(
					O(
						_,
						G((b) => b.items),
					),
					d,
				)
			const w = Xe(
					O(
						_,
						K(({ items: b }) => b.length > 0),
						ne(i, e),
						K(([{ items: b }, T]) => b[b.length - 1].originalIndex === T - 1),
						G(([, b, T]) => [b - 1, T]),
						ge(Sn),
						G(([b]) => b),
					),
				),
				I = Xe(
					O(
						_,
						Tt(200),
						K(({ items: b, topItems: T }) => b.length > 0 && b[0].originalIndex === T.length),
						G(({ items: b }) => b[0].index),
						ge(),
					),
				),
				S = Xe(
					O(
						_,
						K(({ items: b }) => b.length > 0),
						G(({ items: b }) => {
							let T = 0,
								P = b.length - 1
							for (; b[T].type === "group" && T < P; ) T++
							for (; b[P].type === "group" && P > T; ) P--
							return { endIndex: b[P].index, startIndex: b[T].index }
						}),
						ge(ya),
					),
				)
			return {
				endReached: w,
				initialItemCount: x,
				itemsRendered: d,
				listState: _,
				rangeChanged: S,
				startReached: I,
				topItemsIndexes: y,
				...h,
			}
		},
		_e(ft, wa, Yi, Nn, Dn, Mn, Lt, Ui),
		{ singleton: !0 },
	),
	Ia = ae(
		([{ fixedFooterHeight: e, fixedHeaderHeight: t, footerHeight: n, headerHeight: r }, { listState: i }]) => {
			const o = ie(),
				s = ze(
					O(
						Te(n, e, r, t, i),
						G(([a, l, u, m, c]) => a + l + u + m + c.offsetBottom + c.bottom),
					),
					0,
				)
			return U(Y(s), o), { totalListHeight: s, totalListHeightChanged: o }
		},
		_e(He, Ht),
		{ singleton: !0 },
	),
	vc = ae(
		([{ viewportHeight: e }, { totalListHeight: t }]) => {
			const n = F(!1),
				r = ze(
					O(
						Te(n, e, t),
						K(([i]) => i),
						G(([, i, o]) => Math.max(0, i - o)),
						Tt(0),
						ge(),
					),
					0,
				)
			return { alignToBottom: n, paddingTopAddition: r }
		},
		_e(He, Ia),
		{ singleton: !0 },
	)
function Bo(e) {
	return e ? (e === "smooth" ? "smooth" : "auto") : !1
}
const Sc = (e, t) => (typeof e == "function" ? Bo(e(t)) : t && Bo(e)),
	Ic = ae(
		([
			{ listRefresh: e, totalCount: t },
			{ atBottomState: n, isAtBottom: r },
			{ scrollToIndex: i },
			{ scrolledToInitialItem: o },
			{ didMount: s, propsReady: a },
			{ log: l },
			{ scrollingInProgress: u },
		]) => {
			const m = F(!1),
				c = ie()
			let h = null
			function p(y) {
				ee(i, { align: "end", behavior: y, index: "LAST" })
			}
			ce(
				O(
					Te(O(Y(t), Zt(1)), s),
					ne(Y(m), r, o, u),
					G(([[y, x], d, _, w, I]) => {
						let S = x && w,
							b = "auto"
						return (
							S && ((b = Sc(d, _ || I)), (S = S && !!b)),
							{ followOutputBehavior: b, shouldFollow: S, totalCount: y }
						)
					}),
					K(({ shouldFollow: y }) => y),
				),
				({ followOutputBehavior: y, totalCount: x }) => {
					h && (h(), (h = null)),
						(h = ht(e, () => {
							Me(l)("following output to ", { totalCount: x }, Qe.DEBUG), p(y), (h = null)
						}))
				},
			)
			function f(y) {
				const x = ht(n, (d) => {
					y &&
						!d.atBottom &&
						d.notAtBottomBecause === "SIZE_INCREASED" &&
						!h &&
						(Me(l)("scrolling to bottom due to increased size", {}, Qe.DEBUG), p("auto"))
				})
				setTimeout(x, 100)
			}
			return (
				ce(
					O(
						Te(Y(m), t, a),
						K(([y, , x]) => y && x),
						pt(({ value: y }, [, x]) => ({ refreshed: y === x, value: x }), { refreshed: !1, value: 0 }),
						K(({ refreshed: y }) => y),
						ne(m, t),
					),
					([, y]) => {
						Me(o) && f(y !== !1)
					},
				),
				ce(c, () => {
					f(Me(m) !== !1)
				}),
				ce(Te(Y(m), n), ([y, x]) => {
					y && !x.atBottom && x.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && p("auto")
				}),
				{ autoscrollToBottom: c, followOutput: m }
			)
		},
		_e(ft, Mn, Dn, Nn, Lt, Rt, He),
	),
	Tc = ae(
		([
			{ data: e, firstItemIndex: t, gap: n, sizes: r },
			{ initialTopMostItemIndex: i },
			{ initialItemCount: o, listState: s },
			{ didMount: a },
		]) => (
			U(
				O(
					a,
					ne(o),
					K(([, l]) => l !== 0),
					ne(i, r, t, n, e),
					G(([[, l], u, m, c, h, p = []]) => Sa(l, u, m, c, h, p)),
				),
				s,
			),
			{}
		),
		_e(ft, Nn, Ht, Lt),
		{ singleton: !0 },
	),
	Cc = ae(
		([{ didMount: e }, { scrollTo: t }, { listState: n }]) => {
			const r = F(0)
			return (
				ce(
					O(
						e,
						ne(r),
						K(([, i]) => i !== 0),
						G(([, i]) => ({ top: i })),
					),
					(i) => {
						ht(
							O(
								n,
								Zt(1),
								K((o) => o.items.length > 1),
							),
							() => {
								requestAnimationFrame(() => {
									ee(t, i)
								})
							},
						)
					},
				),
				{ initialScrollTop: r }
			)
		},
		_e(Lt, He, Ht),
		{ singleton: !0 },
	),
	Ac = ({
		itemBottom: e,
		itemTop: t,
		locationParams: { align: n, behavior: r, ...i },
		viewportBottom: o,
		viewportTop: s,
	}) =>
		t < s ? { ...i, align: n ?? "start", behavior: r } : e > o ? { ...i, align: n ?? "end", behavior: r } : null,
	Rc = ae(
		([
			{ gap: e, sizes: t, totalCount: n },
			{
				fixedFooterHeight: r,
				fixedHeaderHeight: i,
				headerHeight: o,
				scrollingInProgress: s,
				scrollTop: a,
				viewportHeight: l,
			},
			{ scrollToIndex: u },
		]) => {
			const m = ie()
			return (
				U(
					O(
						m,
						ne(t, l, n, o, i, r, a),
						ne(e),
						G(([[c, h, p, f, y, x, d, _], w]) => {
							const { align: I, behavior: S, calculateViewLocation: b = Ac, done: T, ...P } = c,
								z = ka(c, h, f - 1),
								v = In(z, h.offsetTree, w) + y + x,
								L = v + st(h.sizeTree, z)[1],
								M = _ + x,
								B = _ + p - d,
								C = b({
									itemBottom: L,
									itemTop: v,
									locationParams: { align: I, behavior: S, ...P },
									viewportBottom: B,
									viewportTop: M,
								})
							return (
								C
									? T &&
										ht(
											O(
												s,
												K((j) => !j),
												Zt(Me(s) ? 1 : 2),
											),
											T,
										)
									: T && T(),
								C
							)
						}),
						K((c) => c !== null),
					),
					u,
				),
				{ scrollIntoView: m }
			)
		},
		_e(ft, He, Dn, Ht, Rt),
		{ singleton: !0 },
	),
	Ta = ae(
		([{ scrollVelocity: e }]) => {
			const t = F(!1),
				n = ie(),
				r = F(!1)
			return (
				U(
					O(
						e,
						ne(r, t, n),
						K(([i, o]) => !!o),
						G(([i, o, s, a]) => {
							const { enter: l, exit: u } = o
							if (s) {
								if (u(i, a)) return !1
							} else if (l(i, a)) return !0
							return s
						}),
						ge(),
					),
					t,
				),
				ce(O(Te(t, e, n), ne(r)), ([[i, o, s], a]) => {
					i && a && a.change && a.change(o, s)
				}),
				{ isSeeking: t, scrollSeekConfiguration: r, scrollSeekRangeChanged: n, scrollVelocity: e }
			)
		},
		_e(Mn),
		{ singleton: !0 },
	),
	Xi = ae(([{ scrollContainerState: e, scrollTo: t }]) => {
		const n = ie(),
			r = ie(),
			i = ie(),
			o = F(!1),
			s = F(void 0)
		return (
			U(
				O(
					Te(n, r),
					G(([{ scrollHeight: a, scrollTop: l, viewportHeight: u }, { offsetTop: m }]) => ({
						scrollHeight: a,
						scrollTop: Math.max(0, l - m),
						viewportHeight: u,
					})),
				),
				e,
			),
			U(
				O(
					t,
					ne(r),
					G(([a, { offsetTop: l }]) => ({ ...a, top: a.top + l })),
				),
				i,
			),
			{
				customScrollParent: s,
				useWindowScroll: o,
				windowScrollContainerState: n,
				windowScrollTo: i,
				windowViewportRect: r,
			}
		)
	}, _e(He)),
	Lc = ae(
		([
			{ sizeRanges: e, sizes: t },
			{ headerHeight: n, scrollTop: r },
			{ initialTopMostItemIndex: i },
			{ didMount: o },
			{ useWindowScroll: s, windowScrollContainerState: a, windowViewportRect: l },
		]) => {
			const u = ie(),
				m = F(void 0),
				c = F(null),
				h = F(null)
			return (
				U(a, c),
				U(l, h),
				ce(O(u, ne(t, r, s, c, h, n)), ([p, f, y, x, d, _, w]) => {
					const I = hc(f.sizeTree)
					x && d !== null && _ !== null && (y = d.scrollTop - _.offsetTop),
						(y -= w),
						p({ ranges: I, scrollTop: y })
				}),
				U(O(m, K(Hi), G(Pc)), i),
				U(
					O(
						o,
						ne(m),
						K(([, p]) => p !== void 0),
						ge(),
						G(([, p]) => p.ranges),
					),
					e,
				),
				{ getState: u, restoreStateFrom: m }
			)
		},
		_e(ft, He, Nn, Lt, Xi),
	)
function Pc(e) {
	return { align: "start", index: 0, offset: e.scrollTop }
}
const Oc = ae(([{ topItemsIndexes: e }]) => {
	const t = F(0)
	return (
		U(
			O(
				t,
				K((n) => n >= 0),
				G((n) => Array.from({ length: n }).map((r, i) => i)),
			),
			e,
		),
		{ topItemCount: t }
	)
}, _e(Ht))
function Ca(e) {
	let t = !1,
		n
	return () => (t || ((t = !0), (n = e())), n)
}
const Dc = Ca(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent)),
	Nc = ae(
		([
			{ deviation: e, scrollBy: t, scrollingInProgress: n, scrollTop: r },
			{ isAtBottom: i, isScrolling: o, lastJumpDueToItemResize: s, scrollDirection: a },
			{ listState: l },
			{ beforeUnshiftWith: u, gap: m, shiftWithOffset: c, sizes: h },
			{ log: p },
			{ recalcInProgress: f },
		]) => {
			const y = Xe(
				O(
					l,
					ne(s),
					pt(
						([, d, _, w], [{ bottom: I, items: S, offsetBottom: b, totalCount: T }, P]) => {
							const z = I + b
							let v = 0
							return (
								_ === T &&
									d.length > 0 &&
									S.length > 0 &&
									((S[0].originalIndex === 0 && d[0].originalIndex === 0) ||
										((v = z - w), v !== 0 && (v += P))),
								[v, S, T, z]
							)
						},
						[0, [], 0, 0],
					),
					K(([d]) => d !== 0),
					ne(r, a, n, i, p, f),
					K(([, d, _, w, , , I]) => !I && !w && d !== 0 && _ === Tn),
					G(([[d], , , , , _]) => (_("Upward scrolling compensation", { amount: d }, Qe.DEBUG), d)),
				),
			)
			function x(d) {
				d > 0
					? (ee(t, { behavior: "auto", top: -d }), ee(e, 0))
					: (ee(e, 0), ee(t, { behavior: "auto", top: -d }))
			}
			return (
				ce(O(y, ne(e, o)), ([d, _, w]) => {
					w && Dc() ? ee(e, _ - d) : x(-d)
				}),
				ce(
					O(
						Te(ze(o, !1), e, f),
						K(([d, _, w]) => !d && !w && _ !== 0),
						G(([d, _]) => _),
						Tt(1),
					),
					x,
				),
				U(
					O(
						c,
						G((d) => ({ top: -d })),
					),
					t,
				),
				ce(
					O(
						u,
						ne(h, m),
						G(([d, { groupIndices: _, lastSize: w, sizeTree: I }, S]) => {
							function b(T) {
								return T * (w + S)
							}
							if (_.length === 0) return b(d)
							{
								let T = 0
								const P = vn(I, 0)
								let z = 0,
									v = 0
								for (; z < d; ) {
									z++, (T += P)
									let L = _.length === v + 1 ? 1 / 0 : _[v + 1] - _[v] - 1
									z + L > d && ((T -= P), (L = d - z + 1)), (z += L), (T += b(L)), v++
								}
								return T
							}
						}),
					),
					(d) => {
						ee(e, d),
							requestAnimationFrame(() => {
								ee(t, { top: d }),
									requestAnimationFrame(() => {
										ee(e, 0), ee(f, !1)
									})
							})
					},
				),
				{ deviation: e }
			)
		},
		_e(He, Mn, Ht, ft, Rt, Ui),
	),
	Mc = ae(
		([e, t, n, r, i, o, s, a, l, u]) => ({ ...e, ...t, ...n, ...r, ...i, ...o, ...s, ...a, ...l, ...u }),
		_e(Yi, Tc, Lt, Ta, Ia, Cc, vc, Xi, Rc, Rt),
	),
	Aa = ae(
		([
			{
				data: e,
				defaultItemSize: t,
				firstItemIndex: n,
				fixedItemSize: r,
				gap: i,
				groupIndices: o,
				itemSize: s,
				sizeRanges: a,
				sizes: l,
				statefulTotalCount: u,
				totalCount: m,
				trackItemSizes: c,
			},
			{ initialItemFinalLocationReached: h, initialTopMostItemIndex: p, scrolledToInitialItem: f },
			y,
			x,
			d,
			{ listState: _, topItemsIndexes: w, ...I },
			{ scrollToIndex: S },
			b,
			{ topItemCount: T },
			{ groupCounts: P },
			z,
		]) => (
			U(I.rangeChanged, z.scrollSeekRangeChanged),
			U(
				O(
					z.windowViewportRect,
					G((v) => v.visibleHeight),
				),
				y.viewportHeight,
			),
			{
				data: e,
				defaultItemHeight: t,
				firstItemIndex: n,
				fixedItemHeight: r,
				gap: i,
				groupCounts: P,
				initialItemFinalLocationReached: h,
				initialTopMostItemIndex: p,
				scrolledToInitialItem: f,
				sizeRanges: a,
				topItemCount: T,
				topItemsIndexes: w,
				totalCount: m,
				...d,
				groupIndices: o,
				itemSize: s,
				listState: _,
				scrollToIndex: S,
				statefulTotalCount: u,
				trackItemSizes: c,
				...I,
				...z,
				...y,
				sizes: l,
				...x,
			}
		),
		_e(ft, Nn, He, Lc, Ic, Ht, Dn, Nc, Oc, wa, Mc),
	)
function zc(e, t) {
	const n = {},
		r = {}
	let i = 0
	const o = e.length
	for (; i < o; ) (r[e[i]] = 1), (i += 1)
	for (const s in t) Object.hasOwn(r, s) || (n[s] = t[s])
	return n
}
const $n = typeof document < "u" ? $.useLayoutEffect : $.useEffect
function Ra(e, t, n) {
	const r = Object.keys(t.required || {}),
		i = Object.keys(t.optional || {}),
		o = Object.keys(t.methods || {}),
		s = Object.keys(t.events || {}),
		a = $.createContext({})
	function l(x, d) {
		x.propsReady && ee(x.propsReady, !1)
		for (const _ of r) {
			const w = x[t.required[_]]
			ee(w, d[_])
		}
		for (const _ of i)
			if (_ in d) {
				const w = x[t.optional[_]]
				ee(w, d[_])
			}
		x.propsReady && ee(x.propsReady, !0)
	}
	function u(x) {
		return o.reduce(
			(d, _) => (
				(d[_] = (w) => {
					const I = x[t.methods[_]]
					ee(I, w)
				}),
				d
			),
			{},
		)
	}
	function m(x) {
		return s.reduce((d, _) => ((d[_] = Ju(x[t.events[_]])), d), {})
	}
	const c = $.forwardRef((x, d) => {
			const { children: _, ...w } = x,
				[I] = $.useState(() =>
					Cr(ec(e), (T) => {
						l(T, w)
					}),
				),
				[S] = $.useState(Ao(m, I))
			$n(() => {
				for (const T of s) T in w && ce(S[T], w[T])
				return () => {
					Object.values(S).map(Gi)
				}
			}, [w, S, I]),
				$n(() => {
					l(I, w)
				}),
				$.useImperativeHandle(d, Co(u(I)))
			const b = n
			return D.jsx(a.Provider, {
				value: I,
				children: n ? D.jsx(b, { ...zc([...r, ...i, ...s], w), children: _ }) : _,
			})
		}),
		h = (x) => {
			const d = $.useContext(a)
			return $.useCallback(
				(_) => {
					ee(d[x], _)
				},
				[d, x],
			)
		},
		p = (x) => {
			const d = $.useContext(a)[x],
				_ = $.useCallback((w) => ce(d, w), [d])
			return $.useSyncExternalStore(
				_,
				() => Me(d),
				() => Me(d),
			)
		},
		f = (x) => {
			const d = $.useContext(a)[x],
				[_, w] = $.useState(Ao(Me, d))
			return (
				$n(
					() =>
						ce(d, (I) => {
							I !== _ && w(Co(I))
						}),
					[d, _],
				),
				_
			)
		},
		y = $.version.startsWith("18") ? p : f
	return {
		Component: c,
		useEmitter: (x, d) => {
			const _ = $.useContext(a)[x]
			$n(() => ce(_, d), [d, _])
		},
		useEmitterValue: y,
		usePublisher: h,
	}
}
const La = $.createContext(void 0),
	Pa = $.createContext(void 0),
	Oa = typeof document < "u" ? $.useLayoutEffect : $.useEffect
function $r(e) {
	return "self" in e
}
function Vc(e) {
	return "body" in e
}
function Da(e, t, n, r = rn, i, o) {
	const s = $.useRef(null),
		a = $.useRef(null),
		l = $.useRef(null),
		u = $.useCallback(
			(h) => {
				let p, f, y
				const x = h.target
				if (Vc(x) || $r(x)) {
					const _ = $r(x) ? x : x.defaultView
					;(y = o ? _.scrollX : _.scrollY),
						(p = o ? _.document.documentElement.scrollWidth : _.document.documentElement.scrollHeight),
						(f = o ? _.innerWidth : _.innerHeight)
				} else
					(y = o ? x.scrollLeft : x.scrollTop),
						(p = o ? x.scrollWidth : x.scrollHeight),
						(f = o ? x.offsetWidth : x.offsetHeight)
				const d = () => {
					e({ scrollHeight: p, scrollTop: Math.max(y, 0), viewportHeight: f })
				}
				h.suppressFlushSync ? d() : Mu.flushSync(d),
					a.current !== null &&
						(y === a.current || y <= 0 || y === p - f) &&
						((a.current = null), t(!0), l.current && (clearTimeout(l.current), (l.current = null)))
			},
			[e, t, o],
		)
	$.useEffect(() => {
		const h = i || s.current
		return (
			r(i || s.current),
			u({ suppressFlushSync: !0, target: h }),
			h.addEventListener("scroll", u, { passive: !0 }),
			() => {
				r(null), h.removeEventListener("scroll", u)
			}
		)
	}, [s, u, n, r, i])
	function m(h) {
		const p = s.current
		if (!p || (o ? "offsetWidth" in p && p.offsetWidth === 0 : "offsetHeight" in p && p.offsetHeight === 0)) return
		const f = h.behavior === "smooth"
		let y, x, d
		$r(p)
			? ((x = Math.max(
					Ct(p.document.documentElement, o ? "width" : "height"),
					o ? p.document.documentElement.scrollWidth : p.document.documentElement.scrollHeight,
				)),
				(y = o ? p.innerWidth : p.innerHeight),
				(d = o ? window.scrollX : window.scrollY))
			: ((x = p[o ? "scrollWidth" : "scrollHeight"]),
				(y = Ct(p, o ? "width" : "height")),
				(d = p[o ? "scrollLeft" : "scrollTop"]))
		const _ = x - y
		if (((h.top = Math.ceil(Math.max(Math.min(_, h.top), 0))), va(y, x) || h.top === d)) {
			e({ scrollHeight: x, scrollTop: d, viewportHeight: y }), f && t(!0)
			return
		}
		f
			? ((a.current = h.top),
				l.current && clearTimeout(l.current),
				(l.current = setTimeout(() => {
					;(l.current = null), (a.current = null), t(!0)
				}, 1e3)))
			: (a.current = null),
			o && (h = { behavior: h.behavior, left: h.top }),
			p.scrollTo(h)
	}
	function c(h) {
		o && (h = { behavior: h.behavior, left: h.top }), s.current.scrollBy(h)
	}
	return { scrollByCallback: c, scrollerRef: s, scrollToCallback: m }
}
const Ur = "-webkit-sticky",
	Fo = "sticky",
	Na = Ca(() => {
		if (typeof document > "u") return Fo
		const e = document.createElement("div")
		return (e.style.position = Ur), e.style.position === Ur ? Ur : Fo
	})
function Qi(e) {
	return e
}
const Bc = ae(() => {
		const e = F((l) => `Item ${l}`),
			t = F(null),
			n = F((l) => `Group ${l}`),
			r = F({}),
			i = F(Qi),
			o = F("div"),
			s = F(rn),
			a = (l, u = null) =>
				ze(
					O(
						r,
						G((m) => m[l]),
						ge(),
					),
					u,
				)
		return {
			components: r,
			computeItemKey: i,
			context: t,
			EmptyPlaceholder: a("EmptyPlaceholder"),
			FooterComponent: a("Footer"),
			GroupComponent: a("Group", "div"),
			groupContent: n,
			HeaderComponent: a("Header"),
			HeaderFooterTag: o,
			ItemComponent: a("Item", "div"),
			itemContent: e,
			ListComponent: a("List", "div"),
			ScrollerComponent: a("Scroller", "div"),
			scrollerRef: s,
			ScrollSeekPlaceholder: a("ScrollSeekPlaceholder"),
			TopItemListComponent: a("TopItemList"),
		}
	}),
	Fc = ae(([e, t]) => ({ ...e, ...t }), _e(Aa, Bc)),
	jc = ({ height: e }) => D.jsx("div", { style: { height: e } }),
	Hc = { overflowAnchor: "none", position: Na(), zIndex: 1 },
	Ma = { overflowAnchor: "none" },
	Gc = { ...Ma, display: "inline-block", height: "100%" },
	jo = $.memo(function ({ showTopList: e = !1 }) {
		const t = Q("listState"),
			n = nt("sizeRanges"),
			r = Q("useWindowScroll"),
			i = Q("customScrollParent"),
			o = nt("windowScrollContainerState"),
			s = nt("scrollContainerState"),
			a = i || r ? o : s,
			l = Q("itemContent"),
			u = Q("context"),
			m = Q("groupContent"),
			c = Q("trackItemSizes"),
			h = Q("itemSize"),
			p = Q("log"),
			f = nt("gap"),
			y = Q("horizontalDirection"),
			{ callbackRef: x } = rc(n, h, c, e ? rn : a, p, f, i, y, Q("skipAnimationFrameInResizeObserver")),
			[d, _] = $.useState(0)
		Ji("deviation", (C) => {
			d !== C && _(C)
		})
		const w = Q("EmptyPlaceholder"),
			I = Q("ScrollSeekPlaceholder") || jc,
			S = Q("ListComponent"),
			b = Q("ItemComponent"),
			T = Q("GroupComponent"),
			P = Q("computeItemKey"),
			z = Q("isSeeking"),
			v = Q("groupIndices").length > 0,
			L = Q("alignToBottom"),
			M = Q("initialItemFinalLocationReached"),
			B = e
				? {}
				: {
						boxSizing: "border-box",
						...(y
							? {
									display: "inline-block",
									height: "100%",
									marginLeft: d !== 0 ? d : L ? "auto" : 0,
									paddingLeft: t.offsetTop,
									paddingRight: t.offsetBottom,
									whiteSpace: "nowrap",
								}
							: {
									marginTop: d !== 0 ? d : L ? "auto" : 0,
									paddingBottom: t.offsetBottom,
									paddingTop: t.offsetTop,
								}),
						...(M ? {} : { visibility: "hidden" }),
					}
		return !e && t.totalCount === 0 && w
			? D.jsx(w, { ...Oe(w, u) })
			: D.jsx(S, {
					...Oe(S, u),
					"data-testid": e ? "virtuoso-top-item-list" : "virtuoso-item-list",
					ref: x,
					style: B,
					children: (e ? t.topItems : t.items).map((C) => {
						const j = C.originalIndex,
							Z = P(j + t.firstItemIndex, C.data, u)
						return z
							? we.createElement(I, {
									...Oe(I, u),
									height: C.size,
									index: C.index,
									key: Z,
									type: C.type || "item",
									...(C.type === "group" ? {} : { groupIndex: C.groupIndex }),
								})
							: C.type === "group"
								? we.createElement(
										T,
										{
											...Oe(T, u),
											"data-index": j,
											"data-item-index": C.index,
											"data-known-size": C.size,
											key: Z,
											style: Hc,
										},
										m(C.index, u),
									)
								: we.createElement(
										b,
										{
											...Oe(b, u),
											...Wc(b, C.data),
											"data-index": j,
											"data-item-group-index": C.groupIndex,
											"data-item-index": C.index,
											"data-known-size": C.size,
											key: Z,
											style: y ? Gc : Ma,
										},
										v ? l(C.index, C.groupIndex, C.data, u) : l(C.index, C.data, u),
									)
					}),
				})
	}),
	$c = { height: "100%", outline: "none", overflowY: "auto", position: "relative", WebkitOverflowScrolling: "touch" },
	Uc = { outline: "none", overflowX: "auto", position: "relative" },
	Lr = (e) => ({
		height: "100%",
		position: "absolute",
		top: 0,
		width: "100%",
		...(e ? { display: "flex", flexDirection: "column" } : {}),
	}),
	qc = { position: Na(), top: 0, width: "100%", zIndex: 1 }
function Oe(e, t) {
	if (typeof e != "string") return { context: t }
}
function Wc(e, t) {
	return { item: typeof e == "string" ? void 0 : t }
}
const Kc = $.memo(function () {
		const e = Q("HeaderComponent"),
			t = nt("headerHeight"),
			n = Q("HeaderFooterTag"),
			r = jt(
				$.useMemo(
					() => (o) => {
						t(Ct(o, "height"))
					},
					[t],
				),
				!0,
				Q("skipAnimationFrameInResizeObserver"),
			),
			i = Q("context")
		return e ? D.jsx(n, { ref: r, children: D.jsx(e, { ...Oe(e, i) }) }) : null
	}),
	Yc = $.memo(function () {
		const e = Q("FooterComponent"),
			t = nt("footerHeight"),
			n = Q("HeaderFooterTag"),
			r = jt(
				$.useMemo(
					() => (o) => {
						t(Ct(o, "height"))
					},
					[t],
				),
				!0,
				Q("skipAnimationFrameInResizeObserver"),
			),
			i = Q("context")
		return e ? D.jsx(n, { ref: r, children: D.jsx(e, { ...Oe(e, i) }) }) : null
	})
function za({ useEmitter: e, useEmitterValue: t, usePublisher: n }) {
	return $.memo(function ({ children: r, style: i, ...o }) {
		const s = n("scrollContainerState"),
			a = t("ScrollerComponent"),
			l = n("smoothScrollTargetReached"),
			u = t("scrollerRef"),
			m = t("context"),
			c = t("horizontalDirection") || !1,
			{ scrollByCallback: h, scrollerRef: p, scrollToCallback: f } = Da(s, l, a, u, void 0, c)
		return (
			e("scrollTo", f),
			e("scrollBy", h),
			D.jsx(a, {
				"data-testid": "virtuoso-scroller",
				"data-virtuoso-scroller": !0,
				ref: p,
				style: { ...(c ? Uc : $c), ...i },
				tabIndex: 0,
				...o,
				...Oe(a, m),
				children: r,
			})
		)
	})
}
function Va({ useEmitter: e, useEmitterValue: t, usePublisher: n }) {
	return $.memo(function ({ children: r, style: i, ...o }) {
		const s = n("windowScrollContainerState"),
			a = t("ScrollerComponent"),
			l = n("smoothScrollTargetReached"),
			u = t("totalListHeight"),
			m = t("deviation"),
			c = t("customScrollParent"),
			h = t("context"),
			p = $.useRef(null),
			f = t("scrollerRef"),
			{ scrollByCallback: y, scrollerRef: x, scrollToCallback: d } = Da(s, l, a, f, c)
		return (
			Oa(() => {
				var _
				return (
					(x.current = c || ((_ = p.current) == null ? void 0 : _.ownerDocument.defaultView)),
					() => {
						x.current = null
					}
				)
			}, [x, c]),
			e("windowScrollTo", d),
			e("scrollBy", y),
			D.jsx(a, {
				ref: p,
				"data-virtuoso-scroller": !0,
				style: { position: "relative", ...i, ...(u !== 0 ? { height: u + m } : {}) },
				...o,
				...Oe(a, h),
				children: r,
			})
		)
	})
}
const Xc = ({ children: e }) => {
		const t = $.useContext(La),
			n = nt("viewportHeight"),
			r = nt("fixedItemHeight"),
			i = Q("alignToBottom"),
			o = Q("horizontalDirection"),
			s = $.useMemo(() => ca(n, (l) => Ct(l, o ? "width" : "height")), [n, o]),
			a = jt(s, !0, Q("skipAnimationFrameInResizeObserver"))
		return (
			$.useEffect(() => {
				t && (n(t.viewportHeight), r(t.itemHeight))
			}, [t, n, r]),
			D.jsx("div", { "data-viewport-type": "element", ref: a, style: Lr(i), children: e })
		)
	},
	Qc = ({ children: e }) => {
		const t = $.useContext(La),
			n = nt("windowViewportRect"),
			r = nt("fixedItemHeight"),
			i = Q("customScrollParent"),
			o = pa(n, i, Q("skipAnimationFrameInResizeObserver")),
			s = Q("alignToBottom")
		return (
			$.useEffect(() => {
				t && (r(t.itemHeight), n({ offsetTop: 0, visibleHeight: t.viewportHeight, visibleWidth: 100 }))
			}, [t, n, r]),
			D.jsx("div", { "data-viewport-type": "window", ref: o, style: Lr(s), children: e })
		)
	},
	Jc = ({ children: e }) => {
		const t = Q("TopItemListComponent") || "div",
			n = Q("headerHeight"),
			r = { ...qc, marginTop: `${n}px` },
			i = Q("context")
		return D.jsx(t, { style: r, ...Oe(t, i), children: e })
	},
	Zc = $.memo(function (e) {
		const t = Q("useWindowScroll"),
			n = Q("topItemsIndexes").length > 0,
			r = Q("customScrollParent"),
			i = Q("context"),
			o = r || t ? nm : tm,
			s = r || t ? Qc : Xc
		return D.jsxs(o, {
			...e,
			...Oe(o, i),
			children: [
				n && D.jsx(Jc, { children: D.jsx(jo, { showTopList: !0 }) }),
				D.jsxs(s, { children: [D.jsx(Kc, {}), D.jsx(jo, {}), D.jsx(Yc, {})] }),
			],
		})
	}),
	{
		Component: em,
		useEmitter: Ji,
		useEmitterValue: Q,
		usePublisher: nt,
	} = Ra(
		Fc,
		{
			required: {},
			optional: {
				restoreStateFrom: "restoreStateFrom",
				context: "context",
				followOutput: "followOutput",
				itemContent: "itemContent",
				groupContent: "groupContent",
				overscan: "overscan",
				increaseViewportBy: "increaseViewportBy",
				totalCount: "totalCount",
				groupCounts: "groupCounts",
				topItemCount: "topItemCount",
				firstItemIndex: "firstItemIndex",
				initialTopMostItemIndex: "initialTopMostItemIndex",
				components: "components",
				atBottomThreshold: "atBottomThreshold",
				atTopThreshold: "atTopThreshold",
				computeItemKey: "computeItemKey",
				defaultItemHeight: "defaultItemHeight",
				fixedItemHeight: "fixedItemHeight",
				itemSize: "itemSize",
				scrollSeekConfiguration: "scrollSeekConfiguration",
				headerFooterTag: "HeaderFooterTag",
				data: "data",
				initialItemCount: "initialItemCount",
				initialScrollTop: "initialScrollTop",
				alignToBottom: "alignToBottom",
				useWindowScroll: "useWindowScroll",
				customScrollParent: "customScrollParent",
				scrollerRef: "scrollerRef",
				logLevel: "logLevel",
				horizontalDirection: "horizontalDirection",
				skipAnimationFrameInResizeObserver: "skipAnimationFrameInResizeObserver",
			},
			methods: {
				scrollToIndex: "scrollToIndex",
				scrollIntoView: "scrollIntoView",
				scrollTo: "scrollTo",
				scrollBy: "scrollBy",
				autoscrollToBottom: "autoscrollToBottom",
				getState: "getState",
			},
			events: {
				isScrolling: "isScrolling",
				endReached: "endReached",
				startReached: "startReached",
				rangeChanged: "rangeChanged",
				atBottomStateChange: "atBottomStateChange",
				atTopStateChange: "atTopStateChange",
				totalListHeightChanged: "totalListHeightChanged",
				itemsRendered: "itemsRendered",
				groupIndices: "groupIndices",
			},
		},
		Zc,
	),
	tm = za({ useEmitter: Ji, useEmitterValue: Q, usePublisher: nt }),
	nm = Va({ useEmitter: Ji, useEmitterValue: Q, usePublisher: nt }),
	rm = em,
	im = ae(() => {
		const e = F((l) => D.jsxs("td", { children: ["Item $", l] })),
			t = F(null),
			n = F(null),
			r = F(null),
			i = F({}),
			o = F(Qi),
			s = F(rn),
			a = (l, u = null) =>
				ze(
					O(
						i,
						G((m) => m[l]),
						ge(),
					),
					u,
				)
		return {
			components: i,
			computeItemKey: o,
			context: t,
			EmptyPlaceholder: a("EmptyPlaceholder"),
			FillerRow: a("FillerRow"),
			fixedFooterContent: r,
			fixedHeaderContent: n,
			itemContent: e,
			ScrollerComponent: a("Scroller", "div"),
			scrollerRef: s,
			ScrollSeekPlaceholder: a("ScrollSeekPlaceholder"),
			TableBodyComponent: a("TableBody", "tbody"),
			TableComponent: a("Table", "table"),
			TableFooterComponent: a("TableFoot", "tfoot"),
			TableHeadComponent: a("TableHead", "thead"),
			TableRowComponent: a("TableRow", "tr"),
		}
	})
_e(Aa, im)
const Ho = { bottom: 0, itemHeight: 0, items: [], itemWidth: 0, offsetBottom: 0, offsetTop: 0, top: 0 },
	om = { bottom: 0, itemHeight: 0, items: [{ index: 0 }], itemWidth: 0, offsetBottom: 0, offsetTop: 0, top: 0 },
	{ ceil: Go, floor: ur, max: yn, min: qr, round: $o } = Math
function Uo(e, t, n) {
	return Array.from({ length: t - e + 1 }).map((r, i) => ({ data: n === null ? null : n[i + e], index: i + e }))
}
function sm(e) {
	return { ...om, items: e }
}
function Un(e, t) {
	return e && e.width === t.width && e.height === t.height
}
function am(e, t) {
	return e && e.column === t.column && e.row === t.row
}
const lm = ae(
	([
		{ increaseViewportBy: e, listBoundary: t, overscan: n, visibleRange: r },
		{
			footerHeight: i,
			headerHeight: o,
			scrollBy: s,
			scrollContainerState: a,
			scrollTo: l,
			scrollTop: u,
			smoothScrollTargetReached: m,
			viewportHeight: c,
		},
		h,
		p,
		{ didMount: f, propsReady: y },
		{
			customScrollParent: x,
			useWindowScroll: d,
			windowScrollContainerState: _,
			windowScrollTo: w,
			windowViewportRect: I,
		},
		S,
	]) => {
		const b = F(0),
			T = F(0),
			P = F(Ho),
			z = F({ height: 0, width: 0 }),
			v = F({ height: 0, width: 0 }),
			L = ie(),
			M = ie(),
			B = F(0),
			C = F(null),
			j = F({ column: 0, row: 0 }),
			Z = ie(),
			le = ie(),
			xe = F(!1),
			Ee = F(0),
			k = F(!0),
			pe = F(!1),
			Le = F(!1)
		ce(
			O(
				f,
				ne(Ee),
				K(([V, X]) => !!X),
			),
			() => {
				ee(k, !1)
			},
		),
			ce(
				O(
					Te(f, k, v, z, Ee, pe),
					K(([V, X, se, ke, , be]) => V && !X && se.height !== 0 && ke.height !== 0 && !be),
				),
				([, , , , V]) => {
					ee(pe, !0),
						Wi(1, () => {
							ee(L, V)
						}),
						ht(O(u), () => {
							ee(t, [0, 0]), ee(k, !0)
						})
				},
			),
			U(
				O(
					le,
					K((V) => V != null && V.scrollTop > 0),
					mt(0),
				),
				T,
			),
			ce(
				O(
					f,
					ne(le),
					K(([, V]) => V != null),
				),
				([, V]) => {
					V &&
						(ee(z, V.viewport),
						ee(v, V.item),
						ee(j, V.gap),
						V.scrollTop > 0 &&
							(ee(xe, !0),
							ht(O(u, Zt(1)), (X) => {
								ee(xe, !1)
							}),
							ee(l, { top: V.scrollTop })))
				},
			),
			U(
				O(
					z,
					G(({ height: V }) => V),
				),
				c,
			),
			U(
				O(
					Te(
						Y(z, Un),
						Y(v, Un),
						Y(j, (V, X) => V && V.column === X.column && V.row === X.row),
						Y(u),
					),
					G(([V, X, se, ke]) => ({ gap: se, item: X, scrollTop: ke, viewport: V })),
				),
				Z,
			),
			U(
				O(
					Te(Y(b), r, Y(j, am), Y(v, Un), Y(z, Un), Y(C), Y(T), Y(xe), Y(k), Y(Ee)),
					K(([, , , , , , , V]) => !V),
					G(([V, [X, se], ke, be, gt, Ot, _t, , Dt, it]) => {
						const { column: at, row: vt } = ke,
							{ height: Nt, width: ln } = be,
							{ width: Gn } = gt
						if (_t === 0 && (V === 0 || Gn === 0)) return Ho
						if (ln === 0) {
							const $e = Ki(it, V),
								xt = $e + Math.max(_t - 1, 0)
							return sm(Uo($e, xt, Ot))
						}
						const $t = Ba(Gn, ln, at)
						let St, yt
						Dt
							? X === 0 && se === 0 && _t > 0
								? ((St = 0), (yt = _t - 1))
								: ((St = $t * ur((X + vt) / (Nt + vt))),
									(yt = $t * Go((se + vt) / (Nt + vt)) - 1),
									(yt = qr(V - 1, yn(yt, $t - 1))),
									(St = qr(yt, yn(0, St))))
							: ((St = 0), (yt = -1))
						const A = Uo(St, yt, Ot),
							{ bottom: H, top: W } = qo(gt, ke, be, A),
							te = Go(V / $t),
							ue = te * Nt + (te - 1) * vt - H
						return {
							bottom: H,
							itemHeight: Nt,
							items: A,
							itemWidth: ln,
							offsetBottom: ue,
							offsetTop: W,
							top: W,
						}
					}),
				),
				P,
			),
			U(
				O(
					C,
					K((V) => V !== null),
					G((V) => V.length),
				),
				b,
			),
			U(
				O(
					Te(z, v, P, j),
					K(([V, X, { items: se }]) => se.length > 0 && X.height !== 0 && V.height !== 0),
					G(([V, X, { items: se }, ke]) => {
						const { bottom: be, top: gt } = qo(V, ke, X, se)
						return [gt, be]
					}),
					ge(Sn),
				),
				t,
			)
		const E = F(!1)
		U(
			O(
				u,
				ne(E),
				G(([V, X]) => X || V !== 0),
			),
			E,
		)
		const Pe = Xe(
				O(
					Te(P, b),
					K(([{ items: V }]) => V.length > 0),
					ne(E),
					K(([[V, X], se]) => {
						const ke = V.items[V.items.length - 1].index === X - 1
						return (
							(se ||
								(V.bottom > 0 && V.itemHeight > 0 && V.offsetBottom === 0 && V.items.length === X)) &&
							ke
						)
					}),
					G(([[, V]]) => V - 1),
					ge(),
				),
			),
			Ge = Xe(
				O(
					Y(P),
					K(({ items: V }) => V.length > 0 && V[0].index === 0),
					mt(0),
					ge(),
				),
			),
			me = Xe(
				O(
					Y(P),
					ne(xe),
					K(([{ items: V }, X]) => V.length > 0 && !X),
					G(([{ items: V }]) => ({ endIndex: V[V.length - 1].index, startIndex: V[0].index })),
					ge(ya),
					Tt(0),
				),
			)
		U(me, p.scrollSeekRangeChanged),
			U(
				O(
					L,
					ne(z, v, b, j),
					G(([V, X, se, ke, be]) => {
						const gt = Ea(V),
							{ align: Ot, behavior: _t, offset: Dt } = gt
						let it = gt.index
						it === "LAST" && (it = ke - 1), (it = yn(0, it, qr(ke - 1, it)))
						let at = wi(X, be, se, it)
						return (
							Ot === "end"
								? (at = $o(at - X.height + se.height))
								: Ot === "center" && (at = $o(at - X.height / 2 + se.height / 2)),
							Dt && (at += Dt),
							{ behavior: _t, top: at }
						)
					}),
				),
				l,
			)
		const Fe = ze(
			O(
				P,
				G((V) => V.offsetBottom + V.bottom),
			),
			0,
		)
		return (
			U(
				O(
					I,
					G((V) => ({ height: V.visibleHeight, width: V.visibleWidth })),
				),
				z,
			),
			{
				customScrollParent: x,
				data: C,
				deviation: B,
				footerHeight: i,
				gap: j,
				headerHeight: o,
				increaseViewportBy: e,
				initialItemCount: T,
				itemDimensions: v,
				overscan: n,
				restoreStateFrom: le,
				scrollBy: s,
				scrollContainerState: a,
				scrollHeight: M,
				scrollTo: l,
				scrollToIndex: L,
				scrollTop: u,
				smoothScrollTargetReached: m,
				totalCount: b,
				useWindowScroll: d,
				viewportDimensions: z,
				windowScrollContainerState: _,
				windowScrollTo: w,
				windowViewportRect: I,
				...p,
				gridState: P,
				horizontalDirection: Le,
				initialTopMostItemIndex: Ee,
				totalListHeight: Fe,
				...h,
				endReached: Pe,
				propsReady: y,
				rangeChanged: me,
				startReached: Ge,
				stateChanged: Z,
				stateRestoreInProgress: xe,
				...S,
			}
		)
	},
	_e(Yi, He, Mn, Ta, Lt, Xi, Rt),
)
function Ba(e, t, n) {
	return yn(1, ur((e + n) / (ur(t) + n)))
}
function qo(e, t, n, r) {
	const { height: i } = n
	if (i === void 0 || r.length === 0) return { bottom: 0, top: 0 }
	const o = wi(e, t, n, r[0].index)
	return { bottom: wi(e, t, n, r[r.length - 1].index) + i, top: o }
}
function wi(e, t, n, r) {
	const i = Ba(e.width, n.width, t.column),
		o = ur(r / i),
		s = o * n.height + yn(0, o - 1) * t.row
	return s > 0 ? s + t.row : s
}
const um = ae(() => {
		const e = F((c) => `Item ${c}`),
			t = F({}),
			n = F(null),
			r = F("virtuoso-grid-item"),
			i = F("virtuoso-grid-list"),
			o = F(Qi),
			s = F("div"),
			a = F(rn),
			l = (c, h = null) =>
				ze(
					O(
						t,
						G((p) => p[c]),
						ge(),
					),
					h,
				),
			u = F(!1),
			m = F(!1)
		return (
			U(Y(m), u),
			{
				components: t,
				computeItemKey: o,
				context: n,
				FooterComponent: l("Footer"),
				HeaderComponent: l("Header"),
				headerFooterTag: s,
				itemClassName: r,
				ItemComponent: l("Item", "div"),
				itemContent: e,
				listClassName: i,
				ListComponent: l("List", "div"),
				readyStateChanged: u,
				reportReadyState: m,
				ScrollerComponent: l("Scroller", "div"),
				scrollerRef: a,
				ScrollSeekPlaceholder: l("ScrollSeekPlaceholder", "div"),
			}
		)
	}),
	cm = ae(([e, t]) => ({ ...e, ...t }), _e(lm, um)),
	mm = $.memo(function () {
		const e = ye("gridState"),
			t = ye("listClassName"),
			n = ye("itemClassName"),
			r = ye("itemContent"),
			i = ye("computeItemKey"),
			o = ye("isSeeking"),
			s = rt("scrollHeight"),
			a = ye("ItemComponent"),
			l = ye("ListComponent"),
			u = ye("ScrollSeekPlaceholder"),
			m = ye("context"),
			c = rt("itemDimensions"),
			h = rt("gap"),
			p = ye("log"),
			f = ye("stateRestoreInProgress"),
			y = rt("reportReadyState"),
			x = jt(
				$.useMemo(
					() => (d) => {
						const _ = d.parentElement.parentElement.scrollHeight
						s(_)
						const w = d.firstChild
						if (w) {
							const { height: I, width: S } = w.getBoundingClientRect()
							c({ height: I, width: S })
						}
						h({
							column: Wo("column-gap", getComputedStyle(d).columnGap, p),
							row: Wo("row-gap", getComputedStyle(d).rowGap, p),
						})
					},
					[s, c, h, p],
				),
				!0,
				!1,
			)
		return (
			Oa(() => {
				e.itemHeight > 0 && e.itemWidth > 0 && y(!0)
			}, [e]),
			f
				? null
				: D.jsx(l, {
						className: t,
						ref: x,
						...Oe(l, m),
						"data-testid": "virtuoso-item-list",
						style: { paddingBottom: e.offsetBottom, paddingTop: e.offsetTop },
						children: e.items.map((d) => {
							const _ = i(d.index, d.data, m)
							return o
								? D.jsx(u, { ...Oe(u, m), height: e.itemHeight, index: d.index, width: e.itemWidth }, _)
								: we.createElement(
										a,
										{ ...Oe(a, m), className: n, "data-index": d.index, key: _ },
										r(d.index, d.data, m),
									)
						}),
					})
		)
	}),
	pm = $.memo(function () {
		const e = ye("HeaderComponent"),
			t = rt("headerHeight"),
			n = ye("headerFooterTag"),
			r = jt(
				$.useMemo(
					() => (o) => {
						t(Ct(o, "height"))
					},
					[t],
				),
				!0,
				!1,
			),
			i = ye("context")
		return e ? D.jsx(n, { ref: r, children: D.jsx(e, { ...Oe(e, i) }) }) : null
	}),
	hm = $.memo(function () {
		const e = ye("FooterComponent"),
			t = rt("footerHeight"),
			n = ye("headerFooterTag"),
			r = jt(
				$.useMemo(
					() => (o) => {
						t(Ct(o, "height"))
					},
					[t],
				),
				!0,
				!1,
			),
			i = ye("context")
		return e ? D.jsx(n, { ref: r, children: D.jsx(e, { ...Oe(e, i) }) }) : null
	}),
	fm = ({ children: e }) => {
		const t = $.useContext(Pa),
			n = rt("itemDimensions"),
			r = rt("viewportDimensions"),
			i = jt(
				$.useMemo(
					() => (o) => {
						r(o.getBoundingClientRect())
					},
					[r],
				),
				!0,
				!1,
			)
		return (
			$.useEffect(() => {
				t &&
					(r({ height: t.viewportHeight, width: t.viewportWidth }),
					n({ height: t.itemHeight, width: t.itemWidth }))
			}, [t, r, n]),
			D.jsx("div", { ref: i, style: Lr(!1), children: e })
		)
	},
	dm = ({ children: e }) => {
		const t = $.useContext(Pa),
			n = rt("windowViewportRect"),
			r = rt("itemDimensions"),
			i = ye("customScrollParent"),
			o = pa(n, i, !1)
		return (
			$.useEffect(() => {
				t &&
					(r({ height: t.itemHeight, width: t.itemWidth }),
					n({ offsetTop: 0, visibleHeight: t.viewportHeight, visibleWidth: t.viewportWidth }))
			}, [t, n, r]),
			D.jsx("div", { ref: o, style: Lr(!1), children: e })
		)
	},
	gm = $.memo(function ({ ...e }) {
		const t = ye("useWindowScroll"),
			n = ye("customScrollParent"),
			r = n || t ? ym : _m,
			i = n || t ? dm : fm,
			o = ye("context")
		return D.jsx(r, {
			...e,
			...Oe(r, o),
			children: D.jsxs(i, { children: [D.jsx(pm, {}), D.jsx(mm, {}), D.jsx(hm, {})] }),
		})
	}),
	{
		useEmitter: Fa,
		useEmitterValue: ye,
		usePublisher: rt,
	} = Ra(
		cm,
		{
			optional: {
				context: "context",
				totalCount: "totalCount",
				overscan: "overscan",
				itemContent: "itemContent",
				components: "components",
				computeItemKey: "computeItemKey",
				data: "data",
				initialItemCount: "initialItemCount",
				scrollSeekConfiguration: "scrollSeekConfiguration",
				headerFooterTag: "headerFooterTag",
				listClassName: "listClassName",
				itemClassName: "itemClassName",
				useWindowScroll: "useWindowScroll",
				customScrollParent: "customScrollParent",
				scrollerRef: "scrollerRef",
				logLevel: "logLevel",
				restoreStateFrom: "restoreStateFrom",
				initialTopMostItemIndex: "initialTopMostItemIndex",
				increaseViewportBy: "increaseViewportBy",
			},
			methods: { scrollTo: "scrollTo", scrollBy: "scrollBy", scrollToIndex: "scrollToIndex" },
			events: {
				isScrolling: "isScrolling",
				endReached: "endReached",
				startReached: "startReached",
				rangeChanged: "rangeChanged",
				atBottomStateChange: "atBottomStateChange",
				atTopStateChange: "atTopStateChange",
				stateChanged: "stateChanged",
				readyStateChanged: "readyStateChanged",
			},
		},
		gm,
	),
	_m = za({ useEmitter: Fa, useEmitterValue: ye, usePublisher: rt }),
	ym = Va({ useEmitter: Fa, useEmitterValue: ye, usePublisher: rt })
function Wo(e, t, n) {
	return (
		t !== "normal" &&
			!(t != null && t.endsWith("px")) &&
			n(`${e} was not resolved to pixel value correctly`, t, Qe.WARN),
		t === "normal" ? 0 : parseInt(t ?? "0", 10)
	)
}
const zn = () => {
	const e = we.useContext(la)
	if (!e) throw new Error("useChatUI must be used within a ChatProvider")
	return e
}
function ja({ timeout: e = 2e3 } = {}) {
	const [t, n] = we.useState(!1)
	return {
		isCopied: t,
		copy: (i) => {
			var o
			typeof window > "u" ||
				!((o = navigator.clipboard) != null && o.writeText) ||
				!i ||
				navigator.clipboard.writeText(i).then(() => {
					n(!0), setTimeout(() => n(!1), e)
				})
		},
	}
}
function Ha(e, t) {
	const n = t || {}
	return (e[e.length - 1] === "" ? [...e, ""] : e)
		.join((n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " "))
		.trim()
}
const xm = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u,
	bm = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u,
	km = {}
function Ko(e, t) {
	return (km.jsx ? bm : xm).test(e)
}
const wm = /[ \t\n\f\r]/g
function Pr(e) {
	return typeof e == "object" ? (e.type === "text" ? Yo(e.value) : !1) : Yo(e)
}
function Yo(e) {
	return e.replace(wm, "") === ""
}
class Vn {
	constructor(t, n, r) {
		;(this.normal = n), (this.property = t), r && (this.space = r)
	}
}
Vn.prototype.normal = {}
Vn.prototype.property = {}
Vn.prototype.space = void 0
function Ga(e, t) {
	const n = {},
		r = {}
	for (const i of e) Object.assign(n, i.property), Object.assign(r, i.normal)
	return new Vn(n, r, t)
}
function Ei(e) {
	return e.toLowerCase()
}
class qe {
	constructor(t, n) {
		;(this.attribute = n), (this.property = t)
	}
}
qe.prototype.attribute = ""
qe.prototype.booleanish = !1
qe.prototype.boolean = !1
qe.prototype.commaOrSpaceSeparated = !1
qe.prototype.commaSeparated = !1
qe.prototype.defined = !1
qe.prototype.mustUseProperty = !1
qe.prototype.number = !1
qe.prototype.overloadedBoolean = !1
qe.prototype.property = ""
qe.prototype.spaceSeparated = !1
qe.prototype.space = void 0
let Em = 0
const J = Gt(),
	ve = Gt(),
	vi = Gt(),
	N = Gt(),
	de = Gt(),
	Qt = Gt(),
	Ke = Gt()
function Gt() {
	return 2 ** ++Em
}
const Si = Object.freeze(
		Object.defineProperty(
			{
				__proto__: null,
				boolean: J,
				booleanish: ve,
				commaOrSpaceSeparated: Ke,
				commaSeparated: Qt,
				number: N,
				overloadedBoolean: vi,
				spaceSeparated: de,
			},
			Symbol.toStringTag,
			{ value: "Module" },
		),
	),
	Wr = Object.keys(Si)
class Zi extends qe {
	constructor(t, n, r, i) {
		let o = -1
		if ((super(t, n), Xo(this, "space", i), typeof r == "number"))
			for (; ++o < Wr.length; ) {
				const s = Wr[o]
				Xo(this, Wr[o], (r & Si[s]) === Si[s])
			}
	}
}
Zi.prototype.defined = !0
function Xo(e, t, n) {
	n && (e[t] = n)
}
function on(e) {
	const t = {},
		n = {}
	for (const [r, i] of Object.entries(e.properties)) {
		const o = new Zi(r, e.transform(e.attributes || {}, r), i, e.space)
		e.mustUseProperty && e.mustUseProperty.includes(r) && (o.mustUseProperty = !0),
			(t[r] = o),
			(n[Ei(r)] = r),
			(n[Ei(o.attribute)] = r)
	}
	return new Vn(t, n, e.space)
}
const $a = on({
	properties: {
		ariaActiveDescendant: null,
		ariaAtomic: ve,
		ariaAutoComplete: null,
		ariaBusy: ve,
		ariaChecked: ve,
		ariaColCount: N,
		ariaColIndex: N,
		ariaColSpan: N,
		ariaControls: de,
		ariaCurrent: null,
		ariaDescribedBy: de,
		ariaDetails: null,
		ariaDisabled: ve,
		ariaDropEffect: de,
		ariaErrorMessage: null,
		ariaExpanded: ve,
		ariaFlowTo: de,
		ariaGrabbed: ve,
		ariaHasPopup: null,
		ariaHidden: ve,
		ariaInvalid: null,
		ariaKeyShortcuts: null,
		ariaLabel: null,
		ariaLabelledBy: de,
		ariaLevel: N,
		ariaLive: null,
		ariaModal: ve,
		ariaMultiLine: ve,
		ariaMultiSelectable: ve,
		ariaOrientation: null,
		ariaOwns: de,
		ariaPlaceholder: null,
		ariaPosInSet: N,
		ariaPressed: ve,
		ariaReadOnly: ve,
		ariaRelevant: null,
		ariaRequired: ve,
		ariaRoleDescription: de,
		ariaRowCount: N,
		ariaRowIndex: N,
		ariaRowSpan: N,
		ariaSelected: ve,
		ariaSetSize: N,
		ariaSort: null,
		ariaValueMax: N,
		ariaValueMin: N,
		ariaValueNow: N,
		ariaValueText: null,
		role: null,
	},
	transform(e, t) {
		return t === "role" ? t : "aria-" + t.slice(4).toLowerCase()
	},
})
function Ua(e, t) {
	return t in e ? e[t] : t
}
function qa(e, t) {
	return Ua(e, t.toLowerCase())
}
const vm = on({
		attributes: { acceptcharset: "accept-charset", classname: "class", htmlfor: "for", httpequiv: "http-equiv" },
		mustUseProperty: ["checked", "multiple", "muted", "selected"],
		properties: {
			abbr: null,
			accept: Qt,
			acceptCharset: de,
			accessKey: de,
			action: null,
			allow: null,
			allowFullScreen: J,
			allowPaymentRequest: J,
			allowUserMedia: J,
			alt: null,
			as: null,
			async: J,
			autoCapitalize: null,
			autoComplete: de,
			autoFocus: J,
			autoPlay: J,
			blocking: de,
			capture: null,
			charSet: null,
			checked: J,
			cite: null,
			className: de,
			cols: N,
			colSpan: null,
			content: null,
			contentEditable: ve,
			controls: J,
			controlsList: de,
			coords: N | Qt,
			crossOrigin: null,
			data: null,
			dateTime: null,
			decoding: null,
			default: J,
			defer: J,
			dir: null,
			dirName: null,
			disabled: J,
			download: vi,
			draggable: ve,
			encType: null,
			enterKeyHint: null,
			fetchPriority: null,
			form: null,
			formAction: null,
			formEncType: null,
			formMethod: null,
			formNoValidate: J,
			formTarget: null,
			headers: de,
			height: N,
			hidden: vi,
			high: N,
			href: null,
			hrefLang: null,
			htmlFor: de,
			httpEquiv: de,
			id: null,
			imageSizes: null,
			imageSrcSet: null,
			inert: J,
			inputMode: null,
			integrity: null,
			is: null,
			isMap: J,
			itemId: null,
			itemProp: de,
			itemRef: de,
			itemScope: J,
			itemType: de,
			kind: null,
			label: null,
			lang: null,
			language: null,
			list: null,
			loading: null,
			loop: J,
			low: N,
			manifest: null,
			max: null,
			maxLength: N,
			media: null,
			method: null,
			min: null,
			minLength: N,
			multiple: J,
			muted: J,
			name: null,
			nonce: null,
			noModule: J,
			noValidate: J,
			onAbort: null,
			onAfterPrint: null,
			onAuxClick: null,
			onBeforeMatch: null,
			onBeforePrint: null,
			onBeforeToggle: null,
			onBeforeUnload: null,
			onBlur: null,
			onCancel: null,
			onCanPlay: null,
			onCanPlayThrough: null,
			onChange: null,
			onClick: null,
			onClose: null,
			onContextLost: null,
			onContextMenu: null,
			onContextRestored: null,
			onCopy: null,
			onCueChange: null,
			onCut: null,
			onDblClick: null,
			onDrag: null,
			onDragEnd: null,
			onDragEnter: null,
			onDragExit: null,
			onDragLeave: null,
			onDragOver: null,
			onDragStart: null,
			onDrop: null,
			onDurationChange: null,
			onEmptied: null,
			onEnded: null,
			onError: null,
			onFocus: null,
			onFormData: null,
			onHashChange: null,
			onInput: null,
			onInvalid: null,
			onKeyDown: null,
			onKeyPress: null,
			onKeyUp: null,
			onLanguageChange: null,
			onLoad: null,
			onLoadedData: null,
			onLoadedMetadata: null,
			onLoadEnd: null,
			onLoadStart: null,
			onMessage: null,
			onMessageError: null,
			onMouseDown: null,
			onMouseEnter: null,
			onMouseLeave: null,
			onMouseMove: null,
			onMouseOut: null,
			onMouseOver: null,
			onMouseUp: null,
			onOffline: null,
			onOnline: null,
			onPageHide: null,
			onPageShow: null,
			onPaste: null,
			onPause: null,
			onPlay: null,
			onPlaying: null,
			onPopState: null,
			onProgress: null,
			onRateChange: null,
			onRejectionHandled: null,
			onReset: null,
			onResize: null,
			onScroll: null,
			onScrollEnd: null,
			onSecurityPolicyViolation: null,
			onSeeked: null,
			onSeeking: null,
			onSelect: null,
			onSlotChange: null,
			onStalled: null,
			onStorage: null,
			onSubmit: null,
			onSuspend: null,
			onTimeUpdate: null,
			onToggle: null,
			onUnhandledRejection: null,
			onUnload: null,
			onVolumeChange: null,
			onWaiting: null,
			onWheel: null,
			open: J,
			optimum: N,
			pattern: null,
			ping: de,
			placeholder: null,
			playsInline: J,
			popover: null,
			popoverTarget: null,
			popoverTargetAction: null,
			poster: null,
			preload: null,
			readOnly: J,
			referrerPolicy: null,
			rel: de,
			required: J,
			reversed: J,
			rows: N,
			rowSpan: N,
			sandbox: de,
			scope: null,
			scoped: J,
			seamless: J,
			selected: J,
			shadowRootClonable: J,
			shadowRootDelegatesFocus: J,
			shadowRootMode: null,
			shape: null,
			size: N,
			sizes: null,
			slot: null,
			span: N,
			spellCheck: ve,
			src: null,
			srcDoc: null,
			srcLang: null,
			srcSet: null,
			start: N,
			step: null,
			style: null,
			tabIndex: N,
			target: null,
			title: null,
			translate: null,
			type: null,
			typeMustMatch: J,
			useMap: null,
			value: ve,
			width: N,
			wrap: null,
			writingSuggestions: null,
			align: null,
			aLink: null,
			archive: de,
			axis: null,
			background: null,
			bgColor: null,
			border: N,
			borderColor: null,
			bottomMargin: N,
			cellPadding: null,
			cellSpacing: null,
			char: null,
			charOff: null,
			classId: null,
			clear: null,
			code: null,
			codeBase: null,
			codeType: null,
			color: null,
			compact: J,
			declare: J,
			event: null,
			face: null,
			frame: null,
			frameBorder: null,
			hSpace: N,
			leftMargin: N,
			link: null,
			longDesc: null,
			lowSrc: null,
			marginHeight: N,
			marginWidth: N,
			noResize: J,
			noHref: J,
			noShade: J,
			noWrap: J,
			object: null,
			profile: null,
			prompt: null,
			rev: null,
			rightMargin: N,
			rules: null,
			scheme: null,
			scrolling: ve,
			standby: null,
			summary: null,
			text: null,
			topMargin: N,
			valueType: null,
			version: null,
			vAlign: null,
			vLink: null,
			vSpace: N,
			allowTransparency: null,
			autoCorrect: null,
			autoSave: null,
			disablePictureInPicture: J,
			disableRemotePlayback: J,
			prefix: null,
			property: null,
			results: N,
			security: null,
			unselectable: null,
		},
		space: "html",
		transform: qa,
	}),
	Sm = on({
		attributes: {
			accentHeight: "accent-height",
			alignmentBaseline: "alignment-baseline",
			arabicForm: "arabic-form",
			baselineShift: "baseline-shift",
			capHeight: "cap-height",
			className: "class",
			clipPath: "clip-path",
			clipRule: "clip-rule",
			colorInterpolation: "color-interpolation",
			colorInterpolationFilters: "color-interpolation-filters",
			colorProfile: "color-profile",
			colorRendering: "color-rendering",
			crossOrigin: "crossorigin",
			dataType: "datatype",
			dominantBaseline: "dominant-baseline",
			enableBackground: "enable-background",
			fillOpacity: "fill-opacity",
			fillRule: "fill-rule",
			floodColor: "flood-color",
			floodOpacity: "flood-opacity",
			fontFamily: "font-family",
			fontSize: "font-size",
			fontSizeAdjust: "font-size-adjust",
			fontStretch: "font-stretch",
			fontStyle: "font-style",
			fontVariant: "font-variant",
			fontWeight: "font-weight",
			glyphName: "glyph-name",
			glyphOrientationHorizontal: "glyph-orientation-horizontal",
			glyphOrientationVertical: "glyph-orientation-vertical",
			hrefLang: "hreflang",
			horizAdvX: "horiz-adv-x",
			horizOriginX: "horiz-origin-x",
			horizOriginY: "horiz-origin-y",
			imageRendering: "image-rendering",
			letterSpacing: "letter-spacing",
			lightingColor: "lighting-color",
			markerEnd: "marker-end",
			markerMid: "marker-mid",
			markerStart: "marker-start",
			navDown: "nav-down",
			navDownLeft: "nav-down-left",
			navDownRight: "nav-down-right",
			navLeft: "nav-left",
			navNext: "nav-next",
			navPrev: "nav-prev",
			navRight: "nav-right",
			navUp: "nav-up",
			navUpLeft: "nav-up-left",
			navUpRight: "nav-up-right",
			onAbort: "onabort",
			onActivate: "onactivate",
			onAfterPrint: "onafterprint",
			onBeforePrint: "onbeforeprint",
			onBegin: "onbegin",
			onCancel: "oncancel",
			onCanPlay: "oncanplay",
			onCanPlayThrough: "oncanplaythrough",
			onChange: "onchange",
			onClick: "onclick",
			onClose: "onclose",
			onCopy: "oncopy",
			onCueChange: "oncuechange",
			onCut: "oncut",
			onDblClick: "ondblclick",
			onDrag: "ondrag",
			onDragEnd: "ondragend",
			onDragEnter: "ondragenter",
			onDragExit: "ondragexit",
			onDragLeave: "ondragleave",
			onDragOver: "ondragover",
			onDragStart: "ondragstart",
			onDrop: "ondrop",
			onDurationChange: "ondurationchange",
			onEmptied: "onemptied",
			onEnd: "onend",
			onEnded: "onended",
			onError: "onerror",
			onFocus: "onfocus",
			onFocusIn: "onfocusin",
			onFocusOut: "onfocusout",
			onHashChange: "onhashchange",
			onInput: "oninput",
			onInvalid: "oninvalid",
			onKeyDown: "onkeydown",
			onKeyPress: "onkeypress",
			onKeyUp: "onkeyup",
			onLoad: "onload",
			onLoadedData: "onloadeddata",
			onLoadedMetadata: "onloadedmetadata",
			onLoadStart: "onloadstart",
			onMessage: "onmessage",
			onMouseDown: "onmousedown",
			onMouseEnter: "onmouseenter",
			onMouseLeave: "onmouseleave",
			onMouseMove: "onmousemove",
			onMouseOut: "onmouseout",
			onMouseOver: "onmouseover",
			onMouseUp: "onmouseup",
			onMouseWheel: "onmousewheel",
			onOffline: "onoffline",
			onOnline: "ononline",
			onPageHide: "onpagehide",
			onPageShow: "onpageshow",
			onPaste: "onpaste",
			onPause: "onpause",
			onPlay: "onplay",
			onPlaying: "onplaying",
			onPopState: "onpopstate",
			onProgress: "onprogress",
			onRateChange: "onratechange",
			onRepeat: "onrepeat",
			onReset: "onreset",
			onResize: "onresize",
			onScroll: "onscroll",
			onSeeked: "onseeked",
			onSeeking: "onseeking",
			onSelect: "onselect",
			onShow: "onshow",
			onStalled: "onstalled",
			onStorage: "onstorage",
			onSubmit: "onsubmit",
			onSuspend: "onsuspend",
			onTimeUpdate: "ontimeupdate",
			onToggle: "ontoggle",
			onUnload: "onunload",
			onVolumeChange: "onvolumechange",
			onWaiting: "onwaiting",
			onZoom: "onzoom",
			overlinePosition: "overline-position",
			overlineThickness: "overline-thickness",
			paintOrder: "paint-order",
			panose1: "panose-1",
			pointerEvents: "pointer-events",
			referrerPolicy: "referrerpolicy",
			renderingIntent: "rendering-intent",
			shapeRendering: "shape-rendering",
			stopColor: "stop-color",
			stopOpacity: "stop-opacity",
			strikethroughPosition: "strikethrough-position",
			strikethroughThickness: "strikethrough-thickness",
			strokeDashArray: "stroke-dasharray",
			strokeDashOffset: "stroke-dashoffset",
			strokeLineCap: "stroke-linecap",
			strokeLineJoin: "stroke-linejoin",
			strokeMiterLimit: "stroke-miterlimit",
			strokeOpacity: "stroke-opacity",
			strokeWidth: "stroke-width",
			tabIndex: "tabindex",
			textAnchor: "text-anchor",
			textDecoration: "text-decoration",
			textRendering: "text-rendering",
			transformOrigin: "transform-origin",
			typeOf: "typeof",
			underlinePosition: "underline-position",
			underlineThickness: "underline-thickness",
			unicodeBidi: "unicode-bidi",
			unicodeRange: "unicode-range",
			unitsPerEm: "units-per-em",
			vAlphabetic: "v-alphabetic",
			vHanging: "v-hanging",
			vIdeographic: "v-ideographic",
			vMathematical: "v-mathematical",
			vectorEffect: "vector-effect",
			vertAdvY: "vert-adv-y",
			vertOriginX: "vert-origin-x",
			vertOriginY: "vert-origin-y",
			wordSpacing: "word-spacing",
			writingMode: "writing-mode",
			xHeight: "x-height",
			playbackOrder: "playbackorder",
			timelineBegin: "timelinebegin",
		},
		properties: {
			about: Ke,
			accentHeight: N,
			accumulate: null,
			additive: null,
			alignmentBaseline: null,
			alphabetic: N,
			amplitude: N,
			arabicForm: null,
			ascent: N,
			attributeName: null,
			attributeType: null,
			azimuth: N,
			bandwidth: null,
			baselineShift: null,
			baseFrequency: null,
			baseProfile: null,
			bbox: null,
			begin: null,
			bias: N,
			by: null,
			calcMode: null,
			capHeight: N,
			className: de,
			clip: null,
			clipPath: null,
			clipPathUnits: null,
			clipRule: null,
			color: null,
			colorInterpolation: null,
			colorInterpolationFilters: null,
			colorProfile: null,
			colorRendering: null,
			content: null,
			contentScriptType: null,
			contentStyleType: null,
			crossOrigin: null,
			cursor: null,
			cx: null,
			cy: null,
			d: null,
			dataType: null,
			defaultAction: null,
			descent: N,
			diffuseConstant: N,
			direction: null,
			display: null,
			dur: null,
			divisor: N,
			dominantBaseline: null,
			download: J,
			dx: null,
			dy: null,
			edgeMode: null,
			editable: null,
			elevation: N,
			enableBackground: null,
			end: null,
			event: null,
			exponent: N,
			externalResourcesRequired: null,
			fill: null,
			fillOpacity: N,
			fillRule: null,
			filter: null,
			filterRes: null,
			filterUnits: null,
			floodColor: null,
			floodOpacity: null,
			focusable: null,
			focusHighlight: null,
			fontFamily: null,
			fontSize: null,
			fontSizeAdjust: null,
			fontStretch: null,
			fontStyle: null,
			fontVariant: null,
			fontWeight: null,
			format: null,
			fr: null,
			from: null,
			fx: null,
			fy: null,
			g1: Qt,
			g2: Qt,
			glyphName: Qt,
			glyphOrientationHorizontal: null,
			glyphOrientationVertical: null,
			glyphRef: null,
			gradientTransform: null,
			gradientUnits: null,
			handler: null,
			hanging: N,
			hatchContentUnits: null,
			hatchUnits: null,
			height: null,
			href: null,
			hrefLang: null,
			horizAdvX: N,
			horizOriginX: N,
			horizOriginY: N,
			id: null,
			ideographic: N,
			imageRendering: null,
			initialVisibility: null,
			in: null,
			in2: null,
			intercept: N,
			k: N,
			k1: N,
			k2: N,
			k3: N,
			k4: N,
			kernelMatrix: Ke,
			kernelUnitLength: null,
			keyPoints: null,
			keySplines: null,
			keyTimes: null,
			kerning: null,
			lang: null,
			lengthAdjust: null,
			letterSpacing: null,
			lightingColor: null,
			limitingConeAngle: N,
			local: null,
			markerEnd: null,
			markerMid: null,
			markerStart: null,
			markerHeight: null,
			markerUnits: null,
			markerWidth: null,
			mask: null,
			maskContentUnits: null,
			maskUnits: null,
			mathematical: null,
			max: null,
			media: null,
			mediaCharacterEncoding: null,
			mediaContentEncodings: null,
			mediaSize: N,
			mediaTime: null,
			method: null,
			min: null,
			mode: null,
			name: null,
			navDown: null,
			navDownLeft: null,
			navDownRight: null,
			navLeft: null,
			navNext: null,
			navPrev: null,
			navRight: null,
			navUp: null,
			navUpLeft: null,
			navUpRight: null,
			numOctaves: null,
			observer: null,
			offset: null,
			onAbort: null,
			onActivate: null,
			onAfterPrint: null,
			onBeforePrint: null,
			onBegin: null,
			onCancel: null,
			onCanPlay: null,
			onCanPlayThrough: null,
			onChange: null,
			onClick: null,
			onClose: null,
			onCopy: null,
			onCueChange: null,
			onCut: null,
			onDblClick: null,
			onDrag: null,
			onDragEnd: null,
			onDragEnter: null,
			onDragExit: null,
			onDragLeave: null,
			onDragOver: null,
			onDragStart: null,
			onDrop: null,
			onDurationChange: null,
			onEmptied: null,
			onEnd: null,
			onEnded: null,
			onError: null,
			onFocus: null,
			onFocusIn: null,
			onFocusOut: null,
			onHashChange: null,
			onInput: null,
			onInvalid: null,
			onKeyDown: null,
			onKeyPress: null,
			onKeyUp: null,
			onLoad: null,
			onLoadedData: null,
			onLoadedMetadata: null,
			onLoadStart: null,
			onMessage: null,
			onMouseDown: null,
			onMouseEnter: null,
			onMouseLeave: null,
			onMouseMove: null,
			onMouseOut: null,
			onMouseOver: null,
			onMouseUp: null,
			onMouseWheel: null,
			onOffline: null,
			onOnline: null,
			onPageHide: null,
			onPageShow: null,
			onPaste: null,
			onPause: null,
			onPlay: null,
			onPlaying: null,
			onPopState: null,
			onProgress: null,
			onRateChange: null,
			onRepeat: null,
			onReset: null,
			onResize: null,
			onScroll: null,
			onSeeked: null,
			onSeeking: null,
			onSelect: null,
			onShow: null,
			onStalled: null,
			onStorage: null,
			onSubmit: null,
			onSuspend: null,
			onTimeUpdate: null,
			onToggle: null,
			onUnload: null,
			onVolumeChange: null,
			onWaiting: null,
			onZoom: null,
			opacity: null,
			operator: null,
			order: null,
			orient: null,
			orientation: null,
			origin: null,
			overflow: null,
			overlay: null,
			overlinePosition: N,
			overlineThickness: N,
			paintOrder: null,
			panose1: null,
			path: null,
			pathLength: N,
			patternContentUnits: null,
			patternTransform: null,
			patternUnits: null,
			phase: null,
			ping: de,
			pitch: null,
			playbackOrder: null,
			pointerEvents: null,
			points: null,
			pointsAtX: N,
			pointsAtY: N,
			pointsAtZ: N,
			preserveAlpha: null,
			preserveAspectRatio: null,
			primitiveUnits: null,
			propagate: null,
			property: Ke,
			r: null,
			radius: null,
			referrerPolicy: null,
			refX: null,
			refY: null,
			rel: Ke,
			rev: Ke,
			renderingIntent: null,
			repeatCount: null,
			repeatDur: null,
			requiredExtensions: Ke,
			requiredFeatures: Ke,
			requiredFonts: Ke,
			requiredFormats: Ke,
			resource: null,
			restart: null,
			result: null,
			rotate: null,
			rx: null,
			ry: null,
			scale: null,
			seed: null,
			shapeRendering: null,
			side: null,
			slope: null,
			snapshotTime: null,
			specularConstant: N,
			specularExponent: N,
			spreadMethod: null,
			spacing: null,
			startOffset: null,
			stdDeviation: null,
			stemh: null,
			stemv: null,
			stitchTiles: null,
			stopColor: null,
			stopOpacity: null,
			strikethroughPosition: N,
			strikethroughThickness: N,
			string: null,
			stroke: null,
			strokeDashArray: Ke,
			strokeDashOffset: null,
			strokeLineCap: null,
			strokeLineJoin: null,
			strokeMiterLimit: N,
			strokeOpacity: N,
			strokeWidth: null,
			style: null,
			surfaceScale: N,
			syncBehavior: null,
			syncBehaviorDefault: null,
			syncMaster: null,
			syncTolerance: null,
			syncToleranceDefault: null,
			systemLanguage: Ke,
			tabIndex: N,
			tableValues: null,
			target: null,
			targetX: N,
			targetY: N,
			textAnchor: null,
			textDecoration: null,
			textRendering: null,
			textLength: null,
			timelineBegin: null,
			title: null,
			transformBehavior: null,
			type: null,
			typeOf: Ke,
			to: null,
			transform: null,
			transformOrigin: null,
			u1: null,
			u2: null,
			underlinePosition: N,
			underlineThickness: N,
			unicode: null,
			unicodeBidi: null,
			unicodeRange: null,
			unitsPerEm: N,
			values: null,
			vAlphabetic: N,
			vMathematical: N,
			vectorEffect: null,
			vHanging: N,
			vIdeographic: N,
			version: null,
			vertAdvY: N,
			vertOriginX: N,
			vertOriginY: N,
			viewBox: null,
			viewTarget: null,
			visibility: null,
			width: null,
			widths: null,
			wordSpacing: null,
			writingMode: null,
			x: null,
			x1: null,
			x2: null,
			xChannelSelector: null,
			xHeight: N,
			y: null,
			y1: null,
			y2: null,
			yChannelSelector: null,
			z: null,
			zoomAndPan: null,
		},
		space: "svg",
		transform: Ua,
	}),
	Wa = on({
		properties: {
			xLinkActuate: null,
			xLinkArcRole: null,
			xLinkHref: null,
			xLinkRole: null,
			xLinkShow: null,
			xLinkTitle: null,
			xLinkType: null,
		},
		space: "xlink",
		transform(e, t) {
			return "xlink:" + t.slice(5).toLowerCase()
		},
	}),
	Ka = on({
		attributes: { xmlnsxlink: "xmlns:xlink" },
		properties: { xmlnsXLink: null, xmlns: null },
		space: "xmlns",
		transform: qa,
	}),
	Ya = on({
		properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
		space: "xml",
		transform(e, t) {
			return "xml:" + t.slice(3).toLowerCase()
		},
	}),
	Im = {
		classId: "classID",
		dataType: "datatype",
		itemId: "itemID",
		strokeDashArray: "strokeDasharray",
		strokeDashOffset: "strokeDashoffset",
		strokeLineCap: "strokeLinecap",
		strokeLineJoin: "strokeLinejoin",
		strokeMiterLimit: "strokeMiterlimit",
		typeOf: "typeof",
		xLinkActuate: "xlinkActuate",
		xLinkArcRole: "xlinkArcrole",
		xLinkHref: "xlinkHref",
		xLinkRole: "xlinkRole",
		xLinkShow: "xlinkShow",
		xLinkTitle: "xlinkTitle",
		xLinkType: "xlinkType",
		xmlnsXLink: "xmlnsXlink",
	},
	Tm = /[A-Z]/g,
	Qo = /-[a-z]/g,
	Cm = /^data[-\w.:]+$/i
function Xa(e, t) {
	const n = Ei(t)
	let r = t,
		i = qe
	if (n in e.normal) return e.property[e.normal[n]]
	if (n.length > 4 && n.slice(0, 4) === "data" && Cm.test(t)) {
		if (t.charAt(4) === "-") {
			const o = t.slice(5).replace(Qo, Rm)
			r = "data" + o.charAt(0).toUpperCase() + o.slice(1)
		} else {
			const o = t.slice(4)
			if (!Qo.test(o)) {
				let s = o.replace(Tm, Am)
				s.charAt(0) !== "-" && (s = "-" + s), (t = "data" + s)
			}
		}
		i = Zi
	}
	return new i(r, t)
}
function Am(e) {
	return "-" + e.toLowerCase()
}
function Rm(e) {
	return e.charAt(1).toUpperCase()
}
const Qa = Ga([$a, vm, Wa, Ka, Ya], "html"),
	Bn = Ga([$a, Sm, Wa, Ka, Ya], "svg")
function Ja(e) {
	return e.join(" ").trim()
}
var qt = {},
	Kr,
	Jo
function Lm() {
	if (Jo) return Kr
	Jo = 1
	var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
		t = /\n/g,
		n = /^\s*/,
		r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
		i = /^:\s*/,
		o = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
		s = /^[;\s]*/,
		a = /^\s+|\s+$/g,
		l = `
`,
		u = "/",
		m = "*",
		c = "",
		h = "comment",
		p = "declaration"
	Kr = function (y, x) {
		if (typeof y != "string") throw new TypeError("First argument must be a string")
		if (!y) return []
		x = x || {}
		var d = 1,
			_ = 1
		function w(B) {
			var C = B.match(t)
			C && (d += C.length)
			var j = B.lastIndexOf(l)
			_ = ~j ? B.length - j : _ + B.length
		}
		function I() {
			var B = { line: d, column: _ }
			return function (C) {
				return (C.position = new S(B)), P(), C
			}
		}
		function S(B) {
			;(this.start = B), (this.end = { line: d, column: _ }), (this.source = x.source)
		}
		S.prototype.content = y
		function b(B) {
			var C = new Error(x.source + ":" + d + ":" + _ + ": " + B)
			if (((C.reason = B), (C.filename = x.source), (C.line = d), (C.column = _), (C.source = y), !x.silent))
				throw C
		}
		function T(B) {
			var C = B.exec(y)
			if (C) {
				var j = C[0]
				return w(j), (y = y.slice(j.length)), C
			}
		}
		function P() {
			T(n)
		}
		function z(B) {
			var C
			for (B = B || []; (C = v()); ) C !== !1 && B.push(C)
			return B
		}
		function v() {
			var B = I()
			if (!(u != y.charAt(0) || m != y.charAt(1))) {
				for (var C = 2; c != y.charAt(C) && (m != y.charAt(C) || u != y.charAt(C + 1)); ) ++C
				if (((C += 2), c === y.charAt(C - 1))) return b("End of comment missing")
				var j = y.slice(2, C - 2)
				return (_ += 2), w(j), (y = y.slice(C)), (_ += 2), B({ type: h, comment: j })
			}
		}
		function L() {
			var B = I(),
				C = T(r)
			if (C) {
				if ((v(), !T(i))) return b("property missing ':'")
				var j = T(o),
					Z = B({ type: p, property: f(C[0].replace(e, c)), value: j ? f(j[0].replace(e, c)) : c })
				return T(s), Z
			}
		}
		function M() {
			var B = []
			z(B)
			for (var C; (C = L()); ) C !== !1 && (B.push(C), z(B))
			return B
		}
		return P(), M()
	}
	function f(y) {
		return y ? y.replace(a, c) : c
	}
	return Kr
}
var Zo
function Pm() {
	if (Zo) return qt
	Zo = 1
	var e =
		(qt && qt.__importDefault) ||
		function (r) {
			return r && r.__esModule ? r : { default: r }
		}
	Object.defineProperty(qt, "__esModule", { value: !0 }), (qt.default = n)
	var t = e(Lm())
	function n(r, i) {
		var o = null
		if (!r || typeof r != "string") return o
		var s = (0, t.default)(r),
			a = typeof i == "function"
		return (
			s.forEach(function (l) {
				if (l.type === "declaration") {
					var u = l.property,
						m = l.value
					a ? i(u, m, l) : m && ((o = o || {}), (o[u] = m))
				}
			}),
			o
		)
	}
	return qt
}
var mn = {},
	es
function Om() {
	if (es) return mn
	;(es = 1), Object.defineProperty(mn, "__esModule", { value: !0 }), (mn.camelCase = void 0)
	var e = /^--[a-zA-Z0-9_-]+$/,
		t = /-([a-z])/g,
		n = /^[^-]+$/,
		r = /^-(webkit|moz|ms|o|khtml)-/,
		i = /^-(ms)-/,
		o = function (u) {
			return !u || n.test(u) || e.test(u)
		},
		s = function (u, m) {
			return m.toUpperCase()
		},
		a = function (u, m) {
			return "".concat(m, "-")
		},
		l = function (u, m) {
			return (
				m === void 0 && (m = {}),
				o(u)
					? u
					: ((u = u.toLowerCase()),
						m.reactCompat ? (u = u.replace(i, a)) : (u = u.replace(r, a)),
						u.replace(t, s))
			)
		}
	return (mn.camelCase = l), mn
}
var pn, ts
function Dm() {
	if (ts) return pn
	ts = 1
	var e =
			(pn && pn.__importDefault) ||
			function (i) {
				return i && i.__esModule ? i : { default: i }
			},
		t = e(Pm()),
		n = Om()
	function r(i, o) {
		var s = {}
		return (
			!i ||
				typeof i != "string" ||
				(0, t.default)(i, function (a, l) {
					a && l && (s[(0, n.camelCase)(a, o)] = l)
				}),
			s
		)
	}
	return (r.default = r), (pn = r), pn
}
var Nm = Dm()
const Mm = ra(Nm),
	Za = el("end"),
	eo = el("start")
function el(e) {
	return t
	function t(n) {
		const r = (n && n.position && n.position[e]) || {}
		if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
			return {
				line: r.line,
				column: r.column,
				offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0,
			}
	}
}
function zm(e) {
	const t = eo(e),
		n = Za(e)
	if (t && n) return { start: t, end: n }
}
function xn(e) {
	return !e || typeof e != "object"
		? ""
		: "position" in e || "type" in e
			? ns(e.position)
			: "start" in e || "end" in e
				? ns(e)
				: "line" in e || "column" in e
					? Ii(e)
					: ""
}
function Ii(e) {
	return rs(e && e.line) + ":" + rs(e && e.column)
}
function ns(e) {
	return Ii(e && e.start) + "-" + Ii(e && e.end)
}
function rs(e) {
	return e && typeof e == "number" ? e : 1
}
class Be extends Error {
	constructor(t, n, r) {
		super(), typeof n == "string" && ((r = n), (n = void 0))
		let i = "",
			o = {},
			s = !1
		if (
			(n &&
				("line" in n && "column" in n
					? (o = { place: n })
					: "start" in n && "end" in n
						? (o = { place: n })
						: "type" in n
							? (o = { ancestors: [n], place: n.position })
							: (o = { ...n })),
			typeof t == "string" ? (i = t) : !o.cause && t && ((s = !0), (i = t.message), (o.cause = t)),
			!o.ruleId && !o.source && typeof r == "string")
		) {
			const l = r.indexOf(":")
			l === -1 ? (o.ruleId = r) : ((o.source = r.slice(0, l)), (o.ruleId = r.slice(l + 1)))
		}
		if (!o.place && o.ancestors && o.ancestors) {
			const l = o.ancestors[o.ancestors.length - 1]
			l && (o.place = l.position)
		}
		const a = o.place && "start" in o.place ? o.place.start : o.place
		;(this.ancestors = o.ancestors || void 0),
			(this.cause = o.cause || void 0),
			(this.column = a ? a.column : void 0),
			(this.fatal = void 0),
			this.file,
			(this.message = i),
			(this.line = a ? a.line : void 0),
			(this.name = xn(o.place) || "1:1"),
			(this.place = o.place || void 0),
			(this.reason = this.message),
			(this.ruleId = o.ruleId || void 0),
			(this.source = o.source || void 0),
			(this.stack = s && o.cause && typeof o.cause.stack == "string" ? o.cause.stack : ""),
			this.actual,
			this.expected,
			this.note,
			this.url
	}
}
Be.prototype.file = ""
Be.prototype.name = ""
Be.prototype.reason = ""
Be.prototype.message = ""
Be.prototype.stack = ""
Be.prototype.column = void 0
Be.prototype.line = void 0
Be.prototype.ancestors = void 0
Be.prototype.cause = void 0
Be.prototype.fatal = void 0
Be.prototype.place = void 0
Be.prototype.ruleId = void 0
Be.prototype.source = void 0
const to = {}.hasOwnProperty,
	Vm = new Map(),
	Bm = /[A-Z]/g,
	Fm = new Set(["table", "tbody", "thead", "tfoot", "tr"]),
	jm = new Set(["td", "th"]),
	tl = "https://github.com/syntax-tree/hast-util-to-jsx-runtime"
function Hm(e, t) {
	if (!t || t.Fragment === void 0) throw new TypeError("Expected `Fragment` in options")
	const n = t.filePath || void 0
	let r
	if (t.development) {
		if (typeof t.jsxDEV != "function") throw new TypeError("Expected `jsxDEV` in options when `development: true`")
		r = Xm(n, t.jsxDEV)
	} else {
		if (typeof t.jsx != "function") throw new TypeError("Expected `jsx` in production options")
		if (typeof t.jsxs != "function") throw new TypeError("Expected `jsxs` in production options")
		r = Ym(n, t.jsx, t.jsxs)
	}
	const i = {
			Fragment: t.Fragment,
			ancestors: [],
			components: t.components || {},
			create: r,
			elementAttributeNameCase: t.elementAttributeNameCase || "react",
			evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
			filePath: n,
			ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
			passKeys: t.passKeys !== !1,
			passNode: t.passNode || !1,
			schema: t.space === "svg" ? Bn : Qa,
			stylePropertyNameCase: t.stylePropertyNameCase || "dom",
			tableCellAlignToStyle: t.tableCellAlignToStyle !== !1,
		},
		o = nl(i, e, void 0)
	return o && typeof o != "string" ? o : i.create(e, i.Fragment, { children: o || void 0 }, void 0)
}
function nl(e, t, n) {
	if (t.type === "element") return Gm(e, t, n)
	if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression") return $m(e, t)
	if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement") return qm(e, t, n)
	if (t.type === "mdxjsEsm") return Um(e, t)
	if (t.type === "root") return Wm(e, t, n)
	if (t.type === "text") return Km(e, t)
}
function Gm(e, t, n) {
	const r = e.schema
	let i = r
	t.tagName.toLowerCase() === "svg" && r.space === "html" && ((i = Bn), (e.schema = i)), e.ancestors.push(t)
	const o = il(e, t.tagName, !1),
		s = Qm(e, t)
	let a = ro(e, t)
	return (
		Fm.has(t.tagName) &&
			(a = a.filter(function (l) {
				return typeof l == "string" ? !Pr(l) : !0
			})),
		rl(e, s, o, t),
		no(s, a),
		e.ancestors.pop(),
		(e.schema = r),
		e.create(t, o, s, n)
	)
}
function $m(e, t) {
	if (t.data && t.data.estree && e.evaluater) {
		const r = t.data.estree.body[0]
		return r.type, e.evaluater.evaluateExpression(r.expression)
	}
	Cn(e, t.position)
}
function Um(e, t) {
	if (t.data && t.data.estree && e.evaluater) return e.evaluater.evaluateProgram(t.data.estree)
	Cn(e, t.position)
}
function qm(e, t, n) {
	const r = e.schema
	let i = r
	t.name === "svg" && r.space === "html" && ((i = Bn), (e.schema = i)), e.ancestors.push(t)
	const o = t.name === null ? e.Fragment : il(e, t.name, !0),
		s = Jm(e, t),
		a = ro(e, t)
	return rl(e, s, o, t), no(s, a), e.ancestors.pop(), (e.schema = r), e.create(t, o, s, n)
}
function Wm(e, t, n) {
	const r = {}
	return no(r, ro(e, t)), e.create(t, e.Fragment, r, n)
}
function Km(e, t) {
	return t.value
}
function rl(e, t, n, r) {
	typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r)
}
function no(e, t) {
	if (t.length > 0) {
		const n = t.length > 1 ? t : t[0]
		n && (e.children = n)
	}
}
function Ym(e, t, n) {
	return r
	function r(i, o, s, a) {
		const u = Array.isArray(s.children) ? n : t
		return a ? u(o, s, a) : u(o, s)
	}
}
function Xm(e, t) {
	return n
	function n(r, i, o, s) {
		const a = Array.isArray(o.children),
			l = eo(r)
		return t(
			i,
			o,
			s,
			a,
			{ columnNumber: l ? l.column - 1 : void 0, fileName: e, lineNumber: l ? l.line : void 0 },
			void 0,
		)
	}
}
function Qm(e, t) {
	const n = {}
	let r, i
	for (i in t.properties)
		if (i !== "children" && to.call(t.properties, i)) {
			const o = Zm(e, i, t.properties[i])
			if (o) {
				const [s, a] = o
				e.tableCellAlignToStyle && s === "align" && typeof a == "string" && jm.has(t.tagName)
					? (r = a)
					: (n[s] = a)
			}
		}
	if (r) {
		const o = n.style || (n.style = {})
		o[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r
	}
	return n
}
function Jm(e, t) {
	const n = {}
	for (const r of t.attributes)
		if (r.type === "mdxJsxExpressionAttribute")
			if (r.data && r.data.estree && e.evaluater) {
				const o = r.data.estree.body[0]
				o.type
				const s = o.expression
				s.type
				const a = s.properties[0]
				a.type, Object.assign(n, e.evaluater.evaluateExpression(a.argument))
			} else Cn(e, t.position)
		else {
			const i = r.name
			let o
			if (r.value && typeof r.value == "object")
				if (r.value.data && r.value.data.estree && e.evaluater) {
					const a = r.value.data.estree.body[0]
					a.type, (o = e.evaluater.evaluateExpression(a.expression))
				} else Cn(e, t.position)
			else o = r.value === null ? !0 : r.value
			n[i] = o
		}
	return n
}
function ro(e, t) {
	const n = []
	let r = -1
	const i = e.passKeys ? new Map() : Vm
	for (; ++r < t.children.length; ) {
		const o = t.children[r]
		let s
		if (e.passKeys) {
			const l =
				o.type === "element"
					? o.tagName
					: o.type === "mdxJsxFlowElement" || o.type === "mdxJsxTextElement"
						? o.name
						: void 0
			if (l) {
				const u = i.get(l) || 0
				;(s = l + "-" + u), i.set(l, u + 1)
			}
		}
		const a = nl(e, o, s)
		a !== void 0 && n.push(a)
	}
	return n
}
function Zm(e, t, n) {
	const r = Xa(e.schema, t)
	if (!(n == null || (typeof n == "number" && Number.isNaN(n)))) {
		if ((Array.isArray(n) && (n = r.commaSeparated ? Ha(n) : Ja(n)), r.property === "style")) {
			let i = typeof n == "object" ? n : ep(e, String(n))
			return e.stylePropertyNameCase === "css" && (i = tp(i)), ["style", i]
		}
		return [e.elementAttributeNameCase === "react" && r.space ? Im[r.property] || r.property : r.attribute, n]
	}
}
function ep(e, t) {
	try {
		return Mm(t, { reactCompat: !0 })
	} catch (n) {
		if (e.ignoreInvalidStyle) return {}
		const r = n,
			i = new Be("Cannot parse `style` attribute", {
				ancestors: e.ancestors,
				cause: r,
				ruleId: "style",
				source: "hast-util-to-jsx-runtime",
			})
		throw ((i.file = e.filePath || void 0), (i.url = tl + "#cannot-parse-style-attribute"), i)
	}
}
function il(e, t, n) {
	let r
	if (!n) r = { type: "Literal", value: t }
	else if (t.includes(".")) {
		const i = t.split(".")
		let o = -1,
			s
		for (; ++o < i.length; ) {
			const a = Ko(i[o]) ? { type: "Identifier", name: i[o] } : { type: "Literal", value: i[o] }
			s = s
				? {
						type: "MemberExpression",
						object: s,
						property: a,
						computed: !!(o && a.type === "Literal"),
						optional: !1,
					}
				: a
		}
		r = s
	} else r = Ko(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t }
	if (r.type === "Literal") {
		const i = r.value
		return to.call(e.components, i) ? e.components[i] : i
	}
	if (e.evaluater) return e.evaluater.evaluateExpression(r)
	Cn(e)
}
function Cn(e, t) {
	const n = new Be("Cannot handle MDX estrees without `createEvaluater`", {
		ancestors: e.ancestors,
		place: t,
		ruleId: "mdx-estree",
		source: "hast-util-to-jsx-runtime",
	})
	throw ((n.file = e.filePath || void 0), (n.url = tl + "#cannot-handle-mdx-estrees-without-createevaluater"), n)
}
function tp(e) {
	const t = {}
	let n
	for (n in e) to.call(e, n) && (t[np(n)] = e[n])
	return t
}
function np(e) {
	let t = e.replace(Bm, rp)
	return t.slice(0, 3) === "ms-" && (t = "-" + t), t
}
function rp(e) {
	return "-" + e.toLowerCase()
}
const Yr = {
		action: ["form"],
		cite: ["blockquote", "del", "ins", "q"],
		data: ["object"],
		formAction: ["button", "input"],
		href: ["a", "area", "base", "link"],
		icon: ["menuitem"],
		itemId: null,
		manifest: ["html"],
		ping: ["a", "area"],
		poster: ["video"],
		src: ["audio", "embed", "iframe", "img", "input", "script", "source", "track", "video"],
	},
	ip = {}
function io(e, t) {
	const n = ip,
		r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0,
		i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0
	return ol(e, r, i)
}
function ol(e, t, n) {
	if (op(e)) {
		if ("value" in e) return e.type === "html" && !n ? "" : e.value
		if (t && "alt" in e && e.alt) return e.alt
		if ("children" in e) return is(e.children, t, n)
	}
	return Array.isArray(e) ? is(e, t, n) : ""
}
function is(e, t, n) {
	const r = []
	let i = -1
	for (; ++i < e.length; ) r[i] = ol(e[i], t, n)
	return r.join("")
}
function op(e) {
	return !!(e && typeof e == "object")
}
const os = document.createElement("i")
function oo(e) {
	const t = "&" + e + ";"
	os.innerHTML = t
	const n = os.textContent
	return (n.charCodeAt(n.length - 1) === 59 && e !== "semi") || n === t ? !1 : n
}
function Je(e, t, n, r) {
	const i = e.length
	let o = 0,
		s
	if ((t < 0 ? (t = -t > i ? 0 : i + t) : (t = t > i ? i : t), (n = n > 0 ? n : 0), r.length < 1e4))
		(s = Array.from(r)), s.unshift(t, n), e.splice(...s)
	else
		for (n && e.splice(t, n); o < r.length; )
			(s = r.slice(o, o + 1e4)), s.unshift(t, 0), e.splice(...s), (o += 1e4), (t += 1e4)
}
function et(e, t) {
	return e.length > 0 ? (Je(e, e.length, 0, t), e) : t
}
const ss = {}.hasOwnProperty
function sl(e) {
	const t = {}
	let n = -1
	for (; ++n < e.length; ) sp(t, e[n])
	return t
}
function sp(e, t) {
	let n
	for (n in t) {
		const i = (ss.call(e, n) ? e[n] : void 0) || (e[n] = {}),
			o = t[n]
		let s
		if (o)
			for (s in o) {
				ss.call(i, s) || (i[s] = [])
				const a = o[s]
				ap(i[s], Array.isArray(a) ? a : a ? [a] : [])
			}
	}
}
function ap(e, t) {
	let n = -1
	const r = []
	for (; ++n < t.length; ) (t[n].add === "after" ? e : r).push(t[n])
	Je(e, 0, 0, r)
}
function al(e, t) {
	const n = Number.parseInt(e, t)
	return n < 9 ||
		n === 11 ||
		(n > 13 && n < 32) ||
		(n > 126 && n < 160) ||
		(n > 55295 && n < 57344) ||
		(n > 64975 && n < 65008) ||
		(n & 65535) === 65535 ||
		(n & 65535) === 65534 ||
		n > 1114111
		? "�"
		: String.fromCodePoint(n)
}
function ot(e) {
	return e
		.replace(/[\t\n\r ]+/g, " ")
		.replace(/^ | $/g, "")
		.toLowerCase()
		.toUpperCase()
}
const je = Pt(/[A-Za-z]/),
	Ve = Pt(/[\dA-Za-z]/),
	lp = Pt(/[#-'*+\--9=?A-Z^-~]/)
function cr(e) {
	return e !== null && (e < 32 || e === 127)
}
const Ti = Pt(/\d/),
	up = Pt(/[\dA-Fa-f]/),
	cp = Pt(/[!-/:-@[-`{-~]/)
function q(e) {
	return e !== null && e < -2
}
function fe(e) {
	return e !== null && (e < 0 || e === 32)
}
function re(e) {
	return e === -2 || e === -1 || e === 32
}
const Or = Pt(new RegExp("\\p{P}|\\p{S}", "u")),
	Ft = Pt(/\s/)
function Pt(e) {
	return t
	function t(n) {
		return n !== null && n > -1 && e.test(String.fromCharCode(n))
	}
}
function sn(e) {
	const t = []
	let n = -1,
		r = 0,
		i = 0
	for (; ++n < e.length; ) {
		const o = e.charCodeAt(n)
		let s = ""
		if (o === 37 && Ve(e.charCodeAt(n + 1)) && Ve(e.charCodeAt(n + 2))) i = 2
		else if (o < 128) /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(o)) || (s = String.fromCharCode(o))
		else if (o > 55295 && o < 57344) {
			const a = e.charCodeAt(n + 1)
			o < 56320 && a > 56319 && a < 57344 ? ((s = String.fromCharCode(o, a)), (i = 1)) : (s = "�")
		} else s = String.fromCharCode(o)
		s && (t.push(e.slice(r, n), encodeURIComponent(s)), (r = n + i + 1), (s = "")), i && ((n += i), (i = 0))
	}
	return t.join("") + e.slice(r)
}
function oe(e, t, n, r) {
	const i = r ? r - 1 : Number.POSITIVE_INFINITY
	let o = 0
	return s
	function s(l) {
		return re(l) ? (e.enter(n), a(l)) : t(l)
	}
	function a(l) {
		return re(l) && o++ < i ? (e.consume(l), a) : (e.exit(n), t(l))
	}
}
const mp = { tokenize: pp }
function pp(e) {
	const t = e.attempt(this.parser.constructs.contentInitial, r, i)
	let n
	return t
	function r(a) {
		if (a === null) {
			e.consume(a)
			return
		}
		return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), oe(e, t, "linePrefix")
	}
	function i(a) {
		return e.enter("paragraph"), o(a)
	}
	function o(a) {
		const l = e.enter("chunkText", { contentType: "text", previous: n })
		return n && (n.next = l), (n = l), s(a)
	}
	function s(a) {
		if (a === null) {
			e.exit("chunkText"), e.exit("paragraph"), e.consume(a)
			return
		}
		return q(a) ? (e.consume(a), e.exit("chunkText"), o) : (e.consume(a), s)
	}
}
const hp = { tokenize: fp },
	as = { tokenize: dp }
function fp(e) {
	const t = this,
		n = []
	let r = 0,
		i,
		o,
		s
	return a
	function a(w) {
		if (r < n.length) {
			const I = n[r]
			return (t.containerState = I[1]), e.attempt(I[0].continuation, l, u)(w)
		}
		return u(w)
	}
	function l(w) {
		if ((r++, t.containerState._closeFlow)) {
			;(t.containerState._closeFlow = void 0), i && _()
			const I = t.events.length
			let S = I,
				b
			for (; S--; )
				if (t.events[S][0] === "exit" && t.events[S][1].type === "chunkFlow") {
					b = t.events[S][1].end
					break
				}
			d(r)
			let T = I
			for (; T < t.events.length; ) (t.events[T][1].end = { ...b }), T++
			return Je(t.events, S + 1, 0, t.events.slice(I)), (t.events.length = T), u(w)
		}
		return a(w)
	}
	function u(w) {
		if (r === n.length) {
			if (!i) return h(w)
			if (i.currentConstruct && i.currentConstruct.concrete) return f(w)
			t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack)
		}
		return (t.containerState = {}), e.check(as, m, c)(w)
	}
	function m(w) {
		return i && _(), d(r), h(w)
	}
	function c(w) {
		return (t.parser.lazy[t.now().line] = r !== n.length), (s = t.now().offset), f(w)
	}
	function h(w) {
		return (t.containerState = {}), e.attempt(as, p, f)(w)
	}
	function p(w) {
		return r++, n.push([t.currentConstruct, t.containerState]), h(w)
	}
	function f(w) {
		if (w === null) {
			i && _(), d(0), e.consume(w)
			return
		}
		return (
			(i = i || t.parser.flow(t.now())),
			e.enter("chunkFlow", { _tokenizer: i, contentType: "flow", previous: o }),
			y(w)
		)
	}
	function y(w) {
		if (w === null) {
			x(e.exit("chunkFlow"), !0), d(0), e.consume(w)
			return
		}
		return q(w) ? (e.consume(w), x(e.exit("chunkFlow")), (r = 0), (t.interrupt = void 0), a) : (e.consume(w), y)
	}
	function x(w, I) {
		const S = t.sliceStream(w)
		if (
			(I && S.push(null),
			(w.previous = o),
			o && (o.next = w),
			(o = w),
			i.defineSkip(w.start),
			i.write(S),
			t.parser.lazy[w.start.line])
		) {
			let b = i.events.length
			for (; b--; )
				if (i.events[b][1].start.offset < s && (!i.events[b][1].end || i.events[b][1].end.offset > s)) return
			const T = t.events.length
			let P = T,
				z,
				v
			for (; P--; )
				if (t.events[P][0] === "exit" && t.events[P][1].type === "chunkFlow") {
					if (z) {
						v = t.events[P][1].end
						break
					}
					z = !0
				}
			for (d(r), b = T; b < t.events.length; ) (t.events[b][1].end = { ...v }), b++
			Je(t.events, P + 1, 0, t.events.slice(T)), (t.events.length = b)
		}
	}
	function d(w) {
		let I = n.length
		for (; I-- > w; ) {
			const S = n[I]
			;(t.containerState = S[1]), S[0].exit.call(t, e)
		}
		n.length = w
	}
	function _() {
		i.write([null]), (o = void 0), (i = void 0), (t.containerState._closeFlow = void 0)
	}
}
function dp(e, t, n) {
	return oe(
		e,
		e.attempt(this.parser.constructs.document, t, n),
		"linePrefix",
		this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
	)
}
function en(e) {
	if (e === null || fe(e) || Ft(e)) return 1
	if (Or(e)) return 2
}
function Dr(e, t, n) {
	const r = []
	let i = -1
	for (; ++i < e.length; ) {
		const o = e[i].resolveAll
		o && !r.includes(o) && ((t = o(t, n)), r.push(o))
	}
	return t
}
const Ci = { name: "attention", resolveAll: gp, tokenize: _p }
function gp(e, t) {
	let n = -1,
		r,
		i,
		o,
		s,
		a,
		l,
		u,
		m
	for (; ++n < e.length; )
		if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
			for (r = n; r--; )
				if (
					e[r][0] === "exit" &&
					e[r][1].type === "attentionSequence" &&
					e[r][1]._open &&
					t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)
				) {
					if (
						(e[r][1]._close || e[n][1]._open) &&
						(e[n][1].end.offset - e[n][1].start.offset) % 3 &&
						!((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3)
					)
						continue
					l =
						e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1
							? 2
							: 1
					const c = { ...e[r][1].end },
						h = { ...e[n][1].start }
					ls(c, -l),
						ls(h, l),
						(s = {
							type: l > 1 ? "strongSequence" : "emphasisSequence",
							start: c,
							end: { ...e[r][1].end },
						}),
						(a = {
							type: l > 1 ? "strongSequence" : "emphasisSequence",
							start: { ...e[n][1].start },
							end: h,
						}),
						(o = {
							type: l > 1 ? "strongText" : "emphasisText",
							start: { ...e[r][1].end },
							end: { ...e[n][1].start },
						}),
						(i = { type: l > 1 ? "strong" : "emphasis", start: { ...s.start }, end: { ...a.end } }),
						(e[r][1].end = { ...s.start }),
						(e[n][1].start = { ...a.end }),
						(u = []),
						e[r][1].end.offset - e[r][1].start.offset &&
							(u = et(u, [
								["enter", e[r][1], t],
								["exit", e[r][1], t],
							])),
						(u = et(u, [
							["enter", i, t],
							["enter", s, t],
							["exit", s, t],
							["enter", o, t],
						])),
						(u = et(u, Dr(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t))),
						(u = et(u, [
							["exit", o, t],
							["enter", a, t],
							["exit", a, t],
							["exit", i, t],
						])),
						e[n][1].end.offset - e[n][1].start.offset
							? ((m = 2),
								(u = et(u, [
									["enter", e[n][1], t],
									["exit", e[n][1], t],
								])))
							: (m = 0),
						Je(e, r - 1, n - r + 3, u),
						(n = r + u.length - m - 2)
					break
				}
		}
	for (n = -1; ++n < e.length; ) e[n][1].type === "attentionSequence" && (e[n][1].type = "data")
	return e
}
function _p(e, t) {
	const n = this.parser.constructs.attentionMarkers.null,
		r = this.previous,
		i = en(r)
	let o
	return s
	function s(l) {
		return (o = l), e.enter("attentionSequence"), a(l)
	}
	function a(l) {
		if (l === o) return e.consume(l), a
		const u = e.exit("attentionSequence"),
			m = en(l),
			c = !m || (m === 2 && i) || n.includes(l),
			h = !i || (i === 2 && m) || n.includes(r)
		return (u._open = !!(o === 42 ? c : c && (i || !h))), (u._close = !!(o === 42 ? h : h && (m || !c))), t(l)
	}
}
function ls(e, t) {
	;(e.column += t), (e.offset += t), (e._bufferIndex += t)
}
const yp = { name: "autolink", tokenize: xp }
function xp(e, t, n) {
	let r = 0
	return i
	function i(p) {
		return (
			e.enter("autolink"),
			e.enter("autolinkMarker"),
			e.consume(p),
			e.exit("autolinkMarker"),
			e.enter("autolinkProtocol"),
			o
		)
	}
	function o(p) {
		return je(p) ? (e.consume(p), s) : p === 64 ? n(p) : u(p)
	}
	function s(p) {
		return p === 43 || p === 45 || p === 46 || Ve(p) ? ((r = 1), a(p)) : u(p)
	}
	function a(p) {
		return p === 58
			? (e.consume(p), (r = 0), l)
			: (p === 43 || p === 45 || p === 46 || Ve(p)) && r++ < 32
				? (e.consume(p), a)
				: ((r = 0), u(p))
	}
	function l(p) {
		return p === 62
			? (e.exit("autolinkProtocol"),
				e.enter("autolinkMarker"),
				e.consume(p),
				e.exit("autolinkMarker"),
				e.exit("autolink"),
				t)
			: p === null || p === 32 || p === 60 || cr(p)
				? n(p)
				: (e.consume(p), l)
	}
	function u(p) {
		return p === 64 ? (e.consume(p), m) : lp(p) ? (e.consume(p), u) : n(p)
	}
	function m(p) {
		return Ve(p) ? c(p) : n(p)
	}
	function c(p) {
		return p === 46
			? (e.consume(p), (r = 0), m)
			: p === 62
				? ((e.exit("autolinkProtocol").type = "autolinkEmail"),
					e.enter("autolinkMarker"),
					e.consume(p),
					e.exit("autolinkMarker"),
					e.exit("autolink"),
					t)
				: h(p)
	}
	function h(p) {
		if ((p === 45 || Ve(p)) && r++ < 63) {
			const f = p === 45 ? h : c
			return e.consume(p), f
		}
		return n(p)
	}
}
const Fn = { partial: !0, tokenize: bp }
function bp(e, t, n) {
	return r
	function r(o) {
		return re(o) ? oe(e, i, "linePrefix")(o) : i(o)
	}
	function i(o) {
		return o === null || q(o) ? t(o) : n(o)
	}
}
const ll = { continuation: { tokenize: wp }, exit: Ep, name: "blockQuote", tokenize: kp }
function kp(e, t, n) {
	const r = this
	return i
	function i(s) {
		if (s === 62) {
			const a = r.containerState
			return (
				a.open || (e.enter("blockQuote", { _container: !0 }), (a.open = !0)),
				e.enter("blockQuotePrefix"),
				e.enter("blockQuoteMarker"),
				e.consume(s),
				e.exit("blockQuoteMarker"),
				o
			)
		}
		return n(s)
	}
	function o(s) {
		return re(s)
			? (e.enter("blockQuotePrefixWhitespace"),
				e.consume(s),
				e.exit("blockQuotePrefixWhitespace"),
				e.exit("blockQuotePrefix"),
				t)
			: (e.exit("blockQuotePrefix"), t(s))
	}
}
function wp(e, t, n) {
	const r = this
	return i
	function i(s) {
		return re(s)
			? oe(e, o, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s)
			: o(s)
	}
	function o(s) {
		return e.attempt(ll, t, n)(s)
	}
}
function Ep(e) {
	e.exit("blockQuote")
}
const ul = { name: "characterEscape", tokenize: vp }
function vp(e, t, n) {
	return r
	function r(o) {
		return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(o), e.exit("escapeMarker"), i
	}
	function i(o) {
		return cp(o)
			? (e.enter("characterEscapeValue"),
				e.consume(o),
				e.exit("characterEscapeValue"),
				e.exit("characterEscape"),
				t)
			: n(o)
	}
}
const cl = { name: "characterReference", tokenize: Sp }
function Sp(e, t, n) {
	const r = this
	let i = 0,
		o,
		s
	return a
	function a(c) {
		return (
			e.enter("characterReference"),
			e.enter("characterReferenceMarker"),
			e.consume(c),
			e.exit("characterReferenceMarker"),
			l
		)
	}
	function l(c) {
		return c === 35
			? (e.enter("characterReferenceMarkerNumeric"), e.consume(c), e.exit("characterReferenceMarkerNumeric"), u)
			: (e.enter("characterReferenceValue"), (o = 31), (s = Ve), m(c))
	}
	function u(c) {
		return c === 88 || c === 120
			? (e.enter("characterReferenceMarkerHexadecimal"),
				e.consume(c),
				e.exit("characterReferenceMarkerHexadecimal"),
				e.enter("characterReferenceValue"),
				(o = 6),
				(s = up),
				m)
			: (e.enter("characterReferenceValue"), (o = 7), (s = Ti), m(c))
	}
	function m(c) {
		if (c === 59 && i) {
			const h = e.exit("characterReferenceValue")
			return s === Ve && !oo(r.sliceSerialize(h))
				? n(c)
				: (e.enter("characterReferenceMarker"),
					e.consume(c),
					e.exit("characterReferenceMarker"),
					e.exit("characterReference"),
					t)
		}
		return s(c) && i++ < o ? (e.consume(c), m) : n(c)
	}
}
const us = { partial: !0, tokenize: Tp },
	cs = { concrete: !0, name: "codeFenced", tokenize: Ip }
function Ip(e, t, n) {
	const r = this,
		i = { partial: !0, tokenize: S }
	let o = 0,
		s = 0,
		a
	return l
	function l(b) {
		return u(b)
	}
	function u(b) {
		const T = r.events[r.events.length - 1]
		return (
			(o = T && T[1].type === "linePrefix" ? T[2].sliceSerialize(T[1], !0).length : 0),
			(a = b),
			e.enter("codeFenced"),
			e.enter("codeFencedFence"),
			e.enter("codeFencedFenceSequence"),
			m(b)
		)
	}
	function m(b) {
		return b === a
			? (s++, e.consume(b), m)
			: s < 3
				? n(b)
				: (e.exit("codeFencedFenceSequence"), re(b) ? oe(e, c, "whitespace")(b) : c(b))
	}
	function c(b) {
		return b === null || q(b)
			? (e.exit("codeFencedFence"), r.interrupt ? t(b) : e.check(us, y, I)(b))
			: (e.enter("codeFencedFenceInfo"), e.enter("chunkString", { contentType: "string" }), h(b))
	}
	function h(b) {
		return b === null || q(b)
			? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), c(b))
			: re(b)
				? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), oe(e, p, "whitespace")(b))
				: b === 96 && b === a
					? n(b)
					: (e.consume(b), h)
	}
	function p(b) {
		return b === null || q(b)
			? c(b)
			: (e.enter("codeFencedFenceMeta"), e.enter("chunkString", { contentType: "string" }), f(b))
	}
	function f(b) {
		return b === null || q(b)
			? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), c(b))
			: b === 96 && b === a
				? n(b)
				: (e.consume(b), f)
	}
	function y(b) {
		return e.attempt(i, I, x)(b)
	}
	function x(b) {
		return e.enter("lineEnding"), e.consume(b), e.exit("lineEnding"), d
	}
	function d(b) {
		return o > 0 && re(b) ? oe(e, _, "linePrefix", o + 1)(b) : _(b)
	}
	function _(b) {
		return b === null || q(b) ? e.check(us, y, I)(b) : (e.enter("codeFlowValue"), w(b))
	}
	function w(b) {
		return b === null || q(b) ? (e.exit("codeFlowValue"), _(b)) : (e.consume(b), w)
	}
	function I(b) {
		return e.exit("codeFenced"), t(b)
	}
	function S(b, T, P) {
		let z = 0
		return v
		function v(j) {
			return b.enter("lineEnding"), b.consume(j), b.exit("lineEnding"), L
		}
		function L(j) {
			return (
				b.enter("codeFencedFence"),
				re(j)
					? oe(b, M, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(j)
					: M(j)
			)
		}
		function M(j) {
			return j === a ? (b.enter("codeFencedFenceSequence"), B(j)) : P(j)
		}
		function B(j) {
			return j === a
				? (z++, b.consume(j), B)
				: z >= s
					? (b.exit("codeFencedFenceSequence"), re(j) ? oe(b, C, "whitespace")(j) : C(j))
					: P(j)
		}
		function C(j) {
			return j === null || q(j) ? (b.exit("codeFencedFence"), T(j)) : P(j)
		}
	}
}
function Tp(e, t, n) {
	const r = this
	return i
	function i(s) {
		return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o)
	}
	function o(s) {
		return r.parser.lazy[r.now().line] ? n(s) : t(s)
	}
}
const Xr = { name: "codeIndented", tokenize: Ap },
	Cp = { partial: !0, tokenize: Rp }
function Ap(e, t, n) {
	const r = this
	return i
	function i(u) {
		return e.enter("codeIndented"), oe(e, o, "linePrefix", 5)(u)
	}
	function o(u) {
		const m = r.events[r.events.length - 1]
		return m && m[1].type === "linePrefix" && m[2].sliceSerialize(m[1], !0).length >= 4 ? s(u) : n(u)
	}
	function s(u) {
		return u === null ? l(u) : q(u) ? e.attempt(Cp, s, l)(u) : (e.enter("codeFlowValue"), a(u))
	}
	function a(u) {
		return u === null || q(u) ? (e.exit("codeFlowValue"), s(u)) : (e.consume(u), a)
	}
	function l(u) {
		return e.exit("codeIndented"), t(u)
	}
}
function Rp(e, t, n) {
	const r = this
	return i
	function i(s) {
		return r.parser.lazy[r.now().line]
			? n(s)
			: q(s)
				? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i)
				: oe(e, o, "linePrefix", 5)(s)
	}
	function o(s) {
		const a = r.events[r.events.length - 1]
		return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(s) : q(s) ? i(s) : n(s)
	}
}
const Lp = { name: "codeText", previous: Op, resolve: Pp, tokenize: Dp }
function Pp(e) {
	let t = e.length - 4,
		n = 3,
		r,
		i
	if (
		(e[n][1].type === "lineEnding" || e[n][1].type === "space") &&
		(e[t][1].type === "lineEnding" || e[t][1].type === "space")
	) {
		for (r = n; ++r < t; )
			if (e[r][1].type === "codeTextData") {
				;(e[n][1].type = "codeTextPadding"), (e[t][1].type = "codeTextPadding"), (n += 2), (t -= 2)
				break
			}
	}
	for (r = n - 1, t++; ++r <= t; )
		i === void 0
			? r !== t && e[r][1].type !== "lineEnding" && (i = r)
			: (r === t || e[r][1].type === "lineEnding") &&
				((e[i][1].type = "codeTextData"),
				r !== i + 2 &&
					((e[i][1].end = e[r - 1][1].end), e.splice(i + 2, r - i - 2), (t -= r - i - 2), (r = i + 2)),
				(i = void 0))
	return e
}
function Op(e) {
	return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape"
}
function Dp(e, t, n) {
	let r = 0,
		i,
		o
	return s
	function s(c) {
		return e.enter("codeText"), e.enter("codeTextSequence"), a(c)
	}
	function a(c) {
		return c === 96 ? (e.consume(c), r++, a) : (e.exit("codeTextSequence"), l(c))
	}
	function l(c) {
		return c === null
			? n(c)
			: c === 32
				? (e.enter("space"), e.consume(c), e.exit("space"), l)
				: c === 96
					? ((o = e.enter("codeTextSequence")), (i = 0), m(c))
					: q(c)
						? (e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), l)
						: (e.enter("codeTextData"), u(c))
	}
	function u(c) {
		return c === null || c === 32 || c === 96 || q(c) ? (e.exit("codeTextData"), l(c)) : (e.consume(c), u)
	}
	function m(c) {
		return c === 96
			? (e.consume(c), i++, m)
			: i === r
				? (e.exit("codeTextSequence"), e.exit("codeText"), t(c))
				: ((o.type = "codeTextData"), u(c))
	}
}
class Np {
	constructor(t) {
		;(this.left = t ? [...t] : []), (this.right = [])
	}
	get(t) {
		if (t < 0 || t >= this.left.length + this.right.length)
			throw new RangeError(
				"Cannot access index `" +
					t +
					"` in a splice buffer of size `" +
					(this.left.length + this.right.length) +
					"`",
			)
		return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1]
	}
	get length() {
		return this.left.length + this.right.length
	}
	shift() {
		return this.setCursor(0), this.right.pop()
	}
	slice(t, n) {
		const r = n ?? Number.POSITIVE_INFINITY
		return r < this.left.length
			? this.left.slice(t, r)
			: t > this.left.length
				? this.right
						.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length)
						.reverse()
				: this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse())
	}
	splice(t, n, r) {
		const i = n || 0
		this.setCursor(Math.trunc(t))
		const o = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY)
		return r && hn(this.left, r), o.reverse()
	}
	pop() {
		return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop()
	}
	push(t) {
		this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t)
	}
	pushMany(t) {
		this.setCursor(Number.POSITIVE_INFINITY), hn(this.left, t)
	}
	unshift(t) {
		this.setCursor(0), this.right.push(t)
	}
	unshiftMany(t) {
		this.setCursor(0), hn(this.right, t.reverse())
	}
	setCursor(t) {
		if (
			!(
				t === this.left.length ||
				(t > this.left.length && this.right.length === 0) ||
				(t < 0 && this.left.length === 0)
			)
		)
			if (t < this.left.length) {
				const n = this.left.splice(t, Number.POSITIVE_INFINITY)
				hn(this.right, n.reverse())
			} else {
				const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY)
				hn(this.left, n.reverse())
			}
	}
}
function hn(e, t) {
	let n = 0
	if (t.length < 1e4) e.push(...t)
	else for (; n < t.length; ) e.push(...t.slice(n, n + 1e4)), (n += 1e4)
}
function ml(e) {
	const t = {}
	let n = -1,
		r,
		i,
		o,
		s,
		a,
		l,
		u
	const m = new Np(e)
	for (; ++n < m.length; ) {
		for (; n in t; ) n = t[n]
		if (
			((r = m.get(n)),
			n &&
				r[1].type === "chunkFlow" &&
				m.get(n - 1)[1].type === "listItemPrefix" &&
				((l = r[1]._tokenizer.events),
				(o = 0),
				o < l.length && l[o][1].type === "lineEndingBlank" && (o += 2),
				o < l.length && l[o][1].type === "content"))
		)
			for (; ++o < l.length && l[o][1].type !== "content"; )
				l[o][1].type === "chunkText" && ((l[o][1]._isInFirstContentOfListItem = !0), o++)
		if (r[0] === "enter") r[1].contentType && (Object.assign(t, Mp(m, n)), (n = t[n]), (u = !0))
		else if (r[1]._container) {
			for (o = n, i = void 0; o--; )
				if (((s = m.get(o)), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank"))
					s[0] === "enter" &&
						(i && (m.get(i)[1].type = "lineEndingBlank"), (s[1].type = "lineEnding"), (i = o))
				else if (!(s[1].type === "linePrefix" || s[1].type === "listItemIndent")) break
			i && ((r[1].end = { ...m.get(i)[1].start }), (a = m.slice(i, n)), a.unshift(r), m.splice(i, n - i + 1, a))
		}
	}
	return Je(e, 0, Number.POSITIVE_INFINITY, m.slice(0)), !u
}
function Mp(e, t) {
	const n = e.get(t)[1],
		r = e.get(t)[2]
	let i = t - 1
	const o = []
	let s = n._tokenizer
	s || ((s = r.parser[n.contentType](n.start)), n._contentTypeTextTrailing && (s._contentTypeTextTrailing = !0))
	const a = s.events,
		l = [],
		u = {}
	let m,
		c,
		h = -1,
		p = n,
		f = 0,
		y = 0
	const x = [y]
	for (; p; ) {
		for (; e.get(++i)[1] !== p; );
		o.push(i),
			p._tokenizer ||
				((m = r.sliceStream(p)),
				p.next || m.push(null),
				c && s.defineSkip(p.start),
				p._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0),
				s.write(m),
				p._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)),
			(c = p),
			(p = p.next)
	}
	for (p = n; ++h < a.length; )
		a[h][0] === "exit" &&
			a[h - 1][0] === "enter" &&
			a[h][1].type === a[h - 1][1].type &&
			a[h][1].start.line !== a[h][1].end.line &&
			((y = h + 1), x.push(y), (p._tokenizer = void 0), (p.previous = void 0), (p = p.next))
	for (s.events = [], p ? ((p._tokenizer = void 0), (p.previous = void 0)) : x.pop(), h = x.length; h--; ) {
		const d = a.slice(x[h], x[h + 1]),
			_ = o.pop()
		l.push([_, _ + d.length - 1]), e.splice(_, 2, d)
	}
	for (l.reverse(), h = -1; ++h < l.length; ) (u[f + l[h][0]] = f + l[h][1]), (f += l[h][1] - l[h][0] - 1)
	return u
}
const zp = { resolve: Bp, tokenize: Fp },
	Vp = { partial: !0, tokenize: jp }
function Bp(e) {
	return ml(e), e
}
function Fp(e, t) {
	let n
	return r
	function r(a) {
		return e.enter("content"), (n = e.enter("chunkContent", { contentType: "content" })), i(a)
	}
	function i(a) {
		return a === null ? o(a) : q(a) ? e.check(Vp, s, o)(a) : (e.consume(a), i)
	}
	function o(a) {
		return e.exit("chunkContent"), e.exit("content"), t(a)
	}
	function s(a) {
		return (
			e.consume(a),
			e.exit("chunkContent"),
			(n.next = e.enter("chunkContent", { contentType: "content", previous: n })),
			(n = n.next),
			i
		)
	}
}
function jp(e, t, n) {
	const r = this
	return i
	function i(s) {
		return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), oe(e, o, "linePrefix")
	}
	function o(s) {
		if (s === null || q(s)) return n(s)
		const a = r.events[r.events.length - 1]
		return !r.parser.constructs.disable.null.includes("codeIndented") &&
			a &&
			a[1].type === "linePrefix" &&
			a[2].sliceSerialize(a[1], !0).length >= 4
			? t(s)
			: e.interrupt(r.parser.constructs.flow, n, t)(s)
	}
}
function pl(e, t, n, r, i, o, s, a, l) {
	const u = l || Number.POSITIVE_INFINITY
	let m = 0
	return c
	function c(d) {
		return d === 60
			? (e.enter(r), e.enter(i), e.enter(o), e.consume(d), e.exit(o), h)
			: d === null || d === 32 || d === 41 || cr(d)
				? n(d)
				: (e.enter(r), e.enter(s), e.enter(a), e.enter("chunkString", { contentType: "string" }), y(d))
	}
	function h(d) {
		return d === 62
			? (e.enter(o), e.consume(d), e.exit(o), e.exit(i), e.exit(r), t)
			: (e.enter(a), e.enter("chunkString", { contentType: "string" }), p(d))
	}
	function p(d) {
		return d === 62
			? (e.exit("chunkString"), e.exit(a), h(d))
			: d === null || d === 60 || q(d)
				? n(d)
				: (e.consume(d), d === 92 ? f : p)
	}
	function f(d) {
		return d === 60 || d === 62 || d === 92 ? (e.consume(d), p) : p(d)
	}
	function y(d) {
		return !m && (d === null || d === 41 || fe(d))
			? (e.exit("chunkString"), e.exit(a), e.exit(s), e.exit(r), t(d))
			: m < u && d === 40
				? (e.consume(d), m++, y)
				: d === 41
					? (e.consume(d), m--, y)
					: d === null || d === 32 || d === 40 || cr(d)
						? n(d)
						: (e.consume(d), d === 92 ? x : y)
	}
	function x(d) {
		return d === 40 || d === 41 || d === 92 ? (e.consume(d), y) : y(d)
	}
}
function hl(e, t, n, r, i, o) {
	const s = this
	let a = 0,
		l
	return u
	function u(p) {
		return e.enter(r), e.enter(i), e.consume(p), e.exit(i), e.enter(o), m
	}
	function m(p) {
		return a > 999 ||
			p === null ||
			p === 91 ||
			(p === 93 && !l) ||
			(p === 94 && !a && "_hiddenFootnoteSupport" in s.parser.constructs)
			? n(p)
			: p === 93
				? (e.exit(o), e.enter(i), e.consume(p), e.exit(i), e.exit(r), t)
				: q(p)
					? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), m)
					: (e.enter("chunkString", { contentType: "string" }), c(p))
	}
	function c(p) {
		return p === null || p === 91 || p === 93 || q(p) || a++ > 999
			? (e.exit("chunkString"), m(p))
			: (e.consume(p), l || (l = !re(p)), p === 92 ? h : c)
	}
	function h(p) {
		return p === 91 || p === 92 || p === 93 ? (e.consume(p), a++, c) : c(p)
	}
}
function fl(e, t, n, r, i, o) {
	let s
	return a
	function a(h) {
		return h === 34 || h === 39 || h === 40
			? (e.enter(r), e.enter(i), e.consume(h), e.exit(i), (s = h === 40 ? 41 : h), l)
			: n(h)
	}
	function l(h) {
		return h === s ? (e.enter(i), e.consume(h), e.exit(i), e.exit(r), t) : (e.enter(o), u(h))
	}
	function u(h) {
		return h === s
			? (e.exit(o), l(s))
			: h === null
				? n(h)
				: q(h)
					? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), oe(e, u, "linePrefix"))
					: (e.enter("chunkString", { contentType: "string" }), m(h))
	}
	function m(h) {
		return h === s || h === null || q(h) ? (e.exit("chunkString"), u(h)) : (e.consume(h), h === 92 ? c : m)
	}
	function c(h) {
		return h === s || h === 92 ? (e.consume(h), m) : m(h)
	}
}
function bn(e, t) {
	let n
	return r
	function r(i) {
		return q(i)
			? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), (n = !0), r)
			: re(i)
				? oe(e, r, n ? "linePrefix" : "lineSuffix")(i)
				: t(i)
	}
}
const Hp = { name: "definition", tokenize: $p },
	Gp = { partial: !0, tokenize: Up }
function $p(e, t, n) {
	const r = this
	let i
	return o
	function o(p) {
		return e.enter("definition"), s(p)
	}
	function s(p) {
		return hl.call(r, e, a, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(p)
	}
	function a(p) {
		return (
			(i = ot(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))),
			p === 58 ? (e.enter("definitionMarker"), e.consume(p), e.exit("definitionMarker"), l) : n(p)
		)
	}
	function l(p) {
		return fe(p) ? bn(e, u)(p) : u(p)
	}
	function u(p) {
		return pl(
			e,
			m,
			n,
			"definitionDestination",
			"definitionDestinationLiteral",
			"definitionDestinationLiteralMarker",
			"definitionDestinationRaw",
			"definitionDestinationString",
		)(p)
	}
	function m(p) {
		return e.attempt(Gp, c, c)(p)
	}
	function c(p) {
		return re(p) ? oe(e, h, "whitespace")(p) : h(p)
	}
	function h(p) {
		return p === null || q(p) ? (e.exit("definition"), r.parser.defined.push(i), t(p)) : n(p)
	}
}
function Up(e, t, n) {
	return r
	function r(a) {
		return fe(a) ? bn(e, i)(a) : n(a)
	}
	function i(a) {
		return fl(e, o, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(a)
	}
	function o(a) {
		return re(a) ? oe(e, s, "whitespace")(a) : s(a)
	}
	function s(a) {
		return a === null || q(a) ? t(a) : n(a)
	}
}
const qp = { name: "hardBreakEscape", tokenize: Wp }
function Wp(e, t, n) {
	return r
	function r(o) {
		return e.enter("hardBreakEscape"), e.consume(o), i
	}
	function i(o) {
		return q(o) ? (e.exit("hardBreakEscape"), t(o)) : n(o)
	}
}
const Kp = { name: "headingAtx", resolve: Yp, tokenize: Xp }
function Yp(e, t) {
	let n = e.length - 2,
		r = 3,
		i,
		o
	return (
		e[r][1].type === "whitespace" && (r += 2),
		n - 2 > r && e[n][1].type === "whitespace" && (n -= 2),
		e[n][1].type === "atxHeadingSequence" &&
			(r === n - 1 || (n - 4 > r && e[n - 2][1].type === "whitespace")) &&
			(n -= r + 1 === n ? 2 : 4),
		n > r &&
			((i = { type: "atxHeadingText", start: e[r][1].start, end: e[n][1].end }),
			(o = { type: "chunkText", start: e[r][1].start, end: e[n][1].end, contentType: "text" }),
			Je(e, r, n - r + 1, [
				["enter", i, t],
				["enter", o, t],
				["exit", o, t],
				["exit", i, t],
			])),
		e
	)
}
function Xp(e, t, n) {
	let r = 0
	return i
	function i(m) {
		return e.enter("atxHeading"), o(m)
	}
	function o(m) {
		return e.enter("atxHeadingSequence"), s(m)
	}
	function s(m) {
		return m === 35 && r++ < 6
			? (e.consume(m), s)
			: m === null || fe(m)
				? (e.exit("atxHeadingSequence"), a(m))
				: n(m)
	}
	function a(m) {
		return m === 35
			? (e.enter("atxHeadingSequence"), l(m))
			: m === null || q(m)
				? (e.exit("atxHeading"), t(m))
				: re(m)
					? oe(e, a, "whitespace")(m)
					: (e.enter("atxHeadingText"), u(m))
	}
	function l(m) {
		return m === 35 ? (e.consume(m), l) : (e.exit("atxHeadingSequence"), a(m))
	}
	function u(m) {
		return m === null || m === 35 || fe(m) ? (e.exit("atxHeadingText"), a(m)) : (e.consume(m), u)
	}
}
const Qp = [
		"address",
		"article",
		"aside",
		"base",
		"basefont",
		"blockquote",
		"body",
		"caption",
		"center",
		"col",
		"colgroup",
		"dd",
		"details",
		"dialog",
		"dir",
		"div",
		"dl",
		"dt",
		"fieldset",
		"figcaption",
		"figure",
		"footer",
		"form",
		"frame",
		"frameset",
		"h1",
		"h2",
		"h3",
		"h4",
		"h5",
		"h6",
		"head",
		"header",
		"hr",
		"html",
		"iframe",
		"legend",
		"li",
		"link",
		"main",
		"menu",
		"menuitem",
		"nav",
		"noframes",
		"ol",
		"optgroup",
		"option",
		"p",
		"param",
		"search",
		"section",
		"summary",
		"table",
		"tbody",
		"td",
		"tfoot",
		"th",
		"thead",
		"title",
		"tr",
		"track",
		"ul",
	],
	ms = ["pre", "script", "style", "textarea"],
	Jp = { concrete: !0, name: "htmlFlow", resolveTo: th, tokenize: nh },
	Zp = { partial: !0, tokenize: ih },
	eh = { partial: !0, tokenize: rh }
function th(e) {
	let t = e.length
	for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); );
	return (
		t > 1 &&
			e[t - 2][1].type === "linePrefix" &&
			((e[t][1].start = e[t - 2][1].start), (e[t + 1][1].start = e[t - 2][1].start), e.splice(t - 2, 2)),
		e
	)
}
function nh(e, t, n) {
	const r = this
	let i, o, s, a, l
	return u
	function u(E) {
		return m(E)
	}
	function m(E) {
		return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(E), c
	}
	function c(E) {
		return E === 33
			? (e.consume(E), h)
			: E === 47
				? (e.consume(E), (o = !0), y)
				: E === 63
					? (e.consume(E), (i = 3), r.interrupt ? t : k)
					: je(E)
						? (e.consume(E), (s = String.fromCharCode(E)), x)
						: n(E)
	}
	function h(E) {
		return E === 45
			? (e.consume(E), (i = 2), p)
			: E === 91
				? (e.consume(E), (i = 5), (a = 0), f)
				: je(E)
					? (e.consume(E), (i = 4), r.interrupt ? t : k)
					: n(E)
	}
	function p(E) {
		return E === 45 ? (e.consume(E), r.interrupt ? t : k) : n(E)
	}
	function f(E) {
		const Pe = "CDATA["
		return E === Pe.charCodeAt(a++) ? (e.consume(E), a === Pe.length ? (r.interrupt ? t : M) : f) : n(E)
	}
	function y(E) {
		return je(E) ? (e.consume(E), (s = String.fromCharCode(E)), x) : n(E)
	}
	function x(E) {
		if (E === null || E === 47 || E === 62 || fe(E)) {
			const Pe = E === 47,
				Ge = s.toLowerCase()
			return !Pe && !o && ms.includes(Ge)
				? ((i = 1), r.interrupt ? t(E) : M(E))
				: Qp.includes(s.toLowerCase())
					? ((i = 6), Pe ? (e.consume(E), d) : r.interrupt ? t(E) : M(E))
					: ((i = 7), r.interrupt && !r.parser.lazy[r.now().line] ? n(E) : o ? _(E) : w(E))
		}
		return E === 45 || Ve(E) ? (e.consume(E), (s += String.fromCharCode(E)), x) : n(E)
	}
	function d(E) {
		return E === 62 ? (e.consume(E), r.interrupt ? t : M) : n(E)
	}
	function _(E) {
		return re(E) ? (e.consume(E), _) : v(E)
	}
	function w(E) {
		return E === 47
			? (e.consume(E), v)
			: E === 58 || E === 95 || je(E)
				? (e.consume(E), I)
				: re(E)
					? (e.consume(E), w)
					: v(E)
	}
	function I(E) {
		return E === 45 || E === 46 || E === 58 || E === 95 || Ve(E) ? (e.consume(E), I) : S(E)
	}
	function S(E) {
		return E === 61 ? (e.consume(E), b) : re(E) ? (e.consume(E), S) : w(E)
	}
	function b(E) {
		return E === null || E === 60 || E === 61 || E === 62 || E === 96
			? n(E)
			: E === 34 || E === 39
				? (e.consume(E), (l = E), T)
				: re(E)
					? (e.consume(E), b)
					: P(E)
	}
	function T(E) {
		return E === l ? (e.consume(E), (l = null), z) : E === null || q(E) ? n(E) : (e.consume(E), T)
	}
	function P(E) {
		return E === null || E === 34 || E === 39 || E === 47 || E === 60 || E === 61 || E === 62 || E === 96 || fe(E)
			? S(E)
			: (e.consume(E), P)
	}
	function z(E) {
		return E === 47 || E === 62 || re(E) ? w(E) : n(E)
	}
	function v(E) {
		return E === 62 ? (e.consume(E), L) : n(E)
	}
	function L(E) {
		return E === null || q(E) ? M(E) : re(E) ? (e.consume(E), L) : n(E)
	}
	function M(E) {
		return E === 45 && i === 2
			? (e.consume(E), Z)
			: E === 60 && i === 1
				? (e.consume(E), le)
				: E === 62 && i === 4
					? (e.consume(E), pe)
					: E === 63 && i === 3
						? (e.consume(E), k)
						: E === 93 && i === 5
							? (e.consume(E), Ee)
							: q(E) && (i === 6 || i === 7)
								? (e.exit("htmlFlowData"), e.check(Zp, Le, B)(E))
								: E === null || q(E)
									? (e.exit("htmlFlowData"), B(E))
									: (e.consume(E), M)
	}
	function B(E) {
		return e.check(eh, C, Le)(E)
	}
	function C(E) {
		return e.enter("lineEnding"), e.consume(E), e.exit("lineEnding"), j
	}
	function j(E) {
		return E === null || q(E) ? B(E) : (e.enter("htmlFlowData"), M(E))
	}
	function Z(E) {
		return E === 45 ? (e.consume(E), k) : M(E)
	}
	function le(E) {
		return E === 47 ? (e.consume(E), (s = ""), xe) : M(E)
	}
	function xe(E) {
		if (E === 62) {
			const Pe = s.toLowerCase()
			return ms.includes(Pe) ? (e.consume(E), pe) : M(E)
		}
		return je(E) && s.length < 8 ? (e.consume(E), (s += String.fromCharCode(E)), xe) : M(E)
	}
	function Ee(E) {
		return E === 93 ? (e.consume(E), k) : M(E)
	}
	function k(E) {
		return E === 62 ? (e.consume(E), pe) : E === 45 && i === 2 ? (e.consume(E), k) : M(E)
	}
	function pe(E) {
		return E === null || q(E) ? (e.exit("htmlFlowData"), Le(E)) : (e.consume(E), pe)
	}
	function Le(E) {
		return e.exit("htmlFlow"), t(E)
	}
}
function rh(e, t, n) {
	const r = this
	return i
	function i(s) {
		return q(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o) : n(s)
	}
	function o(s) {
		return r.parser.lazy[r.now().line] ? n(s) : t(s)
	}
}
function ih(e, t, n) {
	return r
	function r(i) {
		return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(Fn, t, n)
	}
}
const oh = { name: "htmlText", tokenize: sh }
function sh(e, t, n) {
	const r = this
	let i, o, s
	return a
	function a(k) {
		return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(k), l
	}
	function l(k) {
		return k === 33
			? (e.consume(k), u)
			: k === 47
				? (e.consume(k), S)
				: k === 63
					? (e.consume(k), w)
					: je(k)
						? (e.consume(k), P)
						: n(k)
	}
	function u(k) {
		return k === 45 ? (e.consume(k), m) : k === 91 ? (e.consume(k), (o = 0), f) : je(k) ? (e.consume(k), _) : n(k)
	}
	function m(k) {
		return k === 45 ? (e.consume(k), p) : n(k)
	}
	function c(k) {
		return k === null ? n(k) : k === 45 ? (e.consume(k), h) : q(k) ? ((s = c), le(k)) : (e.consume(k), c)
	}
	function h(k) {
		return k === 45 ? (e.consume(k), p) : c(k)
	}
	function p(k) {
		return k === 62 ? Z(k) : k === 45 ? h(k) : c(k)
	}
	function f(k) {
		const pe = "CDATA["
		return k === pe.charCodeAt(o++) ? (e.consume(k), o === pe.length ? y : f) : n(k)
	}
	function y(k) {
		return k === null ? n(k) : k === 93 ? (e.consume(k), x) : q(k) ? ((s = y), le(k)) : (e.consume(k), y)
	}
	function x(k) {
		return k === 93 ? (e.consume(k), d) : y(k)
	}
	function d(k) {
		return k === 62 ? Z(k) : k === 93 ? (e.consume(k), d) : y(k)
	}
	function _(k) {
		return k === null || k === 62 ? Z(k) : q(k) ? ((s = _), le(k)) : (e.consume(k), _)
	}
	function w(k) {
		return k === null ? n(k) : k === 63 ? (e.consume(k), I) : q(k) ? ((s = w), le(k)) : (e.consume(k), w)
	}
	function I(k) {
		return k === 62 ? Z(k) : w(k)
	}
	function S(k) {
		return je(k) ? (e.consume(k), b) : n(k)
	}
	function b(k) {
		return k === 45 || Ve(k) ? (e.consume(k), b) : T(k)
	}
	function T(k) {
		return q(k) ? ((s = T), le(k)) : re(k) ? (e.consume(k), T) : Z(k)
	}
	function P(k) {
		return k === 45 || Ve(k) ? (e.consume(k), P) : k === 47 || k === 62 || fe(k) ? z(k) : n(k)
	}
	function z(k) {
		return k === 47
			? (e.consume(k), Z)
			: k === 58 || k === 95 || je(k)
				? (e.consume(k), v)
				: q(k)
					? ((s = z), le(k))
					: re(k)
						? (e.consume(k), z)
						: Z(k)
	}
	function v(k) {
		return k === 45 || k === 46 || k === 58 || k === 95 || Ve(k) ? (e.consume(k), v) : L(k)
	}
	function L(k) {
		return k === 61 ? (e.consume(k), M) : q(k) ? ((s = L), le(k)) : re(k) ? (e.consume(k), L) : z(k)
	}
	function M(k) {
		return k === null || k === 60 || k === 61 || k === 62 || k === 96
			? n(k)
			: k === 34 || k === 39
				? (e.consume(k), (i = k), B)
				: q(k)
					? ((s = M), le(k))
					: re(k)
						? (e.consume(k), M)
						: (e.consume(k), C)
	}
	function B(k) {
		return k === i
			? (e.consume(k), (i = void 0), j)
			: k === null
				? n(k)
				: q(k)
					? ((s = B), le(k))
					: (e.consume(k), B)
	}
	function C(k) {
		return k === null || k === 34 || k === 39 || k === 60 || k === 61 || k === 96
			? n(k)
			: k === 47 || k === 62 || fe(k)
				? z(k)
				: (e.consume(k), C)
	}
	function j(k) {
		return k === 47 || k === 62 || fe(k) ? z(k) : n(k)
	}
	function Z(k) {
		return k === 62 ? (e.consume(k), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(k)
	}
	function le(k) {
		return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(k), e.exit("lineEnding"), xe
	}
	function xe(k) {
		return re(k)
			? oe(e, Ee, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(k)
			: Ee(k)
	}
	function Ee(k) {
		return e.enter("htmlTextData"), s(k)
	}
}
const so = { name: "labelEnd", resolveAll: ch, resolveTo: mh, tokenize: ph },
	ah = { tokenize: hh },
	lh = { tokenize: fh },
	uh = { tokenize: dh }
function ch(e) {
	let t = -1
	const n = []
	for (; ++t < e.length; ) {
		const r = e[t][1]
		if ((n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd")) {
			const i = r.type === "labelImage" ? 4 : 2
			;(r.type = "data"), (t += i)
		}
	}
	return e.length !== n.length && Je(e, 0, e.length, n), e
}
function mh(e, t) {
	let n = e.length,
		r = 0,
		i,
		o,
		s,
		a
	for (; n--; )
		if (((i = e[n][1]), o)) {
			if (i.type === "link" || (i.type === "labelLink" && i._inactive)) break
			e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0)
		} else if (s) {
			if (
				e[n][0] === "enter" &&
				(i.type === "labelImage" || i.type === "labelLink") &&
				!i._balanced &&
				((o = n), i.type !== "labelLink")
			) {
				r = 2
				break
			}
		} else i.type === "labelEnd" && (s = n)
	const l = {
			type: e[o][1].type === "labelLink" ? "link" : "image",
			start: { ...e[o][1].start },
			end: { ...e[e.length - 1][1].end },
		},
		u = { type: "label", start: { ...e[o][1].start }, end: { ...e[s][1].end } },
		m = { type: "labelText", start: { ...e[o + r + 2][1].end }, end: { ...e[s - 2][1].start } }
	return (
		(a = [
			["enter", l, t],
			["enter", u, t],
		]),
		(a = et(a, e.slice(o + 1, o + r + 3))),
		(a = et(a, [["enter", m, t]])),
		(a = et(a, Dr(t.parser.constructs.insideSpan.null, e.slice(o + r + 4, s - 3), t))),
		(a = et(a, [["exit", m, t], e[s - 2], e[s - 1], ["exit", u, t]])),
		(a = et(a, e.slice(s + 1))),
		(a = et(a, [["exit", l, t]])),
		Je(e, o, e.length, a),
		e
	)
}
function ph(e, t, n) {
	const r = this
	let i = r.events.length,
		o,
		s
	for (; i--; )
		if (
			(r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") &&
			!r.events[i][1]._balanced
		) {
			o = r.events[i][1]
			break
		}
	return a
	function a(h) {
		return o
			? o._inactive
				? c(h)
				: ((s = r.parser.defined.includes(ot(r.sliceSerialize({ start: o.end, end: r.now() })))),
					e.enter("labelEnd"),
					e.enter("labelMarker"),
					e.consume(h),
					e.exit("labelMarker"),
					e.exit("labelEnd"),
					l)
			: n(h)
	}
	function l(h) {
		return h === 40 ? e.attempt(ah, m, s ? m : c)(h) : h === 91 ? e.attempt(lh, m, s ? u : c)(h) : s ? m(h) : c(h)
	}
	function u(h) {
		return e.attempt(uh, m, c)(h)
	}
	function m(h) {
		return t(h)
	}
	function c(h) {
		return (o._balanced = !0), n(h)
	}
}
function hh(e, t, n) {
	return r
	function r(c) {
		return e.enter("resource"), e.enter("resourceMarker"), e.consume(c), e.exit("resourceMarker"), i
	}
	function i(c) {
		return fe(c) ? bn(e, o)(c) : o(c)
	}
	function o(c) {
		return c === 41
			? m(c)
			: pl(
					e,
					s,
					a,
					"resourceDestination",
					"resourceDestinationLiteral",
					"resourceDestinationLiteralMarker",
					"resourceDestinationRaw",
					"resourceDestinationString",
					32,
				)(c)
	}
	function s(c) {
		return fe(c) ? bn(e, l)(c) : m(c)
	}
	function a(c) {
		return n(c)
	}
	function l(c) {
		return c === 34 || c === 39 || c === 40
			? fl(e, u, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(c)
			: m(c)
	}
	function u(c) {
		return fe(c) ? bn(e, m)(c) : m(c)
	}
	function m(c) {
		return c === 41
			? (e.enter("resourceMarker"), e.consume(c), e.exit("resourceMarker"), e.exit("resource"), t)
			: n(c)
	}
}
function fh(e, t, n) {
	const r = this
	return i
	function i(a) {
		return hl.call(r, e, o, s, "reference", "referenceMarker", "referenceString")(a)
	}
	function o(a) {
		return r.parser.defined.includes(ot(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)))
			? t(a)
			: n(a)
	}
	function s(a) {
		return n(a)
	}
}
function dh(e, t, n) {
	return r
	function r(o) {
		return e.enter("reference"), e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), i
	}
	function i(o) {
		return o === 93
			? (e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), e.exit("reference"), t)
			: n(o)
	}
}
const gh = { name: "labelStartImage", resolveAll: so.resolveAll, tokenize: _h }
function _h(e, t, n) {
	const r = this
	return i
	function i(a) {
		return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(a), e.exit("labelImageMarker"), o
	}
	function o(a) {
		return a === 91 ? (e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelImage"), s) : n(a)
	}
	function s(a) {
		return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : t(a)
	}
}
const yh = { name: "labelStartLink", resolveAll: so.resolveAll, tokenize: xh }
function xh(e, t, n) {
	const r = this
	return i
	function i(s) {
		return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), o
	}
	function o(s) {
		return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s)
	}
}
const Qr = { name: "lineEnding", tokenize: bh }
function bh(e, t) {
	return n
	function n(r) {
		return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), oe(e, t, "linePrefix")
	}
}
const rr = { name: "thematicBreak", tokenize: kh }
function kh(e, t, n) {
	let r = 0,
		i
	return o
	function o(u) {
		return e.enter("thematicBreak"), s(u)
	}
	function s(u) {
		return (i = u), a(u)
	}
	function a(u) {
		return u === i
			? (e.enter("thematicBreakSequence"), l(u))
			: r >= 3 && (u === null || q(u))
				? (e.exit("thematicBreak"), t(u))
				: n(u)
	}
	function l(u) {
		return u === i
			? (e.consume(u), r++, l)
			: (e.exit("thematicBreakSequence"), re(u) ? oe(e, a, "whitespace")(u) : a(u))
	}
}
const Ue = { continuation: { tokenize: Sh }, exit: Th, name: "list", tokenize: vh },
	wh = { partial: !0, tokenize: Ch },
	Eh = { partial: !0, tokenize: Ih }
function vh(e, t, n) {
	const r = this,
		i = r.events[r.events.length - 1]
	let o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0,
		s = 0
	return a
	function a(p) {
		const f = r.containerState.type || (p === 42 || p === 43 || p === 45 ? "listUnordered" : "listOrdered")
		if (f === "listUnordered" ? !r.containerState.marker || p === r.containerState.marker : Ti(p)) {
			if (
				(r.containerState.type || ((r.containerState.type = f), e.enter(f, { _container: !0 })),
				f === "listUnordered")
			)
				return e.enter("listItemPrefix"), p === 42 || p === 45 ? e.check(rr, n, u)(p) : u(p)
			if (!r.interrupt || p === 49) return e.enter("listItemPrefix"), e.enter("listItemValue"), l(p)
		}
		return n(p)
	}
	function l(p) {
		return Ti(p) && ++s < 10
			? (e.consume(p), l)
			: (!r.interrupt || s < 2) &&
				  (r.containerState.marker ? p === r.containerState.marker : p === 41 || p === 46)
				? (e.exit("listItemValue"), u(p))
				: n(p)
	}
	function u(p) {
		return (
			e.enter("listItemMarker"),
			e.consume(p),
			e.exit("listItemMarker"),
			(r.containerState.marker = r.containerState.marker || p),
			e.check(Fn, r.interrupt ? n : m, e.attempt(wh, h, c))
		)
	}
	function m(p) {
		return (r.containerState.initialBlankLine = !0), o++, h(p)
	}
	function c(p) {
		return re(p) ? (e.enter("listItemPrefixWhitespace"), e.consume(p), e.exit("listItemPrefixWhitespace"), h) : n(p)
	}
	function h(p) {
		return (r.containerState.size = o + r.sliceSerialize(e.exit("listItemPrefix"), !0).length), t(p)
	}
}
function Sh(e, t, n) {
	const r = this
	return (r.containerState._closeFlow = void 0), e.check(Fn, i, o)
	function i(a) {
		return (
			(r.containerState.furtherBlankLines =
				r.containerState.furtherBlankLines || r.containerState.initialBlankLine),
			oe(e, t, "listItemIndent", r.containerState.size + 1)(a)
		)
	}
	function o(a) {
		return r.containerState.furtherBlankLines || !re(a)
			? ((r.containerState.furtherBlankLines = void 0), (r.containerState.initialBlankLine = void 0), s(a))
			: ((r.containerState.furtherBlankLines = void 0),
				(r.containerState.initialBlankLine = void 0),
				e.attempt(Eh, t, s)(a))
	}
	function s(a) {
		return (
			(r.containerState._closeFlow = !0),
			(r.interrupt = void 0),
			oe(
				e,
				e.attempt(Ue, t, n),
				"linePrefix",
				r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
			)(a)
		)
	}
}
function Ih(e, t, n) {
	const r = this
	return oe(e, i, "listItemIndent", r.containerState.size + 1)
	function i(o) {
		const s = r.events[r.events.length - 1]
		return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size
			? t(o)
			: n(o)
	}
}
function Th(e) {
	e.exit(this.containerState.type)
}
function Ch(e, t, n) {
	const r = this
	return oe(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5)
	function i(o) {
		const s = r.events[r.events.length - 1]
		return !re(o) && s && s[1].type === "listItemPrefixWhitespace" ? t(o) : n(o)
	}
}
const ps = { name: "setextUnderline", resolveTo: Ah, tokenize: Rh }
function Ah(e, t) {
	let n = e.length,
		r,
		i,
		o
	for (; n--; )
		if (e[n][0] === "enter") {
			if (e[n][1].type === "content") {
				r = n
				break
			}
			e[n][1].type === "paragraph" && (i = n)
		} else e[n][1].type === "content" && e.splice(n, 1), !o && e[n][1].type === "definition" && (o = n)
	const s = { type: "setextHeading", start: { ...e[r][1].start }, end: { ...e[e.length - 1][1].end } }
	return (
		(e[i][1].type = "setextHeadingText"),
		o
			? (e.splice(i, 0, ["enter", s, t]),
				e.splice(o + 1, 0, ["exit", e[r][1], t]),
				(e[r][1].end = { ...e[o][1].end }))
			: (e[r][1] = s),
		e.push(["exit", s, t]),
		e
	)
}
function Rh(e, t, n) {
	const r = this
	let i
	return o
	function o(u) {
		let m = r.events.length,
			c
		for (; m--; )
			if (
				r.events[m][1].type !== "lineEnding" &&
				r.events[m][1].type !== "linePrefix" &&
				r.events[m][1].type !== "content"
			) {
				c = r.events[m][1].type === "paragraph"
				break
			}
		return !r.parser.lazy[r.now().line] && (r.interrupt || c) ? (e.enter("setextHeadingLine"), (i = u), s(u)) : n(u)
	}
	function s(u) {
		return e.enter("setextHeadingLineSequence"), a(u)
	}
	function a(u) {
		return u === i
			? (e.consume(u), a)
			: (e.exit("setextHeadingLineSequence"), re(u) ? oe(e, l, "lineSuffix")(u) : l(u))
	}
	function l(u) {
		return u === null || q(u) ? (e.exit("setextHeadingLine"), t(u)) : n(u)
	}
}
const Lh = { tokenize: Ph }
function Ph(e) {
	const t = this,
		n = e.attempt(
			Fn,
			r,
			e.attempt(
				this.parser.constructs.flowInitial,
				i,
				oe(e, e.attempt(this.parser.constructs.flow, i, e.attempt(zp, i)), "linePrefix"),
			),
		)
	return n
	function r(o) {
		if (o === null) {
			e.consume(o)
			return
		}
		return e.enter("lineEndingBlank"), e.consume(o), e.exit("lineEndingBlank"), (t.currentConstruct = void 0), n
	}
	function i(o) {
		if (o === null) {
			e.consume(o)
			return
		}
		return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), (t.currentConstruct = void 0), n
	}
}
const Oh = { resolveAll: gl() },
	Dh = dl("string"),
	Nh = dl("text")
function dl(e) {
	return { resolveAll: gl(e === "text" ? Mh : void 0), tokenize: t }
	function t(n) {
		const r = this,
			i = this.parser.constructs[e],
			o = n.attempt(i, s, a)
		return s
		function s(m) {
			return u(m) ? o(m) : a(m)
		}
		function a(m) {
			if (m === null) {
				n.consume(m)
				return
			}
			return n.enter("data"), n.consume(m), l
		}
		function l(m) {
			return u(m) ? (n.exit("data"), o(m)) : (n.consume(m), l)
		}
		function u(m) {
			if (m === null) return !0
			const c = i[m]
			let h = -1
			if (c)
				for (; ++h < c.length; ) {
					const p = c[h]
					if (!p.previous || p.previous.call(r, r.previous)) return !0
				}
			return !1
		}
	}
}
function gl(e) {
	return t
	function t(n, r) {
		let i = -1,
			o
		for (; ++i <= n.length; )
			o === void 0
				? n[i] && n[i][1].type === "data" && ((o = i), i++)
				: (!n[i] || n[i][1].type !== "data") &&
					(i !== o + 2 && ((n[o][1].end = n[i - 1][1].end), n.splice(o + 2, i - o - 2), (i = o + 2)),
					(o = void 0))
		return e ? e(n, r) : n
	}
}
function Mh(e, t) {
	let n = 0
	for (; ++n <= e.length; )
		if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
			const r = e[n - 1][1],
				i = t.sliceStream(r)
			let o = i.length,
				s = -1,
				a = 0,
				l
			for (; o--; ) {
				const u = i[o]
				if (typeof u == "string") {
					for (s = u.length; u.charCodeAt(s - 1) === 32; ) a++, s--
					if (s) break
					s = -1
				} else if (u === -2) (l = !0), a++
				else if (u !== -1) {
					o++
					break
				}
			}
			if ((t._contentTypeTextTrailing && n === e.length && (a = 0), a)) {
				const u = {
					type: n === e.length || l || a < 2 ? "lineSuffix" : "hardBreakTrailing",
					start: {
						_bufferIndex: o ? s : r.start._bufferIndex + s,
						_index: r.start._index + o,
						line: r.end.line,
						column: r.end.column - a,
						offset: r.end.offset - a,
					},
					end: { ...r.end },
				}
				;(r.end = { ...u.start }),
					r.start.offset === r.end.offset
						? Object.assign(r, u)
						: (e.splice(n, 0, ["enter", u, t], ["exit", u, t]), (n += 2))
			}
			n++
		}
	return e
}
const zh = {
		42: Ue,
		43: Ue,
		45: Ue,
		48: Ue,
		49: Ue,
		50: Ue,
		51: Ue,
		52: Ue,
		53: Ue,
		54: Ue,
		55: Ue,
		56: Ue,
		57: Ue,
		62: ll,
	},
	Vh = { 91: Hp },
	Bh = { [-2]: Xr, [-1]: Xr, 32: Xr },
	Fh = { 35: Kp, 42: rr, 45: [ps, rr], 60: Jp, 61: ps, 95: rr, 96: cs, 126: cs },
	jh = { 38: cl, 92: ul },
	Hh = {
		[-5]: Qr,
		[-4]: Qr,
		[-3]: Qr,
		33: gh,
		38: cl,
		42: Ci,
		60: [yp, oh],
		91: yh,
		92: [qp, ul],
		93: so,
		95: Ci,
		96: Lp,
	},
	Gh = { null: [Ci, Oh] },
	$h = { null: [42, 95] },
	Uh = { null: [] },
	qh = Object.freeze(
		Object.defineProperty(
			{
				__proto__: null,
				attentionMarkers: $h,
				contentInitial: Vh,
				disable: Uh,
				document: zh,
				flow: Fh,
				flowInitial: Bh,
				insideSpan: Gh,
				string: jh,
				text: Hh,
			},
			Symbol.toStringTag,
			{ value: "Module" },
		),
	)
function Wh(e, t, n) {
	let r = {
		_bufferIndex: -1,
		_index: 0,
		line: (n && n.line) || 1,
		column: (n && n.column) || 1,
		offset: (n && n.offset) || 0,
	}
	const i = {},
		o = []
	let s = [],
		a = []
	const l = { attempt: T(S), check: T(b), consume: _, enter: w, exit: I, interrupt: T(b, { interrupt: !0 }) },
		u = {
			code: null,
			containerState: {},
			defineSkip: y,
			events: [],
			now: f,
			parser: e,
			previous: null,
			sliceSerialize: h,
			sliceStream: p,
			write: c,
		}
	let m = t.tokenize.call(u, l)
	return t.resolveAll && o.push(t), u
	function c(L) {
		return (s = et(s, L)), x(), s[s.length - 1] !== null ? [] : (P(t, 0), (u.events = Dr(o, u.events, u)), u.events)
	}
	function h(L, M) {
		return Yh(p(L), M)
	}
	function p(L) {
		return Kh(s, L)
	}
	function f() {
		const { _bufferIndex: L, _index: M, line: B, column: C, offset: j } = r
		return { _bufferIndex: L, _index: M, line: B, column: C, offset: j }
	}
	function y(L) {
		;(i[L.line] = L.column), v()
	}
	function x() {
		let L
		for (; r._index < s.length; ) {
			const M = s[r._index]
			if (typeof M == "string")
				for (
					L = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0);
					r._index === L && r._bufferIndex < M.length;

				)
					d(M.charCodeAt(r._bufferIndex))
			else d(M)
		}
	}
	function d(L) {
		m = m(L)
	}
	function _(L) {
		q(L) ? (r.line++, (r.column = 1), (r.offset += L === -3 ? 2 : 1), v()) : L !== -1 && (r.column++, r.offset++),
			r._bufferIndex < 0
				? r._index++
				: (r._bufferIndex++, r._bufferIndex === s[r._index].length && ((r._bufferIndex = -1), r._index++)),
			(u.previous = L)
	}
	function w(L, M) {
		const B = M || {}
		return (B.type = L), (B.start = f()), u.events.push(["enter", B, u]), a.push(B), B
	}
	function I(L) {
		const M = a.pop()
		return (M.end = f()), u.events.push(["exit", M, u]), M
	}
	function S(L, M) {
		P(L, M.from)
	}
	function b(L, M) {
		M.restore()
	}
	function T(L, M) {
		return B
		function B(C, j, Z) {
			let le, xe, Ee, k
			return Array.isArray(C) ? Le(C) : "tokenize" in C ? Le([C]) : pe(C)
			function pe(me) {
				return Fe
				function Fe(V) {
					const X = V !== null && me[V],
						se = V !== null && me.null,
						ke = [...(Array.isArray(X) ? X : X ? [X] : []), ...(Array.isArray(se) ? se : se ? [se] : [])]
					return Le(ke)(V)
				}
			}
			function Le(me) {
				return (le = me), (xe = 0), me.length === 0 ? Z : E(me[xe])
			}
			function E(me) {
				return Fe
				function Fe(V) {
					return (
						(k = z()),
						(Ee = me),
						me.partial || (u.currentConstruct = me),
						me.name && u.parser.constructs.disable.null.includes(me.name)
							? Ge()
							: me.tokenize.call(M ? Object.assign(Object.create(u), M) : u, l, Pe, Ge)(V)
					)
				}
			}
			function Pe(me) {
				return L(Ee, k), j
			}
			function Ge(me) {
				return k.restore(), ++xe < le.length ? E(le[xe]) : Z
			}
		}
	}
	function P(L, M) {
		L.resolveAll && !o.includes(L) && o.push(L),
			L.resolve && Je(u.events, M, u.events.length - M, L.resolve(u.events.slice(M), u)),
			L.resolveTo && (u.events = L.resolveTo(u.events, u))
	}
	function z() {
		const L = f(),
			M = u.previous,
			B = u.currentConstruct,
			C = u.events.length,
			j = Array.from(a)
		return { from: C, restore: Z }
		function Z() {
			;(r = L), (u.previous = M), (u.currentConstruct = B), (u.events.length = C), (a = j), v()
		}
	}
	function v() {
		r.line in i && r.column < 2 && ((r.column = i[r.line]), (r.offset += i[r.line] - 1))
	}
}
function Kh(e, t) {
	const n = t.start._index,
		r = t.start._bufferIndex,
		i = t.end._index,
		o = t.end._bufferIndex
	let s
	if (n === i) s = [e[n].slice(r, o)]
	else {
		if (((s = e.slice(n, i)), r > -1)) {
			const a = s[0]
			typeof a == "string" ? (s[0] = a.slice(r)) : s.shift()
		}
		o > 0 && s.push(e[i].slice(0, o))
	}
	return s
}
function Yh(e, t) {
	let n = -1
	const r = []
	let i
	for (; ++n < e.length; ) {
		const o = e[n]
		let s
		if (typeof o == "string") s = o
		else
			switch (o) {
				case -5: {
					s = "\r"
					break
				}
				case -4: {
					s = `
`
					break
				}
				case -3: {
					s = `\r
`
					break
				}
				case -2: {
					s = t ? " " : "	"
					break
				}
				case -1: {
					if (!t && i) continue
					s = " "
					break
				}
				default:
					s = String.fromCharCode(o)
			}
		;(i = o === -2), r.push(s)
	}
	return r.join("")
}
function Xh(e) {
	const r = {
		constructs: sl([qh, ...((e || {}).extensions || [])]),
		content: i(mp),
		defined: [],
		document: i(hp),
		flow: i(Lh),
		lazy: {},
		string: i(Dh),
		text: i(Nh),
	}
	return r
	function i(o) {
		return s
		function s(a) {
			return Wh(r, o, a)
		}
	}
}
function Qh(e) {
	for (; !ml(e); );
	return e
}
const hs = /[\0\t\n\r]/g
function Jh() {
	let e = 1,
		t = "",
		n = !0,
		r
	return i
	function i(o, s, a) {
		const l = []
		let u, m, c, h, p
		for (
			o = t + (typeof o == "string" ? o.toString() : new TextDecoder(s || void 0).decode(o)),
				c = 0,
				t = "",
				n && (o.charCodeAt(0) === 65279 && c++, (n = void 0));
			c < o.length;

		) {
			if (
				((hs.lastIndex = c),
				(u = hs.exec(o)),
				(h = u && u.index !== void 0 ? u.index : o.length),
				(p = o.charCodeAt(h)),
				!u)
			) {
				t = o.slice(c)
				break
			}
			if (p === 10 && c === h && r) l.push(-3), (r = void 0)
			else
				switch ((r && (l.push(-5), (r = void 0)), c < h && (l.push(o.slice(c, h)), (e += h - c)), p)) {
					case 0: {
						l.push(65533), e++
						break
					}
					case 9: {
						for (m = Math.ceil(e / 4) * 4, l.push(-2); e++ < m; ) l.push(-1)
						break
					}
					case 10: {
						l.push(-4), (e = 1)
						break
					}
					default:
						;(r = !0), (e = 1)
				}
			c = h + 1
		}
		return a && (r && l.push(-5), t && l.push(t), l.push(null)), l
	}
}
const Zh = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi
function ef(e) {
	return e.replace(Zh, tf)
}
function tf(e, t, n) {
	if (t) return t
	if (n.charCodeAt(0) === 35) {
		const i = n.charCodeAt(1),
			o = i === 120 || i === 88
		return al(n.slice(o ? 2 : 1), o ? 16 : 10)
	}
	return oo(n) || e
}
const _l = {}.hasOwnProperty
function nf(e, t, n) {
	return (
		typeof t != "string" && ((n = t), (t = void 0)),
		rf(n)(
			Qh(
				Xh(n)
					.document()
					.write(Jh()(e, t, !0)),
			),
		)
	)
}
function rf(e) {
	const t = {
		transforms: [],
		canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
		enter: {
			autolink: o(vt),
			autolinkProtocol: z,
			autolinkEmail: z,
			atxHeading: o(_t),
			blockQuote: o(se),
			characterEscape: z,
			characterReference: z,
			codeFenced: o(ke),
			codeFencedFenceInfo: s,
			codeFencedFenceMeta: s,
			codeIndented: o(ke, s),
			codeText: o(be, s),
			codeTextData: z,
			data: z,
			codeFlowValue: z,
			definition: o(gt),
			definitionDestinationString: s,
			definitionLabelString: s,
			definitionTitleString: s,
			emphasis: o(Ot),
			hardBreakEscape: o(Dt),
			hardBreakTrailing: o(Dt),
			htmlFlow: o(it, s),
			htmlFlowData: z,
			htmlText: o(it, s),
			htmlTextData: z,
			image: o(at),
			label: s,
			link: o(vt),
			listItem: o(ln),
			listItemValue: h,
			listOrdered: o(Nt, c),
			listUnordered: o(Nt),
			paragraph: o(Gn),
			reference: E,
			referenceString: s,
			resourceDestinationString: s,
			resourceTitleString: s,
			setextHeading: o(_t),
			strong: o($t),
			thematicBreak: o(yt),
		},
		exit: {
			atxHeading: l(),
			atxHeadingSequence: S,
			autolink: l(),
			autolinkEmail: X,
			autolinkProtocol: V,
			blockQuote: l(),
			characterEscapeValue: v,
			characterReferenceMarkerHexadecimal: Ge,
			characterReferenceMarkerNumeric: Ge,
			characterReferenceValue: me,
			characterReference: Fe,
			codeFenced: l(x),
			codeFencedFence: y,
			codeFencedFenceInfo: p,
			codeFencedFenceMeta: f,
			codeFlowValue: v,
			codeIndented: l(d),
			codeText: l(j),
			codeTextData: v,
			data: v,
			definition: l(),
			definitionDestinationString: I,
			definitionLabelString: _,
			definitionTitleString: w,
			emphasis: l(),
			hardBreakEscape: l(M),
			hardBreakTrailing: l(M),
			htmlFlow: l(B),
			htmlFlowData: v,
			htmlText: l(C),
			htmlTextData: v,
			image: l(le),
			label: Ee,
			labelText: xe,
			lineEnding: L,
			link: l(Z),
			listItem: l(),
			listOrdered: l(),
			listUnordered: l(),
			paragraph: l(),
			referenceString: Pe,
			resourceDestinationString: k,
			resourceTitleString: pe,
			resource: Le,
			setextHeading: l(P),
			setextHeadingLineSequence: T,
			setextHeadingText: b,
			strong: l(),
			thematicBreak: l(),
		},
	}
	yl(t, (e || {}).mdastExtensions || [])
	const n = {}
	return r
	function r(A) {
		let H = { type: "root", children: [] }
		const W = { stack: [H], tokenStack: [], config: t, enter: a, exit: u, buffer: s, resume: m, data: n },
			te = []
		let ue = -1
		for (; ++ue < A.length; )
			if (A[ue][1].type === "listOrdered" || A[ue][1].type === "listUnordered")
				if (A[ue][0] === "enter") te.push(ue)
				else {
					const $e = te.pop()
					ue = i(A, $e, ue)
				}
		for (ue = -1; ++ue < A.length; ) {
			const $e = t[A[ue][0]]
			_l.call($e, A[ue][1].type) &&
				$e[A[ue][1].type].call(Object.assign({ sliceSerialize: A[ue][2].sliceSerialize }, W), A[ue][1])
		}
		if (W.tokenStack.length > 0) {
			const $e = W.tokenStack[W.tokenStack.length - 1]
			;($e[1] || fs).call(W, void 0, $e[0])
		}
		for (
			H.position = {
				start: It(A.length > 0 ? A[0][1].start : { line: 1, column: 1, offset: 0 }),
				end: It(A.length > 0 ? A[A.length - 2][1].end : { line: 1, column: 1, offset: 0 }),
			},
				ue = -1;
			++ue < t.transforms.length;

		)
			H = t.transforms[ue](H) || H
		return H
	}
	function i(A, H, W) {
		let te = H - 1,
			ue = -1,
			$e = !1,
			xt,
			bt,
			un,
			cn
		for (; ++te <= W; ) {
			const We = A[te]
			switch (We[1].type) {
				case "listUnordered":
				case "listOrdered":
				case "blockQuote": {
					We[0] === "enter" ? ue++ : ue--, (cn = void 0)
					break
				}
				case "lineEndingBlank": {
					We[0] === "enter" && (xt && !cn && !ue && !un && (un = te), (cn = void 0))
					break
				}
				case "linePrefix":
				case "listItemValue":
				case "listItemMarker":
				case "listItemPrefix":
				case "listItemPrefixWhitespace":
					break
				default:
					cn = void 0
			}
			if (
				(!ue && We[0] === "enter" && We[1].type === "listItemPrefix") ||
				(ue === -1 && We[0] === "exit" && (We[1].type === "listUnordered" || We[1].type === "listOrdered"))
			) {
				if (xt) {
					let Ut = te
					for (bt = void 0; Ut--; ) {
						const kt = A[Ut]
						if (kt[1].type === "lineEnding" || kt[1].type === "lineEndingBlank") {
							if (kt[0] === "exit") continue
							bt && ((A[bt][1].type = "lineEndingBlank"), ($e = !0)),
								(kt[1].type = "lineEnding"),
								(bt = Ut)
						} else if (
							!(
								kt[1].type === "linePrefix" ||
								kt[1].type === "blockQuotePrefix" ||
								kt[1].type === "blockQuotePrefixWhitespace" ||
								kt[1].type === "blockQuoteMarker" ||
								kt[1].type === "listItemIndent"
							)
						)
							break
					}
					un && (!bt || un < bt) && (xt._spread = !0),
						(xt.end = Object.assign({}, bt ? A[bt][1].start : We[1].end)),
						A.splice(bt || te, 0, ["exit", xt, We[2]]),
						te++,
						W++
				}
				if (We[1].type === "listItemPrefix") {
					const Ut = { type: "listItem", _spread: !1, start: Object.assign({}, We[1].start), end: void 0 }
					;(xt = Ut), A.splice(te, 0, ["enter", Ut, We[2]]), te++, W++, (un = void 0), (cn = !0)
				}
			}
		}
		return (A[H][1]._spread = $e), W
	}
	function o(A, H) {
		return W
		function W(te) {
			a.call(this, A(te), te), H && H.call(this, te)
		}
	}
	function s() {
		this.stack.push({ type: "fragment", children: [] })
	}
	function a(A, H, W) {
		this.stack[this.stack.length - 1].children.push(A),
			this.stack.push(A),
			this.tokenStack.push([H, W || void 0]),
			(A.position = { start: It(H.start), end: void 0 })
	}
	function l(A) {
		return H
		function H(W) {
			A && A.call(this, W), u.call(this, W)
		}
	}
	function u(A, H) {
		const W = this.stack.pop(),
			te = this.tokenStack.pop()
		if (te) te[0].type !== A.type && (H ? H.call(this, A, te[0]) : (te[1] || fs).call(this, A, te[0]))
		else
			throw new Error("Cannot close `" + A.type + "` (" + xn({ start: A.start, end: A.end }) + "): it’s not open")
		W.position.end = It(A.end)
	}
	function m() {
		return io(this.stack.pop())
	}
	function c() {
		this.data.expectingFirstListItemValue = !0
	}
	function h(A) {
		if (this.data.expectingFirstListItemValue) {
			const H = this.stack[this.stack.length - 2]
			;(H.start = Number.parseInt(this.sliceSerialize(A), 10)), (this.data.expectingFirstListItemValue = void 0)
		}
	}
	function p() {
		const A = this.resume(),
			H = this.stack[this.stack.length - 1]
		H.lang = A
	}
	function f() {
		const A = this.resume(),
			H = this.stack[this.stack.length - 1]
		H.meta = A
	}
	function y() {
		this.data.flowCodeInside || (this.buffer(), (this.data.flowCodeInside = !0))
	}
	function x() {
		const A = this.resume(),
			H = this.stack[this.stack.length - 1]
		;(H.value = A.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "")), (this.data.flowCodeInside = void 0)
	}
	function d() {
		const A = this.resume(),
			H = this.stack[this.stack.length - 1]
		H.value = A.replace(/(\r?\n|\r)$/g, "")
	}
	function _(A) {
		const H = this.resume(),
			W = this.stack[this.stack.length - 1]
		;(W.label = H), (W.identifier = ot(this.sliceSerialize(A)).toLowerCase())
	}
	function w() {
		const A = this.resume(),
			H = this.stack[this.stack.length - 1]
		H.title = A
	}
	function I() {
		const A = this.resume(),
			H = this.stack[this.stack.length - 1]
		H.url = A
	}
	function S(A) {
		const H = this.stack[this.stack.length - 1]
		if (!H.depth) {
			const W = this.sliceSerialize(A).length
			H.depth = W
		}
	}
	function b() {
		this.data.setextHeadingSlurpLineEnding = !0
	}
	function T(A) {
		const H = this.stack[this.stack.length - 1]
		H.depth = this.sliceSerialize(A).codePointAt(0) === 61 ? 1 : 2
	}
	function P() {
		this.data.setextHeadingSlurpLineEnding = void 0
	}
	function z(A) {
		const W = this.stack[this.stack.length - 1].children
		let te = W[W.length - 1]
		;(!te || te.type !== "text") && ((te = St()), (te.position = { start: It(A.start), end: void 0 }), W.push(te)),
			this.stack.push(te)
	}
	function v(A) {
		const H = this.stack.pop()
		;(H.value += this.sliceSerialize(A)), (H.position.end = It(A.end))
	}
	function L(A) {
		const H = this.stack[this.stack.length - 1]
		if (this.data.atHardBreak) {
			const W = H.children[H.children.length - 1]
			;(W.position.end = It(A.end)), (this.data.atHardBreak = void 0)
			return
		}
		!this.data.setextHeadingSlurpLineEnding &&
			t.canContainEols.includes(H.type) &&
			(z.call(this, A), v.call(this, A))
	}
	function M() {
		this.data.atHardBreak = !0
	}
	function B() {
		const A = this.resume(),
			H = this.stack[this.stack.length - 1]
		H.value = A
	}
	function C() {
		const A = this.resume(),
			H = this.stack[this.stack.length - 1]
		H.value = A
	}
	function j() {
		const A = this.resume(),
			H = this.stack[this.stack.length - 1]
		H.value = A
	}
	function Z() {
		const A = this.stack[this.stack.length - 1]
		if (this.data.inReference) {
			const H = this.data.referenceType || "shortcut"
			;(A.type += "Reference"), (A.referenceType = H), delete A.url, delete A.title
		} else delete A.identifier, delete A.label
		this.data.referenceType = void 0
	}
	function le() {
		const A = this.stack[this.stack.length - 1]
		if (this.data.inReference) {
			const H = this.data.referenceType || "shortcut"
			;(A.type += "Reference"), (A.referenceType = H), delete A.url, delete A.title
		} else delete A.identifier, delete A.label
		this.data.referenceType = void 0
	}
	function xe(A) {
		const H = this.sliceSerialize(A),
			W = this.stack[this.stack.length - 2]
		;(W.label = ef(H)), (W.identifier = ot(H).toLowerCase())
	}
	function Ee() {
		const A = this.stack[this.stack.length - 1],
			H = this.resume(),
			W = this.stack[this.stack.length - 1]
		if (((this.data.inReference = !0), W.type === "link")) {
			const te = A.children
			W.children = te
		} else W.alt = H
	}
	function k() {
		const A = this.resume(),
			H = this.stack[this.stack.length - 1]
		H.url = A
	}
	function pe() {
		const A = this.resume(),
			H = this.stack[this.stack.length - 1]
		H.title = A
	}
	function Le() {
		this.data.inReference = void 0
	}
	function E() {
		this.data.referenceType = "collapsed"
	}
	function Pe(A) {
		const H = this.resume(),
			W = this.stack[this.stack.length - 1]
		;(W.label = H), (W.identifier = ot(this.sliceSerialize(A)).toLowerCase()), (this.data.referenceType = "full")
	}
	function Ge(A) {
		this.data.characterReferenceType = A.type
	}
	function me(A) {
		const H = this.sliceSerialize(A),
			W = this.data.characterReferenceType
		let te
		W
			? ((te = al(H, W === "characterReferenceMarkerNumeric" ? 10 : 16)),
				(this.data.characterReferenceType = void 0))
			: (te = oo(H))
		const ue = this.stack[this.stack.length - 1]
		ue.value += te
	}
	function Fe(A) {
		const H = this.stack.pop()
		H.position.end = It(A.end)
	}
	function V(A) {
		v.call(this, A)
		const H = this.stack[this.stack.length - 1]
		H.url = this.sliceSerialize(A)
	}
	function X(A) {
		v.call(this, A)
		const H = this.stack[this.stack.length - 1]
		H.url = "mailto:" + this.sliceSerialize(A)
	}
	function se() {
		return { type: "blockquote", children: [] }
	}
	function ke() {
		return { type: "code", lang: null, meta: null, value: "" }
	}
	function be() {
		return { type: "inlineCode", value: "" }
	}
	function gt() {
		return { type: "definition", identifier: "", label: null, title: null, url: "" }
	}
	function Ot() {
		return { type: "emphasis", children: [] }
	}
	function _t() {
		return { type: "heading", depth: 0, children: [] }
	}
	function Dt() {
		return { type: "break" }
	}
	function it() {
		return { type: "html", value: "" }
	}
	function at() {
		return { type: "image", title: null, url: "", alt: null }
	}
	function vt() {
		return { type: "link", title: null, url: "", children: [] }
	}
	function Nt(A) {
		return { type: "list", ordered: A.type === "listOrdered", start: null, spread: A._spread, children: [] }
	}
	function ln(A) {
		return { type: "listItem", spread: A._spread, checked: null, children: [] }
	}
	function Gn() {
		return { type: "paragraph", children: [] }
	}
	function $t() {
		return { type: "strong", children: [] }
	}
	function St() {
		return { type: "text", value: "" }
	}
	function yt() {
		return { type: "thematicBreak" }
	}
}
function It(e) {
	return { line: e.line, column: e.column, offset: e.offset }
}
function yl(e, t) {
	let n = -1
	for (; ++n < t.length; ) {
		const r = t[n]
		Array.isArray(r) ? yl(e, r) : of(e, r)
	}
}
function of(e, t) {
	let n
	for (n in t)
		if (_l.call(t, n))
			switch (n) {
				case "canContainEols": {
					const r = t[n]
					r && e[n].push(...r)
					break
				}
				case "transforms": {
					const r = t[n]
					r && e[n].push(...r)
					break
				}
				case "enter":
				case "exit": {
					const r = t[n]
					r && Object.assign(e[n], r)
					break
				}
			}
}
function fs(e, t) {
	throw e
		? new Error(
				"Cannot close `" +
					e.type +
					"` (" +
					xn({ start: e.start, end: e.end }) +
					"): a different token (`" +
					t.type +
					"`, " +
					xn({ start: t.start, end: t.end }) +
					") is open",
			)
		: new Error(
				"Cannot close document, a token (`" +
					t.type +
					"`, " +
					xn({ start: t.start, end: t.end }) +
					") is still open",
			)
}
function sf(e) {
	const t = this
	t.parser = n
	function n(r) {
		return nf(r, {
			...t.data("settings"),
			...e,
			extensions: t.data("micromarkExtensions") || [],
			mdastExtensions: t.data("fromMarkdownExtensions") || [],
		})
	}
}
function af(e, t) {
	const n = { type: "element", tagName: "blockquote", properties: {}, children: e.wrap(e.all(t), !0) }
	return e.patch(t, n), e.applyData(t, n)
}
function lf(e, t) {
	const n = { type: "element", tagName: "br", properties: {}, children: [] }
	return (
		e.patch(t, n),
		[
			e.applyData(t, n),
			{
				type: "text",
				value: `
`,
			},
		]
	)
}
function uf(e, t) {
	const n = t.value
			? t.value +
				`
`
			: "",
		r = {}
	t.lang && (r.className = ["language-" + t.lang])
	let i = { type: "element", tagName: "code", properties: r, children: [{ type: "text", value: n }] }
	return (
		t.meta && (i.data = { meta: t.meta }),
		e.patch(t, i),
		(i = e.applyData(t, i)),
		(i = { type: "element", tagName: "pre", properties: {}, children: [i] }),
		e.patch(t, i),
		i
	)
}
function cf(e, t) {
	const n = { type: "element", tagName: "del", properties: {}, children: e.all(t) }
	return e.patch(t, n), e.applyData(t, n)
}
function mf(e, t) {
	const n = { type: "element", tagName: "em", properties: {}, children: e.all(t) }
	return e.patch(t, n), e.applyData(t, n)
}
function pf(e, t) {
	const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-",
		r = String(t.identifier).toUpperCase(),
		i = sn(r.toLowerCase()),
		o = e.footnoteOrder.indexOf(r)
	let s,
		a = e.footnoteCounts.get(r)
	a === void 0 ? ((a = 0), e.footnoteOrder.push(r), (s = e.footnoteOrder.length)) : (s = o + 1),
		(a += 1),
		e.footnoteCounts.set(r, a)
	const l = {
		type: "element",
		tagName: "a",
		properties: {
			href: "#" + n + "fn-" + i,
			id: n + "fnref-" + i + (a > 1 ? "-" + a : ""),
			dataFootnoteRef: !0,
			ariaDescribedBy: ["footnote-label"],
		},
		children: [{ type: "text", value: String(s) }],
	}
	e.patch(t, l)
	const u = { type: "element", tagName: "sup", properties: {}, children: [l] }
	return e.patch(t, u), e.applyData(t, u)
}
function hf(e, t) {
	const n = { type: "element", tagName: "h" + t.depth, properties: {}, children: e.all(t) }
	return e.patch(t, n), e.applyData(t, n)
}
function ff(e, t) {
	if (e.options.allowDangerousHtml) {
		const n = { type: "raw", value: t.value }
		return e.patch(t, n), e.applyData(t, n)
	}
}
function xl(e, t) {
	const n = t.referenceType
	let r = "]"
	if (
		(n === "collapsed" ? (r += "[]") : n === "full" && (r += "[" + (t.label || t.identifier) + "]"),
		t.type === "imageReference")
	)
		return [{ type: "text", value: "![" + t.alt + r }]
	const i = e.all(t),
		o = i[0]
	o && o.type === "text" ? (o.value = "[" + o.value) : i.unshift({ type: "text", value: "[" })
	const s = i[i.length - 1]
	return s && s.type === "text" ? (s.value += r) : i.push({ type: "text", value: r }), i
}
function df(e, t) {
	const n = String(t.identifier).toUpperCase(),
		r = e.definitionById.get(n)
	if (!r) return xl(e, t)
	const i = { src: sn(r.url || ""), alt: t.alt }
	r.title !== null && r.title !== void 0 && (i.title = r.title)
	const o = { type: "element", tagName: "img", properties: i, children: [] }
	return e.patch(t, o), e.applyData(t, o)
}
function gf(e, t) {
	const n = { src: sn(t.url) }
	t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title)
	const r = { type: "element", tagName: "img", properties: n, children: [] }
	return e.patch(t, r), e.applyData(t, r)
}
function _f(e, t) {
	const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") }
	e.patch(t, n)
	const r = { type: "element", tagName: "code", properties: {}, children: [n] }
	return e.patch(t, r), e.applyData(t, r)
}
function yf(e, t) {
	const n = String(t.identifier).toUpperCase(),
		r = e.definitionById.get(n)
	if (!r) return xl(e, t)
	const i = { href: sn(r.url || "") }
	r.title !== null && r.title !== void 0 && (i.title = r.title)
	const o = { type: "element", tagName: "a", properties: i, children: e.all(t) }
	return e.patch(t, o), e.applyData(t, o)
}
function xf(e, t) {
	const n = { href: sn(t.url) }
	t.title !== null && t.title !== void 0 && (n.title = t.title)
	const r = { type: "element", tagName: "a", properties: n, children: e.all(t) }
	return e.patch(t, r), e.applyData(t, r)
}
function bf(e, t, n) {
	const r = e.all(t),
		i = n ? kf(n) : bl(t),
		o = {},
		s = []
	if (typeof t.checked == "boolean") {
		const m = r[0]
		let c
		m && m.type === "element" && m.tagName === "p"
			? (c = m)
			: ((c = { type: "element", tagName: "p", properties: {}, children: [] }), r.unshift(c)),
			c.children.length > 0 && c.children.unshift({ type: "text", value: " " }),
			c.children.unshift({
				type: "element",
				tagName: "input",
				properties: { type: "checkbox", checked: t.checked, disabled: !0 },
				children: [],
			}),
			(o.className = ["task-list-item"])
	}
	let a = -1
	for (; ++a < r.length; ) {
		const m = r[a]
		;(i || a !== 0 || m.type !== "element" || m.tagName !== "p") &&
			s.push({
				type: "text",
				value: `
`,
			}),
			m.type === "element" && m.tagName === "p" && !i ? s.push(...m.children) : s.push(m)
	}
	const l = r[r.length - 1]
	l &&
		(i || l.type !== "element" || l.tagName !== "p") &&
		s.push({
			type: "text",
			value: `
`,
		})
	const u = { type: "element", tagName: "li", properties: o, children: s }
	return e.patch(t, u), e.applyData(t, u)
}
function kf(e) {
	let t = !1
	if (e.type === "list") {
		t = e.spread || !1
		const n = e.children
		let r = -1
		for (; !t && ++r < n.length; ) t = bl(n[r])
	}
	return t
}
function bl(e) {
	const t = e.spread
	return t ?? e.children.length > 1
}
function wf(e, t) {
	const n = {},
		r = e.all(t)
	let i = -1
	for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
		const s = r[i]
		if (
			s.type === "element" &&
			s.tagName === "li" &&
			s.properties &&
			Array.isArray(s.properties.className) &&
			s.properties.className.includes("task-list-item")
		) {
			n.className = ["contains-task-list"]
			break
		}
	}
	const o = { type: "element", tagName: t.ordered ? "ol" : "ul", properties: n, children: e.wrap(r, !0) }
	return e.patch(t, o), e.applyData(t, o)
}
function Ef(e, t) {
	const n = { type: "element", tagName: "p", properties: {}, children: e.all(t) }
	return e.patch(t, n), e.applyData(t, n)
}
function vf(e, t) {
	const n = { type: "root", children: e.wrap(e.all(t)) }
	return e.patch(t, n), e.applyData(t, n)
}
function Sf(e, t) {
	const n = { type: "element", tagName: "strong", properties: {}, children: e.all(t) }
	return e.patch(t, n), e.applyData(t, n)
}
function If(e, t) {
	const n = e.all(t),
		r = n.shift(),
		i = []
	if (r) {
		const s = { type: "element", tagName: "thead", properties: {}, children: e.wrap([r], !0) }
		e.patch(t.children[0], s), i.push(s)
	}
	if (n.length > 0) {
		const s = { type: "element", tagName: "tbody", properties: {}, children: e.wrap(n, !0) },
			a = eo(t.children[1]),
			l = Za(t.children[t.children.length - 1])
		a && l && (s.position = { start: a, end: l }), i.push(s)
	}
	const o = { type: "element", tagName: "table", properties: {}, children: e.wrap(i, !0) }
	return e.patch(t, o), e.applyData(t, o)
}
function Tf(e, t, n) {
	const r = n ? n.children : void 0,
		o = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td",
		s = n && n.type === "table" ? n.align : void 0,
		a = s ? s.length : t.children.length
	let l = -1
	const u = []
	for (; ++l < a; ) {
		const c = t.children[l],
			h = {},
			p = s ? s[l] : void 0
		p && (h.align = p)
		let f = { type: "element", tagName: o, properties: h, children: [] }
		c && ((f.children = e.all(c)), e.patch(c, f), (f = e.applyData(c, f))), u.push(f)
	}
	const m = { type: "element", tagName: "tr", properties: {}, children: e.wrap(u, !0) }
	return e.patch(t, m), e.applyData(t, m)
}
function Cf(e, t) {
	const n = { type: "element", tagName: "td", properties: {}, children: e.all(t) }
	return e.patch(t, n), e.applyData(t, n)
}
const ds = 9,
	gs = 32
function Af(e) {
	const t = String(e),
		n = /\r?\n|\r/g
	let r = n.exec(t),
		i = 0
	const o = []
	for (; r; ) o.push(_s(t.slice(i, r.index), i > 0, !0), r[0]), (i = r.index + r[0].length), (r = n.exec(t))
	return o.push(_s(t.slice(i), i > 0, !1)), o.join("")
}
function _s(e, t, n) {
	let r = 0,
		i = e.length
	if (t) {
		let o = e.codePointAt(r)
		for (; o === ds || o === gs; ) r++, (o = e.codePointAt(r))
	}
	if (n) {
		let o = e.codePointAt(i - 1)
		for (; o === ds || o === gs; ) i--, (o = e.codePointAt(i - 1))
	}
	return i > r ? e.slice(r, i) : ""
}
function Rf(e, t) {
	const n = { type: "text", value: Af(String(t.value)) }
	return e.patch(t, n), e.applyData(t, n)
}
function Lf(e, t) {
	const n = { type: "element", tagName: "hr", properties: {}, children: [] }
	return e.patch(t, n), e.applyData(t, n)
}
const Pf = {
	blockquote: af,
	break: lf,
	code: uf,
	delete: cf,
	emphasis: mf,
	footnoteReference: pf,
	heading: hf,
	html: ff,
	imageReference: df,
	image: gf,
	inlineCode: _f,
	linkReference: yf,
	link: xf,
	listItem: bf,
	list: wf,
	paragraph: Ef,
	root: vf,
	strong: Sf,
	table: If,
	tableCell: Cf,
	tableRow: Tf,
	text: Rf,
	thematicBreak: Lf,
	toml: qn,
	yaml: qn,
	definition: qn,
	footnoteDefinition: qn,
}
function qn() {}
const kl = -1,
	Nr = 0,
	kn = 1,
	mr = 2,
	ao = 3,
	lo = 4,
	uo = 5,
	co = 6,
	wl = 7,
	El = 8,
	ys = typeof self == "object" ? self : globalThis,
	Of = (e, t) => {
		const n = (i, o) => (e.set(o, i), i),
			r = (i) => {
				if (e.has(i)) return e.get(i)
				const [o, s] = t[i]
				switch (o) {
					case Nr:
					case kl:
						return n(s, i)
					case kn: {
						const a = n([], i)
						for (const l of s) a.push(r(l))
						return a
					}
					case mr: {
						const a = n({}, i)
						for (const [l, u] of s) a[r(l)] = r(u)
						return a
					}
					case ao:
						return n(new Date(s), i)
					case lo: {
						const { source: a, flags: l } = s
						return n(new RegExp(a, l), i)
					}
					case uo: {
						const a = n(new Map(), i)
						for (const [l, u] of s) a.set(r(l), r(u))
						return a
					}
					case co: {
						const a = n(new Set(), i)
						for (const l of s) a.add(r(l))
						return a
					}
					case wl: {
						const { name: a, message: l } = s
						return n(new ys[a](l), i)
					}
					case El:
						return n(BigInt(s), i)
					case "BigInt":
						return n(Object(BigInt(s)), i)
					case "ArrayBuffer":
						return n(new Uint8Array(s).buffer, s)
					case "DataView": {
						const { buffer: a } = new Uint8Array(s)
						return n(new DataView(a), s)
					}
				}
				return n(new ys[o](s), i)
			}
		return r
	},
	xs = (e) => Of(new Map(), e)(0),
	Wt = "",
	{ toString: Df } = {},
	{ keys: Nf } = Object,
	fn = (e) => {
		const t = typeof e
		if (t !== "object" || !e) return [Nr, t]
		const n = Df.call(e).slice(8, -1)
		switch (n) {
			case "Array":
				return [kn, Wt]
			case "Object":
				return [mr, Wt]
			case "Date":
				return [ao, Wt]
			case "RegExp":
				return [lo, Wt]
			case "Map":
				return [uo, Wt]
			case "Set":
				return [co, Wt]
			case "DataView":
				return [kn, n]
		}
		return n.includes("Array") ? [kn, n] : n.includes("Error") ? [wl, n] : [mr, n]
	},
	Wn = ([e, t]) => e === Nr && (t === "function" || t === "symbol"),
	Mf = (e, t, n, r) => {
		const i = (s, a) => {
				const l = r.push(s) - 1
				return n.set(a, l), l
			},
			o = (s) => {
				if (n.has(s)) return n.get(s)
				let [a, l] = fn(s)
				switch (a) {
					case Nr: {
						let m = s
						switch (l) {
							case "bigint":
								;(a = El), (m = s.toString())
								break
							case "function":
							case "symbol":
								if (e) throw new TypeError("unable to serialize " + l)
								m = null
								break
							case "undefined":
								return i([kl], s)
						}
						return i([a, m], s)
					}
					case kn: {
						if (l) {
							let h = s
							return (
								l === "DataView"
									? (h = new Uint8Array(s.buffer))
									: l === "ArrayBuffer" && (h = new Uint8Array(s)),
								i([l, [...h]], s)
							)
						}
						const m = [],
							c = i([a, m], s)
						for (const h of s) m.push(o(h))
						return c
					}
					case mr: {
						if (l)
							switch (l) {
								case "BigInt":
									return i([l, s.toString()], s)
								case "Boolean":
								case "Number":
								case "String":
									return i([l, s.valueOf()], s)
							}
						if (t && "toJSON" in s) return o(s.toJSON())
						const m = [],
							c = i([a, m], s)
						for (const h of Nf(s)) (e || !Wn(fn(s[h]))) && m.push([o(h), o(s[h])])
						return c
					}
					case ao:
						return i([a, s.toISOString()], s)
					case lo: {
						const { source: m, flags: c } = s
						return i([a, { source: m, flags: c }], s)
					}
					case uo: {
						const m = [],
							c = i([a, m], s)
						for (const [h, p] of s) (e || !(Wn(fn(h)) || Wn(fn(p)))) && m.push([o(h), o(p)])
						return c
					}
					case co: {
						const m = [],
							c = i([a, m], s)
						for (const h of s) (e || !Wn(fn(h))) && m.push(o(h))
						return c
					}
				}
				const { message: u } = s
				return i([a, { name: l, message: u }], s)
			}
		return o
	},
	bs = (e, { json: t, lossy: n } = {}) => {
		const r = []
		return Mf(!(t || n), !!t, new Map(), r)(e), r
	},
	pr =
		typeof structuredClone == "function"
			? (e, t) => (t && ("json" in t || "lossy" in t) ? xs(bs(e, t)) : structuredClone(e))
			: (e, t) => xs(bs(e, t))
function zf(e, t) {
	const n = [{ type: "text", value: "↩" }]
	return (
		t > 1 &&
			n.push({ type: "element", tagName: "sup", properties: {}, children: [{ type: "text", value: String(t) }] }),
		n
	)
}
function Vf(e, t) {
	return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "")
}
function Bf(e) {
	const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-",
		n = e.options.footnoteBackContent || zf,
		r = e.options.footnoteBackLabel || Vf,
		i = e.options.footnoteLabel || "Footnotes",
		o = e.options.footnoteLabelTagName || "h2",
		s = e.options.footnoteLabelProperties || { className: ["sr-only"] },
		a = []
	let l = -1
	for (; ++l < e.footnoteOrder.length; ) {
		const u = e.footnoteById.get(e.footnoteOrder[l])
		if (!u) continue
		const m = e.all(u),
			c = String(u.identifier).toUpperCase(),
			h = sn(c.toLowerCase())
		let p = 0
		const f = [],
			y = e.footnoteCounts.get(c)
		for (; y !== void 0 && ++p <= y; ) {
			f.length > 0 && f.push({ type: "text", value: " " })
			let _ = typeof n == "string" ? n : n(l, p)
			typeof _ == "string" && (_ = { type: "text", value: _ }),
				f.push({
					type: "element",
					tagName: "a",
					properties: {
						href: "#" + t + "fnref-" + h + (p > 1 ? "-" + p : ""),
						dataFootnoteBackref: "",
						ariaLabel: typeof r == "string" ? r : r(l, p),
						className: ["data-footnote-backref"],
					},
					children: Array.isArray(_) ? _ : [_],
				})
		}
		const x = m[m.length - 1]
		if (x && x.type === "element" && x.tagName === "p") {
			const _ = x.children[x.children.length - 1]
			_ && _.type === "text" ? (_.value += " ") : x.children.push({ type: "text", value: " " }),
				x.children.push(...f)
		} else m.push(...f)
		const d = { type: "element", tagName: "li", properties: { id: t + "fn-" + h }, children: e.wrap(m, !0) }
		e.patch(u, d), a.push(d)
	}
	if (a.length !== 0)
		return {
			type: "element",
			tagName: "section",
			properties: { dataFootnotes: !0, className: ["footnotes"] },
			children: [
				{
					type: "element",
					tagName: o,
					properties: { ...pr(s), id: "footnote-label" },
					children: [{ type: "text", value: i }],
				},
				{
					type: "text",
					value: `
`,
				},
				{ type: "element", tagName: "ol", properties: {}, children: e.wrap(a, !0) },
				{
					type: "text",
					value: `
`,
				},
			],
		}
}
const Mr = function (e) {
	if (e == null) return Gf
	if (typeof e == "function") return zr(e)
	if (typeof e == "object") return Array.isArray(e) ? Ff(e) : jf(e)
	if (typeof e == "string") return Hf(e)
	throw new Error("Expected function, string, or object as test")
}
function Ff(e) {
	const t = []
	let n = -1
	for (; ++n < e.length; ) t[n] = Mr(e[n])
	return zr(r)
	function r(...i) {
		let o = -1
		for (; ++o < t.length; ) if (t[o].apply(this, i)) return !0
		return !1
	}
}
function jf(e) {
	const t = e
	return zr(n)
	function n(r) {
		const i = r
		let o
		for (o in e) if (i[o] !== t[o]) return !1
		return !0
	}
}
function Hf(e) {
	return zr(t)
	function t(n) {
		return n && n.type === e
	}
}
function zr(e) {
	return t
	function t(n, r, i) {
		return !!($f(n) && e.call(this, n, typeof r == "number" ? r : void 0, i || void 0))
	}
}
function Gf() {
	return !0
}
function $f(e) {
	return e !== null && typeof e == "object" && "type" in e
}
const vl = [],
	Uf = !0,
	Ai = !1,
	qf = "skip"
function Sl(e, t, n, r) {
	let i
	typeof t == "function" && typeof n != "function" ? ((r = n), (n = t)) : (i = t)
	const o = Mr(i),
		s = r ? -1 : 1
	a(e, void 0, [])()
	function a(l, u, m) {
		const c = l && typeof l == "object" ? l : {}
		if (typeof c.type == "string") {
			const p = typeof c.tagName == "string" ? c.tagName : typeof c.name == "string" ? c.name : void 0
			Object.defineProperty(h, "name", { value: "node (" + (l.type + (p ? "<" + p + ">" : "")) + ")" })
		}
		return h
		function h() {
			let p = vl,
				f,
				y,
				x
			if ((!t || o(l, u, m[m.length - 1] || void 0)) && ((p = Wf(n(l, m))), p[0] === Ai)) return p
			if ("children" in l && l.children) {
				const d = l
				if (d.children && p[0] !== qf)
					for (y = (r ? d.children.length : -1) + s, x = m.concat(d); y > -1 && y < d.children.length; ) {
						const _ = d.children[y]
						if (((f = a(_, y, x)()), f[0] === Ai)) return f
						y = typeof f[1] == "number" ? f[1] : y + s
					}
			}
			return p
		}
	}
}
function Wf(e) {
	return Array.isArray(e) ? e : typeof e == "number" ? [Uf, e] : e == null ? vl : [e]
}
function mo(e, t, n, r) {
	let i, o, s
	typeof t == "function" ? ((o = void 0), (s = t), (i = n)) : ((o = t), (s = n), (i = r)), Sl(e, o, a, i)
	function a(l, u) {
		const m = u[u.length - 1],
			c = m ? m.children.indexOf(l) : void 0
		return s(l, c, m)
	}
}
const Ri = {}.hasOwnProperty,
	Kf = {}
function Yf(e, t) {
	const n = t || Kf,
		r = new Map(),
		i = new Map(),
		o = new Map(),
		s = { ...Pf, ...n.handlers },
		a = {
			all: u,
			applyData: Qf,
			definitionById: r,
			footnoteById: i,
			footnoteCounts: o,
			footnoteOrder: [],
			handlers: s,
			one: l,
			options: n,
			patch: Xf,
			wrap: Zf,
		}
	return (
		mo(e, function (m) {
			if (m.type === "definition" || m.type === "footnoteDefinition") {
				const c = m.type === "definition" ? r : i,
					h = String(m.identifier).toUpperCase()
				c.has(h) || c.set(h, m)
			}
		}),
		a
	)
	function l(m, c) {
		const h = m.type,
			p = a.handlers[h]
		if (Ri.call(a.handlers, h) && p) return p(a, m, c)
		if (a.options.passThrough && a.options.passThrough.includes(h)) {
			if ("children" in m) {
				const { children: y, ...x } = m,
					d = pr(x)
				return (d.children = a.all(m)), d
			}
			return pr(m)
		}
		return (a.options.unknownHandler || Jf)(a, m, c)
	}
	function u(m) {
		const c = []
		if ("children" in m) {
			const h = m.children
			let p = -1
			for (; ++p < h.length; ) {
				const f = a.one(h[p], m)
				if (f) {
					if (
						p &&
						h[p - 1].type === "break" &&
						(!Array.isArray(f) && f.type === "text" && (f.value = ks(f.value)),
						!Array.isArray(f) && f.type === "element")
					) {
						const y = f.children[0]
						y && y.type === "text" && (y.value = ks(y.value))
					}
					Array.isArray(f) ? c.push(...f) : c.push(f)
				}
			}
		}
		return c
	}
}
function Xf(e, t) {
	e.position && (t.position = zm(e))
}
function Qf(e, t) {
	let n = t
	if (e && e.data) {
		const r = e.data.hName,
			i = e.data.hChildren,
			o = e.data.hProperties
		if (typeof r == "string")
			if (n.type === "element") n.tagName = r
			else {
				const s = "children" in n ? n.children : [n]
				n = { type: "element", tagName: r, properties: {}, children: s }
			}
		n.type === "element" && o && Object.assign(n.properties, pr(o)),
			"children" in n && n.children && i !== null && i !== void 0 && (n.children = i)
	}
	return n
}
function Jf(e, t) {
	const n = t.data || {},
		r =
			"value" in t && !(Ri.call(n, "hProperties") || Ri.call(n, "hChildren"))
				? { type: "text", value: t.value }
				: { type: "element", tagName: "div", properties: {}, children: e.all(t) }
	return e.patch(t, r), e.applyData(t, r)
}
function Zf(e, t) {
	const n = []
	let r = -1
	for (
		t &&
		n.push({
			type: "text",
			value: `
`,
		});
		++r < e.length;

	)
		r &&
			n.push({
				type: "text",
				value: `
`,
			}),
			n.push(e[r])
	return (
		t &&
			e.length > 0 &&
			n.push({
				type: "text",
				value: `
`,
			}),
		n
	)
}
function ks(e) {
	let t = 0,
		n = e.charCodeAt(t)
	for (; n === 9 || n === 32; ) t++, (n = e.charCodeAt(t))
	return e.slice(t)
}
function ws(e, t) {
	const n = Yf(e, t),
		r = n.one(e, void 0),
		i = Bf(n),
		o = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] }
	return (
		i &&
			o.children.push(
				{
					type: "text",
					value: `
`,
				},
				i,
			),
		o
	)
}
function ed(e, t) {
	return e && "run" in e
		? async function (n, r) {
				const i = ws(n, { file: r, ...t })
				await e.run(i, r)
			}
		: function (n, r) {
				return ws(n, { file: r, ...(e || t) })
			}
}
function Es(e) {
	if (e) throw e
}
var Jr, vs
function td() {
	if (vs) return Jr
	vs = 1
	var e = Object.prototype.hasOwnProperty,
		t = Object.prototype.toString,
		n = Object.defineProperty,
		r = Object.getOwnPropertyDescriptor,
		i = function (u) {
			return typeof Array.isArray == "function" ? Array.isArray(u) : t.call(u) === "[object Array]"
		},
		o = function (u) {
			if (!u || t.call(u) !== "[object Object]") return !1
			var m = e.call(u, "constructor"),
				c = u.constructor && u.constructor.prototype && e.call(u.constructor.prototype, "isPrototypeOf")
			if (u.constructor && !m && !c) return !1
			var h
			for (h in u);
			return typeof h > "u" || e.call(u, h)
		},
		s = function (u, m) {
			n && m.name === "__proto__"
				? n(u, m.name, { enumerable: !0, configurable: !0, value: m.newValue, writable: !0 })
				: (u[m.name] = m.newValue)
		},
		a = function (u, m) {
			if (m === "__proto__")
				if (e.call(u, m)) {
					if (r) return r(u, m).value
				} else return
			return u[m]
		}
	return (
		(Jr = function l() {
			var u,
				m,
				c,
				h,
				p,
				f,
				y = arguments[0],
				x = 1,
				d = arguments.length,
				_ = !1
			for (
				typeof y == "boolean" && ((_ = y), (y = arguments[1] || {}), (x = 2)),
					(y == null || (typeof y != "object" && typeof y != "function")) && (y = {});
				x < d;
				++x
			)
				if (((u = arguments[x]), u != null))
					for (m in u)
						(c = a(y, m)),
							(h = a(u, m)),
							y !== h &&
								(_ && h && (o(h) || (p = i(h)))
									? (p ? ((p = !1), (f = c && i(c) ? c : [])) : (f = c && o(c) ? c : {}),
										s(y, { name: m, newValue: l(_, f, h) }))
									: typeof h < "u" && s(y, { name: m, newValue: h }))
			return y
		}),
		Jr
	)
}
var nd = td()
const Zr = ra(nd)
function Li(e) {
	if (typeof e != "object" || e === null) return !1
	const t = Object.getPrototypeOf(e)
	return (
		(t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) &&
		!(Symbol.toStringTag in e) &&
		!(Symbol.iterator in e)
	)
}
function rd() {
	const e = [],
		t = { run: n, use: r }
	return t
	function n(...i) {
		let o = -1
		const s = i.pop()
		if (typeof s != "function") throw new TypeError("Expected function as last argument, not " + s)
		a(null, ...i)
		function a(l, ...u) {
			const m = e[++o]
			let c = -1
			if (l) {
				s(l)
				return
			}
			for (; ++c < i.length; ) (u[c] === null || u[c] === void 0) && (u[c] = i[c])
			;(i = u), m ? id(m, a)(...u) : s(null, ...u)
		}
	}
	function r(i) {
		if (typeof i != "function") throw new TypeError("Expected `middelware` to be a function, not " + i)
		return e.push(i), t
	}
}
function id(e, t) {
	let n
	return r
	function r(...s) {
		const a = e.length > s.length
		let l
		a && s.push(i)
		try {
			l = e.apply(this, s)
		} catch (u) {
			const m = u
			if (a && n) throw m
			return i(m)
		}
		a || (l && l.then && typeof l.then == "function" ? l.then(o, i) : l instanceof Error ? i(l) : o(l))
	}
	function i(s, ...a) {
		n || ((n = !0), t(s, ...a))
	}
	function o(s) {
		i(null, s)
	}
}
const ct = { basename: od, dirname: sd, extname: ad, join: ld, sep: "/" }
function od(e, t) {
	if (t !== void 0 && typeof t != "string") throw new TypeError('"ext" argument must be a string')
	jn(e)
	let n = 0,
		r = -1,
		i = e.length,
		o
	if (t === void 0 || t.length === 0 || t.length > e.length) {
		for (; i--; )
			if (e.codePointAt(i) === 47) {
				if (o) {
					n = i + 1
					break
				}
			} else r < 0 && ((o = !0), (r = i + 1))
		return r < 0 ? "" : e.slice(n, r)
	}
	if (t === e) return ""
	let s = -1,
		a = t.length - 1
	for (; i--; )
		if (e.codePointAt(i) === 47) {
			if (o) {
				n = i + 1
				break
			}
		} else
			s < 0 && ((o = !0), (s = i + 1)),
				a > -1 && (e.codePointAt(i) === t.codePointAt(a--) ? a < 0 && (r = i) : ((a = -1), (r = s)))
	return n === r ? (r = s) : r < 0 && (r = e.length), e.slice(n, r)
}
function sd(e) {
	if ((jn(e), e.length === 0)) return "."
	let t = -1,
		n = e.length,
		r
	for (; --n; )
		if (e.codePointAt(n) === 47) {
			if (r) {
				t = n
				break
			}
		} else r || (r = !0)
	return t < 0 ? (e.codePointAt(0) === 47 ? "/" : ".") : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t)
}
function ad(e) {
	jn(e)
	let t = e.length,
		n = -1,
		r = 0,
		i = -1,
		o = 0,
		s
	for (; t--; ) {
		const a = e.codePointAt(t)
		if (a === 47) {
			if (s) {
				r = t + 1
				break
			}
			continue
		}
		n < 0 && ((s = !0), (n = t + 1)), a === 46 ? (i < 0 ? (i = t) : o !== 1 && (o = 1)) : i > -1 && (o = -1)
	}
	return i < 0 || n < 0 || o === 0 || (o === 1 && i === n - 1 && i === r + 1) ? "" : e.slice(i, n)
}
function ld(...e) {
	let t = -1,
		n
	for (; ++t < e.length; ) jn(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t])
	return n === void 0 ? "." : ud(n)
}
function ud(e) {
	jn(e)
	const t = e.codePointAt(0) === 47
	let n = cd(e, !t)
	return (
		n.length === 0 && !t && (n = "."),
		n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"),
		t ? "/" + n : n
	)
}
function cd(e, t) {
	let n = "",
		r = 0,
		i = -1,
		o = 0,
		s = -1,
		a,
		l
	for (; ++s <= e.length; ) {
		if (s < e.length) a = e.codePointAt(s)
		else {
			if (a === 47) break
			a = 47
		}
		if (a === 47) {
			if (!(i === s - 1 || o === 1))
				if (i !== s - 1 && o === 2) {
					if (
						n.length < 2 ||
						r !== 2 ||
						n.codePointAt(n.length - 1) !== 46 ||
						n.codePointAt(n.length - 2) !== 46
					) {
						if (n.length > 2) {
							if (((l = n.lastIndexOf("/")), l !== n.length - 1)) {
								l < 0
									? ((n = ""), (r = 0))
									: ((n = n.slice(0, l)), (r = n.length - 1 - n.lastIndexOf("/"))),
									(i = s),
									(o = 0)
								continue
							}
						} else if (n.length > 0) {
							;(n = ""), (r = 0), (i = s), (o = 0)
							continue
						}
					}
					t && ((n = n.length > 0 ? n + "/.." : ".."), (r = 2))
				} else n.length > 0 ? (n += "/" + e.slice(i + 1, s)) : (n = e.slice(i + 1, s)), (r = s - i - 1)
			;(i = s), (o = 0)
		} else a === 46 && o > -1 ? o++ : (o = -1)
	}
	return n
}
function jn(e) {
	if (typeof e != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(e))
}
const md = { cwd: pd }
function pd() {
	return "/"
}
function Pi(e) {
	return !!(
		e !== null &&
		typeof e == "object" &&
		"href" in e &&
		e.href &&
		"protocol" in e &&
		e.protocol &&
		e.auth === void 0
	)
}
function hd(e) {
	if (typeof e == "string") e = new URL(e)
	else if (!Pi(e)) {
		const t = new TypeError(
			'The "path" argument must be of type string or an instance of URL. Received `' + e + "`",
		)
		throw ((t.code = "ERR_INVALID_ARG_TYPE"), t)
	}
	if (e.protocol !== "file:") {
		const t = new TypeError("The URL must be of scheme file")
		throw ((t.code = "ERR_INVALID_URL_SCHEME"), t)
	}
	return fd(e)
}
function fd(e) {
	if (e.hostname !== "") {
		const r = new TypeError('File URL host must be "localhost" or empty on darwin')
		throw ((r.code = "ERR_INVALID_FILE_URL_HOST"), r)
	}
	const t = e.pathname
	let n = -1
	for (; ++n < t.length; )
		if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
			const r = t.codePointAt(n + 2)
			if (r === 70 || r === 102) {
				const i = new TypeError("File URL path must not include encoded / characters")
				throw ((i.code = "ERR_INVALID_FILE_URL_PATH"), i)
			}
		}
	return decodeURIComponent(t)
}
const ei = ["history", "path", "basename", "stem", "extname", "dirname"]
class Il {
	constructor(t) {
		let n
		t ? (Pi(t) ? (n = { path: t }) : typeof t == "string" || dd(t) ? (n = { value: t }) : (n = t)) : (n = {}),
			(this.cwd = "cwd" in n ? "" : md.cwd()),
			(this.data = {}),
			(this.history = []),
			(this.messages = []),
			this.value,
			this.map,
			this.result,
			this.stored
		let r = -1
		for (; ++r < ei.length; ) {
			const o = ei[r]
			o in n && n[o] !== void 0 && n[o] !== null && (this[o] = o === "history" ? [...n[o]] : n[o])
		}
		let i
		for (i in n) ei.includes(i) || (this[i] = n[i])
	}
	get basename() {
		return typeof this.path == "string" ? ct.basename(this.path) : void 0
	}
	set basename(t) {
		ni(t, "basename"), ti(t, "basename"), (this.path = ct.join(this.dirname || "", t))
	}
	get dirname() {
		return typeof this.path == "string" ? ct.dirname(this.path) : void 0
	}
	set dirname(t) {
		Ss(this.basename, "dirname"), (this.path = ct.join(t || "", this.basename))
	}
	get extname() {
		return typeof this.path == "string" ? ct.extname(this.path) : void 0
	}
	set extname(t) {
		if ((ti(t, "extname"), Ss(this.dirname, "extname"), t)) {
			if (t.codePointAt(0) !== 46) throw new Error("`extname` must start with `.`")
			if (t.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots")
		}
		this.path = ct.join(this.dirname, this.stem + (t || ""))
	}
	get path() {
		return this.history[this.history.length - 1]
	}
	set path(t) {
		Pi(t) && (t = hd(t)), ni(t, "path"), this.path !== t && this.history.push(t)
	}
	get stem() {
		return typeof this.path == "string" ? ct.basename(this.path, this.extname) : void 0
	}
	set stem(t) {
		ni(t, "stem"), ti(t, "stem"), (this.path = ct.join(this.dirname || "", t + (this.extname || "")))
	}
	fail(t, n, r) {
		const i = this.message(t, n, r)
		throw ((i.fatal = !0), i)
	}
	info(t, n, r) {
		const i = this.message(t, n, r)
		return (i.fatal = void 0), i
	}
	message(t, n, r) {
		const i = new Be(t, n, r)
		return (
			this.path && ((i.name = this.path + ":" + i.name), (i.file = this.path)),
			(i.fatal = !1),
			this.messages.push(i),
			i
		)
	}
	toString(t) {
		return this.value === void 0
			? ""
			: typeof this.value == "string"
				? this.value
				: new TextDecoder(t || void 0).decode(this.value)
	}
}
function ti(e, t) {
	if (e && e.includes(ct.sep)) throw new Error("`" + t + "` cannot be a path: did not expect `" + ct.sep + "`")
}
function ni(e, t) {
	if (!e) throw new Error("`" + t + "` cannot be empty")
}
function Ss(e, t) {
	if (!e) throw new Error("Setting `" + t + "` requires `path` to be set too")
}
function dd(e) {
	return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e)
}
const gd = function (e) {
		const r = this.constructor.prototype,
			i = r[e],
			o = function () {
				return i.apply(o, arguments)
			}
		return Object.setPrototypeOf(o, r), o
	},
	_d = {}.hasOwnProperty
class po extends gd {
	constructor() {
		super("copy"),
			(this.Compiler = void 0),
			(this.Parser = void 0),
			(this.attachers = []),
			(this.compiler = void 0),
			(this.freezeIndex = -1),
			(this.frozen = void 0),
			(this.namespace = {}),
			(this.parser = void 0),
			(this.transformers = rd())
	}
	copy() {
		const t = new po()
		let n = -1
		for (; ++n < this.attachers.length; ) {
			const r = this.attachers[n]
			t.use(...r)
		}
		return t.data(Zr(!0, {}, this.namespace)), t
	}
	data(t, n) {
		return typeof t == "string"
			? arguments.length === 2
				? (oi("data", this.frozen), (this.namespace[t] = n), this)
				: (_d.call(this.namespace, t) && this.namespace[t]) || void 0
			: t
				? (oi("data", this.frozen), (this.namespace = t), this)
				: this.namespace
	}
	freeze() {
		if (this.frozen) return this
		const t = this
		for (; ++this.freezeIndex < this.attachers.length; ) {
			const [n, ...r] = this.attachers[this.freezeIndex]
			if (r[0] === !1) continue
			r[0] === !0 && (r[0] = void 0)
			const i = n.call(t, ...r)
			typeof i == "function" && this.transformers.use(i)
		}
		return (this.frozen = !0), (this.freezeIndex = Number.POSITIVE_INFINITY), this
	}
	parse(t) {
		this.freeze()
		const n = Kn(t),
			r = this.parser || this.Parser
		return ri("parse", r), r(String(n), n)
	}
	process(t, n) {
		const r = this
		return (
			this.freeze(),
			ri("process", this.parser || this.Parser),
			ii("process", this.compiler || this.Compiler),
			n ? i(void 0, n) : new Promise(i)
		)
		function i(o, s) {
			const a = Kn(t),
				l = r.parse(a)
			r.run(l, a, function (m, c, h) {
				if (m || !c || !h) return u(m)
				const p = c,
					f = r.stringify(p, h)
				bd(f) ? (h.value = f) : (h.result = f), u(m, h)
			})
			function u(m, c) {
				m || !c ? s(m) : o ? o(c) : n(void 0, c)
			}
		}
	}
	processSync(t) {
		let n = !1,
			r
		return (
			this.freeze(),
			ri("processSync", this.parser || this.Parser),
			ii("processSync", this.compiler || this.Compiler),
			this.process(t, i),
			Ts("processSync", "process", n),
			r
		)
		function i(o, s) {
			;(n = !0), Es(o), (r = s)
		}
	}
	run(t, n, r) {
		Is(t), this.freeze()
		const i = this.transformers
		return !r && typeof n == "function" && ((r = n), (n = void 0)), r ? o(void 0, r) : new Promise(o)
		function o(s, a) {
			const l = Kn(n)
			i.run(t, l, u)
			function u(m, c, h) {
				const p = c || t
				m ? a(m) : s ? s(p) : r(void 0, p, h)
			}
		}
	}
	runSync(t, n) {
		let r = !1,
			i
		return this.run(t, n, o), Ts("runSync", "run", r), i
		function o(s, a) {
			Es(s), (i = a), (r = !0)
		}
	}
	stringify(t, n) {
		this.freeze()
		const r = Kn(n),
			i = this.compiler || this.Compiler
		return ii("stringify", i), Is(t), i(t, r)
	}
	use(t, ...n) {
		const r = this.attachers,
			i = this.namespace
		if ((oi("use", this.frozen), t != null))
			if (typeof t == "function") l(t, n)
			else if (typeof t == "object") Array.isArray(t) ? a(t) : s(t)
			else throw new TypeError("Expected usable value, not `" + t + "`")
		return this
		function o(u) {
			if (typeof u == "function") l(u, [])
			else if (typeof u == "object")
				if (Array.isArray(u)) {
					const [m, ...c] = u
					l(m, c)
				} else s(u)
			else throw new TypeError("Expected usable value, not `" + u + "`")
		}
		function s(u) {
			if (!("plugins" in u) && !("settings" in u))
				throw new Error(
					"Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither",
				)
			a(u.plugins), u.settings && (i.settings = Zr(!0, i.settings, u.settings))
		}
		function a(u) {
			let m = -1
			if (u != null)
				if (Array.isArray(u))
					for (; ++m < u.length; ) {
						const c = u[m]
						o(c)
					}
				else throw new TypeError("Expected a list of plugins, not `" + u + "`")
		}
		function l(u, m) {
			let c = -1,
				h = -1
			for (; ++c < r.length; )
				if (r[c][0] === u) {
					h = c
					break
				}
			if (h === -1) r.push([u, ...m])
			else if (m.length > 0) {
				let [p, ...f] = m
				const y = r[h][1]
				Li(y) && Li(p) && (p = Zr(!0, y, p)), (r[h] = [u, p, ...f])
			}
		}
	}
}
const yd = new po().freeze()
function ri(e, t) {
	if (typeof t != "function") throw new TypeError("Cannot `" + e + "` without `parser`")
}
function ii(e, t) {
	if (typeof t != "function") throw new TypeError("Cannot `" + e + "` without `compiler`")
}
function oi(e, t) {
	if (t)
		throw new Error(
			"Cannot call `" +
				e +
				"` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.",
		)
}
function Is(e) {
	if (!Li(e) || typeof e.type != "string") throw new TypeError("Expected node, got `" + e + "`")
}
function Ts(e, t, n) {
	if (!n) throw new Error("`" + e + "` finished async. Use `" + t + "` instead")
}
function Kn(e) {
	return xd(e) ? e : new Il(e)
}
function xd(e) {
	return !!(e && typeof e == "object" && "message" in e && "messages" in e)
}
function bd(e) {
	return typeof e == "string" || kd(e)
}
function kd(e) {
	return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e)
}
const wd = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md",
	Cs = [],
	As = { allowDangerousHtml: !0 },
	Ed = /^(https?|ircs?|mailto|xmpp)$/i,
	vd = [
		{ from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
		{ from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
		{ from: "allowNode", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowElement" },
		{ from: "allowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowedElements" },
		{ from: "disallowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "disallowedElements" },
		{ from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
		{ from: "includeElementIndex", id: "#remove-includeelementindex" },
		{ from: "includeNodeIndex", id: "change-includenodeindex-to-includeelementindex" },
		{ from: "linkTarget", id: "remove-linktarget" },
		{ from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
		{ from: "rawSourcePos", id: "#remove-rawsourcepos" },
		{ from: "renderers", id: "change-renderers-to-components", to: "components" },
		{ from: "source", id: "change-source-to-children", to: "children" },
		{ from: "sourcePos", id: "#remove-sourcepos" },
		{ from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
		{ from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" },
	]
function Sd(e) {
	const t = Id(e),
		n = Td(e)
	return Cd(t.runSync(t.parse(n), n), e)
}
function Id(e) {
	const t = e.rehypePlugins || Cs,
		n = e.remarkPlugins || Cs,
		r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...As } : As
	return yd().use(sf).use(n).use(ed, r).use(t)
}
function Td(e) {
	const t = e.children || "",
		n = new Il()
	return typeof t == "string" && (n.value = t), n
}
function Cd(e, t) {
	const n = t.allowedElements,
		r = t.allowElement,
		i = t.components,
		o = t.disallowedElements,
		s = t.skipHtml,
		a = t.unwrapDisallowed,
		l = t.urlTransform || Ad
	for (const m of vd)
		Object.hasOwn(t, m.from) &&
			("" + m.from + (m.to ? "use `" + m.to + "` instead" : "remove it") + wd + m.id, void 0)
	return (
		t.className &&
			(e = {
				type: "element",
				tagName: "div",
				properties: { className: t.className },
				children: e.type === "root" ? e.children : [e],
			}),
		mo(e, u),
		Hm(e, {
			Fragment: D.Fragment,
			components: i,
			ignoreInvalidStyle: !0,
			jsx: D.jsx,
			jsxs: D.jsxs,
			passKeys: !0,
			passNode: !0,
		})
	)
	function u(m, c, h) {
		if (m.type === "raw" && h && typeof c == "number")
			return s ? h.children.splice(c, 1) : (h.children[c] = { type: "text", value: m.value }), c
		if (m.type === "element") {
			let p
			for (p in Yr)
				if (Object.hasOwn(Yr, p) && Object.hasOwn(m.properties, p)) {
					const f = m.properties[p],
						y = Yr[p]
					;(y === null || y.includes(m.tagName)) && (m.properties[p] = l(String(f || ""), p, m))
				}
		}
		if (m.type === "element") {
			let p = n ? !n.includes(m.tagName) : o ? o.includes(m.tagName) : !1
			if ((!p && r && typeof c == "number" && (p = !r(m, c, h)), p && h && typeof c == "number"))
				return a && m.children ? h.children.splice(c, 1, ...m.children) : h.children.splice(c, 1), c
		}
	}
}
function Ad(e) {
	const t = e.indexOf(":"),
		n = e.indexOf("?"),
		r = e.indexOf("#"),
		i = e.indexOf("/")
	return t === -1 || (i !== -1 && t > i) || (n !== -1 && t > n) || (r !== -1 && t > r) || Ed.test(e.slice(0, t))
		? e
		: ""
}
function hr(e, t) {
	const n = String(e)
	if (typeof t != "string") throw new TypeError("Expected character")
	let r = 0,
		i = n.indexOf(t)
	for (; i !== -1; ) r++, (i = n.indexOf(t, i + t.length))
	return r
}
function Rd(e) {
	if (typeof e != "string") throw new TypeError("Expected a string")
	return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
}
function Ld(e, t, n) {
	const i = Mr((n || {}).ignore || []),
		o = Pd(t)
	let s = -1
	for (; ++s < o.length; ) Sl(e, "text", a)
	function a(u, m) {
		let c = -1,
			h
		for (; ++c < m.length; ) {
			const p = m[c],
				f = h ? h.children : void 0
			if (i(p, f ? f.indexOf(p) : void 0, h)) return
			h = p
		}
		if (h) return l(u, m)
	}
	function l(u, m) {
		const c = m[m.length - 1],
			h = o[s][0],
			p = o[s][1]
		let f = 0
		const x = c.children.indexOf(u)
		let d = !1,
			_ = []
		h.lastIndex = 0
		let w = h.exec(u.value)
		for (; w; ) {
			const I = w.index,
				S = { index: w.index, input: w.input, stack: [...m, u] }
			let b = p(...w, S)
			if (
				(typeof b == "string" && (b = b.length > 0 ? { type: "text", value: b } : void 0),
				b === !1
					? (h.lastIndex = I + 1)
					: (f !== I && _.push({ type: "text", value: u.value.slice(f, I) }),
						Array.isArray(b) ? _.push(...b) : b && _.push(b),
						(f = I + w[0].length),
						(d = !0)),
				!h.global)
			)
				break
			w = h.exec(u.value)
		}
		return (
			d
				? (f < u.value.length && _.push({ type: "text", value: u.value.slice(f) }),
					c.children.splice(x, 1, ..._))
				: (_ = [u]),
			x + _.length
		)
	}
}
function Pd(e) {
	const t = []
	if (!Array.isArray(e)) throw new TypeError("Expected find and replace tuple or list of tuples")
	const n = !e[0] || Array.isArray(e[0]) ? e : [e]
	let r = -1
	for (; ++r < n.length; ) {
		const i = n[r]
		t.push([Od(i[0]), Dd(i[1])])
	}
	return t
}
function Od(e) {
	return typeof e == "string" ? new RegExp(Rd(e), "g") : e
}
function Dd(e) {
	return typeof e == "function"
		? e
		: function () {
				return e
			}
}
const si = "phrasing",
	ai = ["autolink", "link", "image", "label"]
function Nd() {
	return {
		transforms: [Hd],
		enter: { literalAutolink: zd, literalAutolinkEmail: li, literalAutolinkHttp: li, literalAutolinkWww: li },
		exit: { literalAutolink: jd, literalAutolinkEmail: Fd, literalAutolinkHttp: Vd, literalAutolinkWww: Bd },
	}
}
function Md() {
	return {
		unsafe: [
			{ character: "@", before: "[+\\-.\\w]", after: "[\\-.\\w]", inConstruct: si, notInConstruct: ai },
			{ character: ".", before: "[Ww]", after: "[\\-.\\w]", inConstruct: si, notInConstruct: ai },
			{ character: ":", before: "[ps]", after: "\\/", inConstruct: si, notInConstruct: ai },
		],
	}
}
function zd(e) {
	this.enter({ type: "link", title: null, url: "", children: [] }, e)
}
function li(e) {
	this.config.enter.autolinkProtocol.call(this, e)
}
function Vd(e) {
	this.config.exit.autolinkProtocol.call(this, e)
}
function Bd(e) {
	this.config.exit.data.call(this, e)
	const t = this.stack[this.stack.length - 1]
	t.type, (t.url = "http://" + this.sliceSerialize(e))
}
function Fd(e) {
	this.config.exit.autolinkEmail.call(this, e)
}
function jd(e) {
	this.exit(e)
}
function Hd(e) {
	Ld(
		e,
		[
			[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, Gd],
			[new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), $d],
		],
		{ ignore: ["link", "linkReference"] },
	)
}
function Gd(e, t, n, r, i) {
	let o = ""
	if (!Tl(i) || (/^w/i.test(t) && ((n = t + n), (t = ""), (o = "http://")), !Ud(n))) return !1
	const s = qd(n + r)
	if (!s[0]) return !1
	const a = { type: "link", title: null, url: o + t + s[0], children: [{ type: "text", value: t + s[0] }] }
	return s[1] ? [a, { type: "text", value: s[1] }] : a
}
function $d(e, t, n, r) {
	return !Tl(r, !0) || /[-\d_]$/.test(n)
		? !1
		: { type: "link", title: null, url: "mailto:" + t + "@" + n, children: [{ type: "text", value: t + "@" + n }] }
}
function Ud(e) {
	const t = e.split(".")
	return !(
		t.length < 2 ||
		(t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1]))) ||
		(t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])))
	)
}
function qd(e) {
	const t = /[!"&'),.:;<>?\]}]+$/.exec(e)
	if (!t) return [e, void 0]
	e = e.slice(0, t.index)
	let n = t[0],
		r = n.indexOf(")")
	const i = hr(e, "(")
	let o = hr(e, ")")
	for (; r !== -1 && i > o; ) (e += n.slice(0, r + 1)), (n = n.slice(r + 1)), (r = n.indexOf(")")), o++
	return [e, n]
}
function Tl(e, t) {
	const n = e.input.charCodeAt(e.index - 1)
	return (e.index === 0 || Ft(n) || Or(n)) && (!t || n !== 47)
}
Cl.peek = tg
function Wd() {
	this.buffer()
}
function Kd(e) {
	this.enter({ type: "footnoteReference", identifier: "", label: "" }, e)
}
function Yd() {
	this.buffer()
}
function Xd(e) {
	this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, e)
}
function Qd(e) {
	const t = this.resume(),
		n = this.stack[this.stack.length - 1]
	n.type, (n.identifier = ot(this.sliceSerialize(e)).toLowerCase()), (n.label = t)
}
function Jd(e) {
	this.exit(e)
}
function Zd(e) {
	const t = this.resume(),
		n = this.stack[this.stack.length - 1]
	n.type, (n.identifier = ot(this.sliceSerialize(e)).toLowerCase()), (n.label = t)
}
function eg(e) {
	this.exit(e)
}
function tg() {
	return "["
}
function Cl(e, t, n, r) {
	const i = n.createTracker(r)
	let o = i.move("[^")
	const s = n.enter("footnoteReference"),
		a = n.enter("reference")
	return (o += i.move(n.safe(n.associationId(e), { after: "]", before: o }))), a(), s(), (o += i.move("]")), o
}
function ng() {
	return {
		enter: {
			gfmFootnoteCallString: Wd,
			gfmFootnoteCall: Kd,
			gfmFootnoteDefinitionLabelString: Yd,
			gfmFootnoteDefinition: Xd,
		},
		exit: {
			gfmFootnoteCallString: Qd,
			gfmFootnoteCall: Jd,
			gfmFootnoteDefinitionLabelString: Zd,
			gfmFootnoteDefinition: eg,
		},
	}
}
function rg(e) {
	let t = !1
	return (
		e && e.firstLineBlank && (t = !0),
		{
			handlers: { footnoteDefinition: n, footnoteReference: Cl },
			unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }],
		}
	)
	function n(r, i, o, s) {
		const a = o.createTracker(s)
		let l = a.move("[^")
		const u = o.enter("footnoteDefinition"),
			m = o.enter("label")
		return (
			(l += a.move(o.safe(o.associationId(r), { before: l, after: "]" }))),
			m(),
			(l += a.move("]:")),
			r.children &&
				r.children.length > 0 &&
				(a.shift(4),
				(l += a.move(
					(t
						? `
`
						: " ") + o.indentLines(o.containerFlow(r, a.current()), t ? Al : ig),
				))),
			u(),
			l
		)
	}
}
function ig(e, t, n) {
	return t === 0 ? e : Al(e, t, n)
}
function Al(e, t, n) {
	return (n ? "" : "    ") + e
}
const og = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"]
Rl.peek = cg
function sg() {
	return { canContainEols: ["delete"], enter: { strikethrough: lg }, exit: { strikethrough: ug } }
}
function ag() {
	return { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: og }], handlers: { delete: Rl } }
}
function lg(e) {
	this.enter({ type: "delete", children: [] }, e)
}
function ug(e) {
	this.exit(e)
}
function Rl(e, t, n, r) {
	const i = n.createTracker(r),
		o = n.enter("strikethrough")
	let s = i.move("~~")
	return (s += n.containerPhrasing(e, { ...i.current(), before: s, after: "~" })), (s += i.move("~~")), o(), s
}
function cg() {
	return "~"
}
function mg(e) {
	return e.length
}
function pg(e, t) {
	const n = t || {},
		r = (n.align || []).concat(),
		i = n.stringLength || mg,
		o = [],
		s = [],
		a = [],
		l = []
	let u = 0,
		m = -1
	for (; ++m < e.length; ) {
		const y = [],
			x = []
		let d = -1
		for (e[m].length > u && (u = e[m].length); ++d < e[m].length; ) {
			const _ = hg(e[m][d])
			if (n.alignDelimiters !== !1) {
				const w = i(_)
				;(x[d] = w), (l[d] === void 0 || w > l[d]) && (l[d] = w)
			}
			y.push(_)
		}
		;(s[m] = y), (a[m] = x)
	}
	let c = -1
	if (typeof r == "object" && "length" in r) for (; ++c < u; ) o[c] = Rs(r[c])
	else {
		const y = Rs(r)
		for (; ++c < u; ) o[c] = y
	}
	c = -1
	const h = [],
		p = []
	for (; ++c < u; ) {
		const y = o[c]
		let x = "",
			d = ""
		y === 99 ? ((x = ":"), (d = ":")) : y === 108 ? (x = ":") : y === 114 && (d = ":")
		let _ = n.alignDelimiters === !1 ? 1 : Math.max(1, l[c] - x.length - d.length)
		const w = x + "-".repeat(_) + d
		n.alignDelimiters !== !1 && ((_ = x.length + _ + d.length), _ > l[c] && (l[c] = _), (p[c] = _)), (h[c] = w)
	}
	s.splice(1, 0, h), a.splice(1, 0, p), (m = -1)
	const f = []
	for (; ++m < s.length; ) {
		const y = s[m],
			x = a[m]
		c = -1
		const d = []
		for (; ++c < u; ) {
			const _ = y[c] || ""
			let w = "",
				I = ""
			if (n.alignDelimiters !== !1) {
				const S = l[c] - (x[c] || 0),
					b = o[c]
				b === 114
					? (w = " ".repeat(S))
					: b === 99
						? S % 2
							? ((w = " ".repeat(S / 2 + 0.5)), (I = " ".repeat(S / 2 - 0.5)))
							: ((w = " ".repeat(S / 2)), (I = w))
						: (I = " ".repeat(S))
			}
			n.delimiterStart !== !1 && !c && d.push("|"),
				n.padding !== !1 &&
					!(n.alignDelimiters === !1 && _ === "") &&
					(n.delimiterStart !== !1 || c) &&
					d.push(" "),
				n.alignDelimiters !== !1 && d.push(w),
				d.push(_),
				n.alignDelimiters !== !1 && d.push(I),
				n.padding !== !1 && d.push(" "),
				(n.delimiterEnd !== !1 || c !== u - 1) && d.push("|")
		}
		f.push(n.delimiterEnd === !1 ? d.join("").replace(/ +$/, "") : d.join(""))
	}
	return f.join(`
`)
}
function hg(e) {
	return e == null ? "" : String(e)
}
function Rs(e) {
	const t = typeof e == "string" ? e.codePointAt(0) : 0
	return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0
}
const Ls = {}.hasOwnProperty
function fg(e, t) {
	const n = t || {}
	function r(i, ...o) {
		let s = r.invalid
		const a = r.handlers
		if (i && Ls.call(i, e)) {
			const l = String(i[e])
			s = Ls.call(a, l) ? a[l] : r.unknown
		}
		if (s) return s.call(this, i, ...o)
	}
	return (r.handlers = n.handlers || {}), (r.invalid = n.invalid), (r.unknown = n.unknown), r
}
function dg(e, t, n, r) {
	const i = n.enter("blockquote"),
		o = n.createTracker(r)
	o.move("> "), o.shift(2)
	const s = n.indentLines(n.containerFlow(e, o.current()), gg)
	return i(), s
}
function gg(e, t, n) {
	return ">" + (n ? "" : " ") + e
}
function _g(e, t) {
	return Ps(e, t.inConstruct, !0) && !Ps(e, t.notInConstruct, !1)
}
function Ps(e, t, n) {
	if ((typeof t == "string" && (t = [t]), !t || t.length === 0)) return n
	let r = -1
	for (; ++r < t.length; ) if (e.includes(t[r])) return !0
	return !1
}
function Os(e, t, n, r) {
	let i = -1
	for (; ++i < n.unsafe.length; )
		if (
			n.unsafe[i].character ===
				`
` &&
			_g(n.stack, n.unsafe[i])
		)
			return /[ \t]/.test(r.before) ? "" : " "
	return `\\
`
}
function yg(e, t) {
	const n = String(e)
	let r = n.indexOf(t),
		i = r,
		o = 0,
		s = 0
	if (typeof t != "string") throw new TypeError("Expected substring")
	for (; r !== -1; ) r === i ? ++o > s && (s = o) : (o = 1), (i = r + t.length), (r = n.indexOf(t, i))
	return s
}
function xg(e, t) {
	return !!(
		t.options.fences === !1 &&
		e.value &&
		!e.lang &&
		/[^ \r\n]/.test(e.value) &&
		!/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value)
	)
}
function bg(e) {
	const t = e.options.fence || "`"
	if (t !== "`" && t !== "~")
		throw new Error("Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`")
	return t
}
function kg(e, t, n, r) {
	const i = bg(n),
		o = e.value || "",
		s = i === "`" ? "GraveAccent" : "Tilde"
	if (xg(e, n)) {
		const c = n.enter("codeIndented"),
			h = n.indentLines(o, wg)
		return c(), h
	}
	const a = n.createTracker(r),
		l = i.repeat(Math.max(yg(o, i) + 1, 3)),
		u = n.enter("codeFenced")
	let m = a.move(l)
	if (e.lang) {
		const c = n.enter(`codeFencedLang${s}`)
		;(m += a.move(n.safe(e.lang, { before: m, after: " ", encode: ["`"], ...a.current() }))), c()
	}
	if (e.lang && e.meta) {
		const c = n.enter(`codeFencedMeta${s}`)
		;(m += a.move(" ")),
			(m += a.move(
				n.safe(e.meta, {
					before: m,
					after: `
`,
					encode: ["`"],
					...a.current(),
				}),
			)),
			c()
	}
	return (
		(m += a.move(`
`)),
		o &&
			(m += a.move(
				o +
					`
`,
			)),
		(m += a.move(l)),
		u(),
		m
	)
}
function wg(e, t, n) {
	return (n ? "" : "    ") + e
}
function ho(e) {
	const t = e.options.quote || '"'
	if (t !== '"' && t !== "'")
		throw new Error("Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`")
	return t
}
function Eg(e, t, n, r) {
	const i = ho(n),
		o = i === '"' ? "Quote" : "Apostrophe",
		s = n.enter("definition")
	let a = n.enter("label")
	const l = n.createTracker(r)
	let u = l.move("[")
	return (
		(u += l.move(n.safe(n.associationId(e), { before: u, after: "]", ...l.current() }))),
		(u += l.move("]: ")),
		a(),
		!e.url || /[\0- \u007F]/.test(e.url)
			? ((a = n.enter("destinationLiteral")),
				(u += l.move("<")),
				(u += l.move(n.safe(e.url, { before: u, after: ">", ...l.current() }))),
				(u += l.move(">")))
			: ((a = n.enter("destinationRaw")),
				(u += l.move(
					n.safe(e.url, {
						before: u,
						after: e.title
							? " "
							: `
`,
						...l.current(),
					}),
				))),
		a(),
		e.title &&
			((a = n.enter(`title${o}`)),
			(u += l.move(" " + i)),
			(u += l.move(n.safe(e.title, { before: u, after: i, ...l.current() }))),
			(u += l.move(i)),
			a()),
		s(),
		u
	)
}
function vg(e) {
	const t = e.options.emphasis || "*"
	if (t !== "*" && t !== "_")
		throw new Error("Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`")
	return t
}
function An(e) {
	return "&#x" + e.toString(16).toUpperCase() + ";"
}
function fr(e, t, n) {
	const r = en(e),
		i = en(t)
	return r === void 0
		? i === void 0
			? n === "_"
				? { inside: !0, outside: !0 }
				: { inside: !1, outside: !1 }
			: i === 1
				? { inside: !0, outside: !0 }
				: { inside: !1, outside: !0 }
		: r === 1
			? i === void 0
				? { inside: !1, outside: !1 }
				: i === 1
					? { inside: !0, outside: !0 }
					: { inside: !1, outside: !1 }
			: i === void 0
				? { inside: !1, outside: !1 }
				: i === 1
					? { inside: !0, outside: !1 }
					: { inside: !1, outside: !1 }
}
Ll.peek = Sg
function Ll(e, t, n, r) {
	const i = vg(n),
		o = n.enter("emphasis"),
		s = n.createTracker(r),
		a = s.move(i)
	let l = s.move(n.containerPhrasing(e, { after: i, before: a, ...s.current() }))
	const u = l.charCodeAt(0),
		m = fr(r.before.charCodeAt(r.before.length - 1), u, i)
	m.inside && (l = An(u) + l.slice(1))
	const c = l.charCodeAt(l.length - 1),
		h = fr(r.after.charCodeAt(0), c, i)
	h.inside && (l = l.slice(0, -1) + An(c))
	const p = s.move(i)
	return o(), (n.attentionEncodeSurroundingInfo = { after: h.outside, before: m.outside }), a + l + p
}
function Sg(e, t, n) {
	return n.options.emphasis || "*"
}
function Ig(e, t) {
	let n = !1
	return (
		mo(e, function (r) {
			if (("value" in r && /\r?\n|\r/.test(r.value)) || r.type === "break") return (n = !0), Ai
		}),
		!!((!e.depth || e.depth < 3) && io(e) && (t.options.setext || n))
	)
}
function Tg(e, t, n, r) {
	const i = Math.max(Math.min(6, e.depth || 1), 1),
		o = n.createTracker(r)
	if (Ig(e, n)) {
		const m = n.enter("headingSetext"),
			c = n.enter("phrasing"),
			h = n.containerPhrasing(e, {
				...o.current(),
				before: `
`,
				after: `
`,
			})
		return (
			c(),
			m(),
			h +
				`
` +
				(i === 1 ? "=" : "-").repeat(
					h.length -
						(Math.max(
							h.lastIndexOf("\r"),
							h.lastIndexOf(`
`),
						) +
							1),
				)
		)
	}
	const s = "#".repeat(i),
		a = n.enter("headingAtx"),
		l = n.enter("phrasing")
	o.move(s + " ")
	let u = n.containerPhrasing(e, {
		before: "# ",
		after: `
`,
		...o.current(),
	})
	return (
		/^[\t ]/.test(u) && (u = An(u.charCodeAt(0)) + u.slice(1)),
		(u = u ? s + " " + u : s),
		n.options.closeAtx && (u += " " + s),
		l(),
		a(),
		u
	)
}
Pl.peek = Cg
function Pl(e) {
	return e.value || ""
}
function Cg() {
	return "<"
}
Ol.peek = Ag
function Ol(e, t, n, r) {
	const i = ho(n),
		o = i === '"' ? "Quote" : "Apostrophe",
		s = n.enter("image")
	let a = n.enter("label")
	const l = n.createTracker(r)
	let u = l.move("![")
	return (
		(u += l.move(n.safe(e.alt, { before: u, after: "]", ...l.current() }))),
		(u += l.move("](")),
		a(),
		(!e.url && e.title) || /[\0- \u007F]/.test(e.url)
			? ((a = n.enter("destinationLiteral")),
				(u += l.move("<")),
				(u += l.move(n.safe(e.url, { before: u, after: ">", ...l.current() }))),
				(u += l.move(">")))
			: ((a = n.enter("destinationRaw")),
				(u += l.move(n.safe(e.url, { before: u, after: e.title ? " " : ")", ...l.current() })))),
		a(),
		e.title &&
			((a = n.enter(`title${o}`)),
			(u += l.move(" " + i)),
			(u += l.move(n.safe(e.title, { before: u, after: i, ...l.current() }))),
			(u += l.move(i)),
			a()),
		(u += l.move(")")),
		s(),
		u
	)
}
function Ag() {
	return "!"
}
Dl.peek = Rg
function Dl(e, t, n, r) {
	const i = e.referenceType,
		o = n.enter("imageReference")
	let s = n.enter("label")
	const a = n.createTracker(r)
	let l = a.move("![")
	const u = n.safe(e.alt, { before: l, after: "]", ...a.current() })
	;(l += a.move(u + "][")), s()
	const m = n.stack
	;(n.stack = []), (s = n.enter("reference"))
	const c = n.safe(n.associationId(e), { before: l, after: "]", ...a.current() })
	return (
		s(),
		(n.stack = m),
		o(),
		i === "full" || !u || u !== c
			? (l += a.move(c + "]"))
			: i === "shortcut"
				? (l = l.slice(0, -1))
				: (l += a.move("]")),
		l
	)
}
function Rg() {
	return "!"
}
Nl.peek = Lg
function Nl(e, t, n) {
	let r = e.value || "",
		i = "`",
		o = -1
	for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); ) i += "`"
	for (
		/[^ \r\n]/.test(r) && ((/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r)) || /^`|`$/.test(r)) && (r = " " + r + " ");
		++o < n.unsafe.length;

	) {
		const s = n.unsafe[o],
			a = n.compilePattern(s)
		let l
		if (s.atBreak)
			for (; (l = a.exec(r)); ) {
				let u = l.index
				r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--,
					(r = r.slice(0, u) + " " + r.slice(l.index + 1))
			}
	}
	return i + r + i
}
function Lg() {
	return "`"
}
function Ml(e, t) {
	const n = io(e)
	return !!(
		!t.options.resourceLink &&
		e.url &&
		!e.title &&
		e.children &&
		e.children.length === 1 &&
		e.children[0].type === "text" &&
		(n === e.url || "mailto:" + n === e.url) &&
		/^[a-z][a-z+.-]+:/i.test(e.url) &&
		!/[\0- <>\u007F]/.test(e.url)
	)
}
zl.peek = Pg
function zl(e, t, n, r) {
	const i = ho(n),
		o = i === '"' ? "Quote" : "Apostrophe",
		s = n.createTracker(r)
	let a, l
	if (Ml(e, n)) {
		const m = n.stack
		;(n.stack = []), (a = n.enter("autolink"))
		let c = s.move("<")
		return (
			(c += s.move(n.containerPhrasing(e, { before: c, after: ">", ...s.current() }))),
			(c += s.move(">")),
			a(),
			(n.stack = m),
			c
		)
	}
	;(a = n.enter("link")), (l = n.enter("label"))
	let u = s.move("[")
	return (
		(u += s.move(n.containerPhrasing(e, { before: u, after: "](", ...s.current() }))),
		(u += s.move("](")),
		l(),
		(!e.url && e.title) || /[\0- \u007F]/.test(e.url)
			? ((l = n.enter("destinationLiteral")),
				(u += s.move("<")),
				(u += s.move(n.safe(e.url, { before: u, after: ">", ...s.current() }))),
				(u += s.move(">")))
			: ((l = n.enter("destinationRaw")),
				(u += s.move(n.safe(e.url, { before: u, after: e.title ? " " : ")", ...s.current() })))),
		l(),
		e.title &&
			((l = n.enter(`title${o}`)),
			(u += s.move(" " + i)),
			(u += s.move(n.safe(e.title, { before: u, after: i, ...s.current() }))),
			(u += s.move(i)),
			l()),
		(u += s.move(")")),
		a(),
		u
	)
}
function Pg(e, t, n) {
	return Ml(e, n) ? "<" : "["
}
Vl.peek = Og
function Vl(e, t, n, r) {
	const i = e.referenceType,
		o = n.enter("linkReference")
	let s = n.enter("label")
	const a = n.createTracker(r)
	let l = a.move("[")
	const u = n.containerPhrasing(e, { before: l, after: "]", ...a.current() })
	;(l += a.move(u + "][")), s()
	const m = n.stack
	;(n.stack = []), (s = n.enter("reference"))
	const c = n.safe(n.associationId(e), { before: l, after: "]", ...a.current() })
	return (
		s(),
		(n.stack = m),
		o(),
		i === "full" || !u || u !== c
			? (l += a.move(c + "]"))
			: i === "shortcut"
				? (l = l.slice(0, -1))
				: (l += a.move("]")),
		l
	)
}
function Og() {
	return "["
}
function fo(e) {
	const t = e.options.bullet || "*"
	if (t !== "*" && t !== "+" && t !== "-")
		throw new Error("Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`")
	return t
}
function Dg(e) {
	const t = fo(e),
		n = e.options.bulletOther
	if (!n) return t === "*" ? "-" : "*"
	if (n !== "*" && n !== "+" && n !== "-")
		throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`")
	if (n === t) throw new Error("Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different")
	return n
}
function Ng(e) {
	const t = e.options.bulletOrdered || "."
	if (t !== "." && t !== ")")
		throw new Error("Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`")
	return t
}
function Bl(e) {
	const t = e.options.rule || "*"
	if (t !== "*" && t !== "-" && t !== "_")
		throw new Error("Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`")
	return t
}
function Mg(e, t, n, r) {
	const i = n.enter("list"),
		o = n.bulletCurrent
	let s = e.ordered ? Ng(n) : fo(n)
	const a = e.ordered ? (s === "." ? ")" : ".") : Dg(n)
	let l = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1
	if (!e.ordered) {
		const m = e.children ? e.children[0] : void 0
		if (
			((s === "*" || s === "-") &&
				m &&
				(!m.children || !m.children[0]) &&
				n.stack[n.stack.length - 1] === "list" &&
				n.stack[n.stack.length - 2] === "listItem" &&
				n.stack[n.stack.length - 3] === "list" &&
				n.stack[n.stack.length - 4] === "listItem" &&
				n.indexStack[n.indexStack.length - 1] === 0 &&
				n.indexStack[n.indexStack.length - 2] === 0 &&
				n.indexStack[n.indexStack.length - 3] === 0 &&
				(l = !0),
			Bl(n) === s && m)
		) {
			let c = -1
			for (; ++c < e.children.length; ) {
				const h = e.children[c]
				if (
					h &&
					h.type === "listItem" &&
					h.children &&
					h.children[0] &&
					h.children[0].type === "thematicBreak"
				) {
					l = !0
					break
				}
			}
		}
	}
	l && (s = a), (n.bulletCurrent = s)
	const u = n.containerFlow(e, r)
	return (n.bulletLastUsed = s), (n.bulletCurrent = o), i(), u
}
function zg(e) {
	const t = e.options.listItemIndent || "one"
	if (t !== "tab" && t !== "one" && t !== "mixed")
		throw new Error(
			"Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`",
		)
	return t
}
function Vg(e, t, n, r) {
	const i = zg(n)
	let o = n.bulletCurrent || fo(n)
	t &&
		t.type === "list" &&
		t.ordered &&
		(o =
			(typeof t.start == "number" && t.start > -1 ? t.start : 1) +
			(n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) +
			o)
	let s = o.length + 1
	;(i === "tab" || (i === "mixed" && ((t && t.type === "list" && t.spread) || e.spread))) &&
		(s = Math.ceil(s / 4) * 4)
	const a = n.createTracker(r)
	a.move(o + " ".repeat(s - o.length)), a.shift(s)
	const l = n.enter("listItem"),
		u = n.indentLines(n.containerFlow(e, a.current()), m)
	return l(), u
	function m(c, h, p) {
		return h ? (p ? "" : " ".repeat(s)) + c : (p ? o : o + " ".repeat(s - o.length)) + c
	}
}
function Bg(e, t, n, r) {
	const i = n.enter("paragraph"),
		o = n.enter("phrasing"),
		s = n.containerPhrasing(e, r)
	return o(), i(), s
}
const Fg = Mr([
	"break",
	"delete",
	"emphasis",
	"footnote",
	"footnoteReference",
	"image",
	"imageReference",
	"inlineCode",
	"inlineMath",
	"link",
	"linkReference",
	"mdxJsxTextElement",
	"mdxTextExpression",
	"strong",
	"text",
	"textDirective",
])
function jg(e, t, n, r) {
	return (
		e.children.some(function (s) {
			return Fg(s)
		})
			? n.containerPhrasing
			: n.containerFlow
	).call(n, e, r)
}
function Hg(e) {
	const t = e.options.strong || "*"
	if (t !== "*" && t !== "_")
		throw new Error("Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`")
	return t
}
Fl.peek = Gg
function Fl(e, t, n, r) {
	const i = Hg(n),
		o = n.enter("strong"),
		s = n.createTracker(r),
		a = s.move(i + i)
	let l = s.move(n.containerPhrasing(e, { after: i, before: a, ...s.current() }))
	const u = l.charCodeAt(0),
		m = fr(r.before.charCodeAt(r.before.length - 1), u, i)
	m.inside && (l = An(u) + l.slice(1))
	const c = l.charCodeAt(l.length - 1),
		h = fr(r.after.charCodeAt(0), c, i)
	h.inside && (l = l.slice(0, -1) + An(c))
	const p = s.move(i + i)
	return o(), (n.attentionEncodeSurroundingInfo = { after: h.outside, before: m.outside }), a + l + p
}
function Gg(e, t, n) {
	return n.options.strong || "*"
}
function $g(e, t, n, r) {
	return n.safe(e.value, r)
}
function Ug(e) {
	const t = e.options.ruleRepetition || 3
	if (t < 3)
		throw new Error(
			"Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more",
		)
	return t
}
function qg(e, t, n) {
	const r = (Bl(n) + (n.options.ruleSpaces ? " " : "")).repeat(Ug(n))
	return n.options.ruleSpaces ? r.slice(0, -1) : r
}
const jl = {
	blockquote: dg,
	break: Os,
	code: kg,
	definition: Eg,
	emphasis: Ll,
	hardBreak: Os,
	heading: Tg,
	html: Pl,
	image: Ol,
	imageReference: Dl,
	inlineCode: Nl,
	link: zl,
	linkReference: Vl,
	list: Mg,
	listItem: Vg,
	paragraph: Bg,
	root: jg,
	strong: Fl,
	text: $g,
	thematicBreak: qg,
}
function Wg() {
	return {
		enter: { table: Kg, tableData: Ds, tableHeader: Ds, tableRow: Xg },
		exit: { codeText: Qg, table: Yg, tableData: ui, tableHeader: ui, tableRow: ui },
	}
}
function Kg(e) {
	const t = e._align
	this.enter(
		{
			type: "table",
			align: t.map(function (n) {
				return n === "none" ? null : n
			}),
			children: [],
		},
		e,
	),
		(this.data.inTable = !0)
}
function Yg(e) {
	this.exit(e), (this.data.inTable = void 0)
}
function Xg(e) {
	this.enter({ type: "tableRow", children: [] }, e)
}
function ui(e) {
	this.exit(e)
}
function Ds(e) {
	this.enter({ type: "tableCell", children: [] }, e)
}
function Qg(e) {
	let t = this.resume()
	this.data.inTable && (t = t.replace(/\\([\\|])/g, Jg))
	const n = this.stack[this.stack.length - 1]
	n.type, (n.value = t), this.exit(e)
}
function Jg(e, t) {
	return t === "|" ? t : e
}
function Zg(e) {
	const t = e || {},
		n = t.tableCellPadding,
		r = t.tablePipeAlign,
		i = t.stringLength,
		o = n ? " " : "|"
	return {
		unsafe: [
			{ character: "\r", inConstruct: "tableCell" },
			{
				character: `
`,
				inConstruct: "tableCell",
			},
			{ atBreak: !0, character: "|", after: "[	 :-]" },
			{ character: "|", inConstruct: "tableCell" },
			{ atBreak: !0, character: ":", after: "-" },
			{ atBreak: !0, character: "-", after: "[:|-]" },
		],
		handlers: { inlineCode: h, table: s, tableCell: l, tableRow: a },
	}
	function s(p, f, y, x) {
		return u(m(p, y, x), p.align)
	}
	function a(p, f, y, x) {
		const d = c(p, y, x),
			_ = u([d])
		return _.slice(
			0,
			_.indexOf(`
`),
		)
	}
	function l(p, f, y, x) {
		const d = y.enter("tableCell"),
			_ = y.enter("phrasing"),
			w = y.containerPhrasing(p, { ...x, before: o, after: o })
		return _(), d(), w
	}
	function u(p, f) {
		return pg(p, { align: f, alignDelimiters: r, padding: n, stringLength: i })
	}
	function m(p, f, y) {
		const x = p.children
		let d = -1
		const _ = [],
			w = f.enter("table")
		for (; ++d < x.length; ) _[d] = c(x[d], f, y)
		return w(), _
	}
	function c(p, f, y) {
		const x = p.children
		let d = -1
		const _ = [],
			w = f.enter("tableRow")
		for (; ++d < x.length; ) _[d] = l(x[d], p, f, y)
		return w(), _
	}
	function h(p, f, y) {
		let x = jl.inlineCode(p, f, y)
		return y.stack.includes("tableCell") && (x = x.replace(/\|/g, "\\$&")), x
	}
}
function e_() {
	return { exit: { taskListCheckValueChecked: Ns, taskListCheckValueUnchecked: Ns, paragraph: n_ } }
}
function t_() {
	return { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: r_ } }
}
function Ns(e) {
	const t = this.stack[this.stack.length - 2]
	t.type, (t.checked = e.type === "taskListCheckValueChecked")
}
function n_(e) {
	const t = this.stack[this.stack.length - 2]
	if (t && t.type === "listItem" && typeof t.checked == "boolean") {
		const n = this.stack[this.stack.length - 1]
		n.type
		const r = n.children[0]
		if (r && r.type === "text") {
			const i = t.children
			let o = -1,
				s
			for (; ++o < i.length; ) {
				const a = i[o]
				if (a.type === "paragraph") {
					s = a
					break
				}
			}
			s === n &&
				((r.value = r.value.slice(1)),
				r.value.length === 0
					? n.children.shift()
					: n.position &&
						r.position &&
						typeof r.position.start.offset == "number" &&
						(r.position.start.column++,
						r.position.start.offset++,
						(n.position.start = Object.assign({}, r.position.start))))
		}
	}
	this.exit(e)
}
function r_(e, t, n, r) {
	const i = e.children[0],
		o = typeof e.checked == "boolean" && i && i.type === "paragraph",
		s = "[" + (e.checked ? "x" : " ") + "] ",
		a = n.createTracker(r)
	o && a.move(s)
	let l = jl.listItem(e, t, n, { ...r, ...a.current() })
	return o && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), l
	function u(m) {
		return m + s
	}
}
function i_() {
	return [Nd(), ng(), sg(), Wg(), e_()]
}
function o_(e) {
	return { extensions: [Md(), rg(e), ag(), Zg(e), t_()] }
}
const s_ = { tokenize: p_, partial: !0 },
	Hl = { tokenize: h_, partial: !0 },
	Gl = { tokenize: f_, partial: !0 },
	$l = { tokenize: d_, partial: !0 },
	a_ = { tokenize: g_, partial: !0 },
	Ul = { name: "wwwAutolink", tokenize: c_, previous: Wl },
	ql = { name: "protocolAutolink", tokenize: m_, previous: Kl },
	Et = { name: "emailAutolink", tokenize: u_, previous: Yl },
	dt = {}
function l_() {
	return { text: dt }
}
let Mt = 48
for (; Mt < 123; ) (dt[Mt] = Et), Mt++, Mt === 58 ? (Mt = 65) : Mt === 91 && (Mt = 97)
dt[43] = Et
dt[45] = Et
dt[46] = Et
dt[95] = Et
dt[72] = [Et, ql]
dt[104] = [Et, ql]
dt[87] = [Et, Ul]
dt[119] = [Et, Ul]
function u_(e, t, n) {
	const r = this
	let i, o
	return s
	function s(c) {
		return !Oi(c) || !Yl.call(r, r.previous) || go(r.events)
			? n(c)
			: (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), a(c))
	}
	function a(c) {
		return Oi(c) ? (e.consume(c), a) : c === 64 ? (e.consume(c), l) : n(c)
	}
	function l(c) {
		return c === 46 ? e.check(a_, m, u)(c) : c === 45 || c === 95 || Ve(c) ? ((o = !0), e.consume(c), l) : m(c)
	}
	function u(c) {
		return e.consume(c), (i = !0), l
	}
	function m(c) {
		return o && i && je(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(c)) : n(c)
	}
}
function c_(e, t, n) {
	const r = this
	return i
	function i(s) {
		return (s !== 87 && s !== 119) || !Wl.call(r, r.previous) || go(r.events)
			? n(s)
			: (e.enter("literalAutolink"),
				e.enter("literalAutolinkWww"),
				e.check(s_, e.attempt(Hl, e.attempt(Gl, o), n), n)(s))
	}
	function o(s) {
		return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s)
	}
}
function m_(e, t, n) {
	const r = this
	let i = "",
		o = !1
	return s
	function s(c) {
		return (c === 72 || c === 104) && Kl.call(r, r.previous) && !go(r.events)
			? (e.enter("literalAutolink"),
				e.enter("literalAutolinkHttp"),
				(i += String.fromCodePoint(c)),
				e.consume(c),
				a)
			: n(c)
	}
	function a(c) {
		if (je(c) && i.length < 5) return (i += String.fromCodePoint(c)), e.consume(c), a
		if (c === 58) {
			const h = i.toLowerCase()
			if (h === "http" || h === "https") return e.consume(c), l
		}
		return n(c)
	}
	function l(c) {
		return c === 47 ? (e.consume(c), o ? u : ((o = !0), l)) : n(c)
	}
	function u(c) {
		return c === null || cr(c) || fe(c) || Ft(c) || Or(c) ? n(c) : e.attempt(Hl, e.attempt(Gl, m), n)(c)
	}
	function m(c) {
		return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(c)
	}
}
function p_(e, t, n) {
	let r = 0
	return i
	function i(s) {
		return (s === 87 || s === 119) && r < 3
			? (r++, e.consume(s), i)
			: s === 46 && r === 3
				? (e.consume(s), o)
				: n(s)
	}
	function o(s) {
		return s === null ? n(s) : t(s)
	}
}
function h_(e, t, n) {
	let r, i, o
	return s
	function s(u) {
		return u === 46 || u === 95
			? e.check($l, l, a)(u)
			: u === null || fe(u) || Ft(u) || (u !== 45 && Or(u))
				? l(u)
				: ((o = !0), e.consume(u), s)
	}
	function a(u) {
		return u === 95 ? (r = !0) : ((i = r), (r = void 0)), e.consume(u), s
	}
	function l(u) {
		return i || r || !o ? n(u) : t(u)
	}
}
function f_(e, t) {
	let n = 0,
		r = 0
	return i
	function i(s) {
		return s === 40
			? (n++, e.consume(s), i)
			: s === 41 && r < n
				? o(s)
				: s === 33 ||
					  s === 34 ||
					  s === 38 ||
					  s === 39 ||
					  s === 41 ||
					  s === 42 ||
					  s === 44 ||
					  s === 46 ||
					  s === 58 ||
					  s === 59 ||
					  s === 60 ||
					  s === 63 ||
					  s === 93 ||
					  s === 95 ||
					  s === 126
					? e.check($l, t, o)(s)
					: s === null || fe(s) || Ft(s)
						? t(s)
						: (e.consume(s), i)
	}
	function o(s) {
		return s === 41 && r++, e.consume(s), i
	}
}
function d_(e, t, n) {
	return r
	function r(a) {
		return a === 33 ||
			a === 34 ||
			a === 39 ||
			a === 41 ||
			a === 42 ||
			a === 44 ||
			a === 46 ||
			a === 58 ||
			a === 59 ||
			a === 63 ||
			a === 95 ||
			a === 126
			? (e.consume(a), r)
			: a === 38
				? (e.consume(a), o)
				: a === 93
					? (e.consume(a), i)
					: a === 60 || a === null || fe(a) || Ft(a)
						? t(a)
						: n(a)
	}
	function i(a) {
		return a === null || a === 40 || a === 91 || fe(a) || Ft(a) ? t(a) : r(a)
	}
	function o(a) {
		return je(a) ? s(a) : n(a)
	}
	function s(a) {
		return a === 59 ? (e.consume(a), r) : je(a) ? (e.consume(a), s) : n(a)
	}
}
function g_(e, t, n) {
	return r
	function r(o) {
		return e.consume(o), i
	}
	function i(o) {
		return Ve(o) ? n(o) : t(o)
	}
}
function Wl(e) {
	return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || fe(e)
}
function Kl(e) {
	return !je(e)
}
function Yl(e) {
	return !(e === 47 || Oi(e))
}
function Oi(e) {
	return e === 43 || e === 45 || e === 46 || e === 95 || Ve(e)
}
function go(e) {
	let t = e.length,
		n = !1
	for (; t--; ) {
		const r = e[t][1]
		if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
			n = !0
			break
		}
		if (r._gfmAutolinkLiteralWalkedInto) {
			n = !1
			break
		}
	}
	return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n
}
const __ = { tokenize: S_, partial: !0 }
function y_() {
	return {
		document: { 91: { name: "gfmFootnoteDefinition", tokenize: w_, continuation: { tokenize: E_ }, exit: v_ } },
		text: {
			91: { name: "gfmFootnoteCall", tokenize: k_ },
			93: { name: "gfmPotentialFootnoteCall", add: "after", tokenize: x_, resolveTo: b_ },
		},
	}
}
function x_(e, t, n) {
	const r = this
	let i = r.events.length
	const o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = [])
	let s
	for (; i--; ) {
		const l = r.events[i][1]
		if (l.type === "labelImage") {
			s = l
			break
		}
		if (
			l.type === "gfmFootnoteCall" ||
			l.type === "labelLink" ||
			l.type === "label" ||
			l.type === "image" ||
			l.type === "link"
		)
			break
	}
	return a
	function a(l) {
		if (!s || !s._balanced) return n(l)
		const u = ot(r.sliceSerialize({ start: s.end, end: r.now() }))
		return u.codePointAt(0) !== 94 || !o.includes(u.slice(1))
			? n(l)
			: (e.enter("gfmFootnoteCallLabelMarker"), e.consume(l), e.exit("gfmFootnoteCallLabelMarker"), t(l))
	}
}
function b_(e, t) {
	let n = e.length
	for (; n--; )
		if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
			e[n][1]
			break
		}
	;(e[n + 1][1].type = "data"), (e[n + 3][1].type = "gfmFootnoteCallLabelMarker")
	const r = {
			type: "gfmFootnoteCall",
			start: Object.assign({}, e[n + 3][1].start),
			end: Object.assign({}, e[e.length - 1][1].end),
		},
		i = {
			type: "gfmFootnoteCallMarker",
			start: Object.assign({}, e[n + 3][1].end),
			end: Object.assign({}, e[n + 3][1].end),
		}
	i.end.column++, i.end.offset++, i.end._bufferIndex++
	const o = {
			type: "gfmFootnoteCallString",
			start: Object.assign({}, i.end),
			end: Object.assign({}, e[e.length - 1][1].start),
		},
		s = {
			type: "chunkString",
			contentType: "string",
			start: Object.assign({}, o.start),
			end: Object.assign({}, o.end),
		},
		a = [
			e[n + 1],
			e[n + 2],
			["enter", r, t],
			e[n + 3],
			e[n + 4],
			["enter", i, t],
			["exit", i, t],
			["enter", o, t],
			["enter", s, t],
			["exit", s, t],
			["exit", o, t],
			e[e.length - 2],
			e[e.length - 1],
			["exit", r, t],
		]
	return e.splice(n, e.length - n + 1, ...a), e
}
function k_(e, t, n) {
	const r = this,
		i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = [])
	let o = 0,
		s
	return a
	function a(c) {
		return (
			e.enter("gfmFootnoteCall"),
			e.enter("gfmFootnoteCallLabelMarker"),
			e.consume(c),
			e.exit("gfmFootnoteCallLabelMarker"),
			l
		)
	}
	function l(c) {
		return c !== 94
			? n(c)
			: (e.enter("gfmFootnoteCallMarker"),
				e.consume(c),
				e.exit("gfmFootnoteCallMarker"),
				e.enter("gfmFootnoteCallString"),
				(e.enter("chunkString").contentType = "string"),
				u)
	}
	function u(c) {
		if (o > 999 || (c === 93 && !s) || c === null || c === 91 || fe(c)) return n(c)
		if (c === 93) {
			e.exit("chunkString")
			const h = e.exit("gfmFootnoteCallString")
			return i.includes(ot(r.sliceSerialize(h)))
				? (e.enter("gfmFootnoteCallLabelMarker"),
					e.consume(c),
					e.exit("gfmFootnoteCallLabelMarker"),
					e.exit("gfmFootnoteCall"),
					t)
				: n(c)
		}
		return fe(c) || (s = !0), o++, e.consume(c), c === 92 ? m : u
	}
	function m(c) {
		return c === 91 || c === 92 || c === 93 ? (e.consume(c), o++, u) : u(c)
	}
}
function w_(e, t, n) {
	const r = this,
		i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = [])
	let o,
		s = 0,
		a
	return l
	function l(f) {
		return (
			(e.enter("gfmFootnoteDefinition")._container = !0),
			e.enter("gfmFootnoteDefinitionLabel"),
			e.enter("gfmFootnoteDefinitionLabelMarker"),
			e.consume(f),
			e.exit("gfmFootnoteDefinitionLabelMarker"),
			u
		)
	}
	function u(f) {
		return f === 94
			? (e.enter("gfmFootnoteDefinitionMarker"),
				e.consume(f),
				e.exit("gfmFootnoteDefinitionMarker"),
				e.enter("gfmFootnoteDefinitionLabelString"),
				(e.enter("chunkString").contentType = "string"),
				m)
			: n(f)
	}
	function m(f) {
		if (s > 999 || (f === 93 && !a) || f === null || f === 91 || fe(f)) return n(f)
		if (f === 93) {
			e.exit("chunkString")
			const y = e.exit("gfmFootnoteDefinitionLabelString")
			return (
				(o = ot(r.sliceSerialize(y))),
				e.enter("gfmFootnoteDefinitionLabelMarker"),
				e.consume(f),
				e.exit("gfmFootnoteDefinitionLabelMarker"),
				e.exit("gfmFootnoteDefinitionLabel"),
				h
			)
		}
		return fe(f) || (a = !0), s++, e.consume(f), f === 92 ? c : m
	}
	function c(f) {
		return f === 91 || f === 92 || f === 93 ? (e.consume(f), s++, m) : m(f)
	}
	function h(f) {
		return f === 58
			? (e.enter("definitionMarker"),
				e.consume(f),
				e.exit("definitionMarker"),
				i.includes(o) || i.push(o),
				oe(e, p, "gfmFootnoteDefinitionWhitespace"))
			: n(f)
	}
	function p(f) {
		return t(f)
	}
}
function E_(e, t, n) {
	return e.check(Fn, t, e.attempt(__, t, n))
}
function v_(e) {
	e.exit("gfmFootnoteDefinition")
}
function S_(e, t, n) {
	const r = this
	return oe(e, i, "gfmFootnoteDefinitionIndent", 5)
	function i(o) {
		const s = r.events[r.events.length - 1]
		return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4
			? t(o)
			: n(o)
	}
}
function I_(e) {
	let n = (e || {}).singleTilde
	const r = { name: "strikethrough", tokenize: o, resolveAll: i }
	return n == null && (n = !0), { text: { 126: r }, insideSpan: { null: [r] }, attentionMarkers: { null: [126] } }
	function i(s, a) {
		let l = -1
		for (; ++l < s.length; )
			if (s[l][0] === "enter" && s[l][1].type === "strikethroughSequenceTemporary" && s[l][1]._close) {
				let u = l
				for (; u--; )
					if (
						s[u][0] === "exit" &&
						s[u][1].type === "strikethroughSequenceTemporary" &&
						s[u][1]._open &&
						s[l][1].end.offset - s[l][1].start.offset === s[u][1].end.offset - s[u][1].start.offset
					) {
						;(s[l][1].type = "strikethroughSequence"), (s[u][1].type = "strikethroughSequence")
						const m = {
								type: "strikethrough",
								start: Object.assign({}, s[u][1].start),
								end: Object.assign({}, s[l][1].end),
							},
							c = {
								type: "strikethroughText",
								start: Object.assign({}, s[u][1].end),
								end: Object.assign({}, s[l][1].start),
							},
							h = [
								["enter", m, a],
								["enter", s[u][1], a],
								["exit", s[u][1], a],
								["enter", c, a],
							],
							p = a.parser.constructs.insideSpan.null
						p && Je(h, h.length, 0, Dr(p, s.slice(u + 1, l), a)),
							Je(h, h.length, 0, [
								["exit", c, a],
								["enter", s[l][1], a],
								["exit", s[l][1], a],
								["exit", m, a],
							]),
							Je(s, u - 1, l - u + 3, h),
							(l = u + h.length - 2)
						break
					}
			}
		for (l = -1; ++l < s.length; ) s[l][1].type === "strikethroughSequenceTemporary" && (s[l][1].type = "data")
		return s
	}
	function o(s, a, l) {
		const u = this.previous,
			m = this.events
		let c = 0
		return h
		function h(f) {
			return u === 126 && m[m.length - 1][1].type !== "characterEscape"
				? l(f)
				: (s.enter("strikethroughSequenceTemporary"), p(f))
		}
		function p(f) {
			const y = en(u)
			if (f === 126) return c > 1 ? l(f) : (s.consume(f), c++, p)
			if (c < 2 && !n) return l(f)
			const x = s.exit("strikethroughSequenceTemporary"),
				d = en(f)
			return (x._open = !d || (d === 2 && !!y)), (x._close = !y || (y === 2 && !!d)), a(f)
		}
	}
}
class T_ {
	constructor() {
		this.map = []
	}
	add(t, n, r) {
		C_(this, t, n, r)
	}
	consume(t) {
		if (
			(this.map.sort(function (o, s) {
				return o[0] - s[0]
			}),
			this.map.length === 0)
		)
			return
		let n = this.map.length
		const r = []
		for (; n > 0; )
			(n -= 1), r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), (t.length = this.map[n][0])
		r.push(t.slice()), (t.length = 0)
		let i = r.pop()
		for (; i; ) {
			for (const o of i) t.push(o)
			i = r.pop()
		}
		this.map.length = 0
	}
}
function C_(e, t, n, r) {
	let i = 0
	if (!(n === 0 && r.length === 0)) {
		for (; i < e.map.length; ) {
			if (e.map[i][0] === t) {
				;(e.map[i][1] += n), e.map[i][2].push(...r)
				return
			}
			i += 1
		}
		e.map.push([t, n, r])
	}
}
function A_(e, t) {
	let n = !1
	const r = []
	for (; t < e.length; ) {
		const i = e[t]
		if (n) {
			if (i[0] === "enter")
				i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none")
			else if (i[1].type === "tableContent") {
				if (e[t - 1][1].type === "tableDelimiterMarker") {
					const o = r.length - 1
					r[o] = r[o] === "left" ? "center" : "right"
				}
			} else if (i[1].type === "tableDelimiterRow") break
		} else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0)
		t += 1
	}
	return r
}
function R_() {
	return { flow: { null: { name: "table", tokenize: L_, resolveAll: P_ } } }
}
function L_(e, t, n) {
	const r = this
	let i = 0,
		o = 0,
		s
	return a
	function a(v) {
		let L = r.events.length - 1
		for (; L > -1; ) {
			const C = r.events[L][1].type
			if (C === "lineEnding" || C === "linePrefix") L--
			else break
		}
		const M = L > -1 ? r.events[L][1].type : null,
			B = M === "tableHead" || M === "tableRow" ? b : l
		return B === b && r.parser.lazy[r.now().line] ? n(v) : B(v)
	}
	function l(v) {
		return e.enter("tableHead"), e.enter("tableRow"), u(v)
	}
	function u(v) {
		return v === 124 || ((s = !0), (o += 1)), m(v)
	}
	function m(v) {
		return v === null
			? n(v)
			: q(v)
				? o > 1
					? ((o = 0),
						(r.interrupt = !0),
						e.exit("tableRow"),
						e.enter("lineEnding"),
						e.consume(v),
						e.exit("lineEnding"),
						p)
					: n(v)
				: re(v)
					? oe(e, m, "whitespace")(v)
					: ((o += 1),
						s && ((s = !1), (i += 1)),
						v === 124
							? (e.enter("tableCellDivider"), e.consume(v), e.exit("tableCellDivider"), (s = !0), m)
							: (e.enter("data"), c(v)))
	}
	function c(v) {
		return v === null || v === 124 || fe(v) ? (e.exit("data"), m(v)) : (e.consume(v), v === 92 ? h : c)
	}
	function h(v) {
		return v === 92 || v === 124 ? (e.consume(v), c) : c(v)
	}
	function p(v) {
		return (
			(r.interrupt = !1),
			r.parser.lazy[r.now().line]
				? n(v)
				: (e.enter("tableDelimiterRow"),
					(s = !1),
					re(v)
						? oe(
								e,
								f,
								"linePrefix",
								r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
							)(v)
						: f(v))
		)
	}
	function f(v) {
		return v === 45 || v === 58
			? x(v)
			: v === 124
				? ((s = !0), e.enter("tableCellDivider"), e.consume(v), e.exit("tableCellDivider"), y)
				: S(v)
	}
	function y(v) {
		return re(v) ? oe(e, x, "whitespace")(v) : x(v)
	}
	function x(v) {
		return v === 58
			? ((o += 1), (s = !0), e.enter("tableDelimiterMarker"), e.consume(v), e.exit("tableDelimiterMarker"), d)
			: v === 45
				? ((o += 1), d(v))
				: v === null || q(v)
					? I(v)
					: S(v)
	}
	function d(v) {
		return v === 45 ? (e.enter("tableDelimiterFiller"), _(v)) : S(v)
	}
	function _(v) {
		return v === 45
			? (e.consume(v), _)
			: v === 58
				? ((s = !0),
					e.exit("tableDelimiterFiller"),
					e.enter("tableDelimiterMarker"),
					e.consume(v),
					e.exit("tableDelimiterMarker"),
					w)
				: (e.exit("tableDelimiterFiller"), w(v))
	}
	function w(v) {
		return re(v) ? oe(e, I, "whitespace")(v) : I(v)
	}
	function I(v) {
		return v === 124
			? f(v)
			: v === null || q(v)
				? !s || i !== o
					? S(v)
					: (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(v))
				: S(v)
	}
	function S(v) {
		return n(v)
	}
	function b(v) {
		return e.enter("tableRow"), T(v)
	}
	function T(v) {
		return v === 124
			? (e.enter("tableCellDivider"), e.consume(v), e.exit("tableCellDivider"), T)
			: v === null || q(v)
				? (e.exit("tableRow"), t(v))
				: re(v)
					? oe(e, T, "whitespace")(v)
					: (e.enter("data"), P(v))
	}
	function P(v) {
		return v === null || v === 124 || fe(v) ? (e.exit("data"), T(v)) : (e.consume(v), v === 92 ? z : P)
	}
	function z(v) {
		return v === 92 || v === 124 ? (e.consume(v), P) : P(v)
	}
}
function P_(e, t) {
	let n = -1,
		r = !0,
		i = 0,
		o = [0, 0, 0, 0],
		s = [0, 0, 0, 0],
		a = !1,
		l = 0,
		u,
		m,
		c
	const h = new T_()
	for (; ++n < e.length; ) {
		const p = e[n],
			f = p[1]
		p[0] === "enter"
			? f.type === "tableHead"
				? ((a = !1),
					l !== 0 && (Ms(h, t, l, u, m), (m = void 0), (l = 0)),
					(u = { type: "table", start: Object.assign({}, f.start), end: Object.assign({}, f.end) }),
					h.add(n, 0, [["enter", u, t]]))
				: f.type === "tableRow" || f.type === "tableDelimiterRow"
					? ((r = !0),
						(c = void 0),
						(o = [0, 0, 0, 0]),
						(s = [0, n + 1, 0, 0]),
						a &&
							((a = !1),
							(m = {
								type: "tableBody",
								start: Object.assign({}, f.start),
								end: Object.assign({}, f.end),
							}),
							h.add(n, 0, [["enter", m, t]])),
						(i = f.type === "tableDelimiterRow" ? 2 : m ? 3 : 1))
					: i && (f.type === "data" || f.type === "tableDelimiterMarker" || f.type === "tableDelimiterFiller")
						? ((r = !1),
							s[2] === 0 &&
								(o[1] !== 0 && ((s[0] = s[1]), (c = Yn(h, t, o, i, void 0, c)), (o = [0, 0, 0, 0])),
								(s[2] = n)))
						: f.type === "tableCellDivider" &&
							(r
								? (r = !1)
								: (o[1] !== 0 && ((s[0] = s[1]), (c = Yn(h, t, o, i, void 0, c))),
									(o = s),
									(s = [o[1], n, 0, 0])))
			: f.type === "tableHead"
				? ((a = !0), (l = n))
				: f.type === "tableRow" || f.type === "tableDelimiterRow"
					? ((l = n),
						o[1] !== 0
							? ((s[0] = s[1]), (c = Yn(h, t, o, i, n, c)))
							: s[1] !== 0 && (c = Yn(h, t, s, i, n, c)),
						(i = 0))
					: i &&
						(f.type === "data" || f.type === "tableDelimiterMarker" || f.type === "tableDelimiterFiller") &&
						(s[3] = n)
	}
	for (l !== 0 && Ms(h, t, l, u, m), h.consume(t.events), n = -1; ++n < t.events.length; ) {
		const p = t.events[n]
		p[0] === "enter" && p[1].type === "table" && (p[1]._align = A_(t.events, n))
	}
	return e
}
function Yn(e, t, n, r, i, o) {
	const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData",
		a = "tableContent"
	n[0] !== 0 && ((o.end = Object.assign({}, Kt(t.events, n[0]))), e.add(n[0], 0, [["exit", o, t]]))
	const l = Kt(t.events, n[1])
	if (
		((o = { type: s, start: Object.assign({}, l), end: Object.assign({}, l) }),
		e.add(n[1], 0, [["enter", o, t]]),
		n[2] !== 0)
	) {
		const u = Kt(t.events, n[2]),
			m = Kt(t.events, n[3]),
			c = { type: a, start: Object.assign({}, u), end: Object.assign({}, m) }
		if ((e.add(n[2], 0, [["enter", c, t]]), r !== 2)) {
			const h = t.events[n[2]],
				p = t.events[n[3]]
			if (
				((h[1].end = Object.assign({}, p[1].end)),
				(h[1].type = "chunkText"),
				(h[1].contentType = "text"),
				n[3] > n[2] + 1)
			) {
				const f = n[2] + 1,
					y = n[3] - n[2] - 1
				e.add(f, y, [])
			}
		}
		e.add(n[3] + 1, 0, [["exit", c, t]])
	}
	return (
		i !== void 0 && ((o.end = Object.assign({}, Kt(t.events, i))), e.add(i, 0, [["exit", o, t]]), (o = void 0)), o
	)
}
function Ms(e, t, n, r, i) {
	const o = [],
		s = Kt(t.events, n)
	i && ((i.end = Object.assign({}, s)), o.push(["exit", i, t])),
		(r.end = Object.assign({}, s)),
		o.push(["exit", r, t]),
		e.add(n + 1, 0, o)
}
function Kt(e, t) {
	const n = e[t],
		r = n[0] === "enter" ? "start" : "end"
	return n[1][r]
}
const O_ = { name: "tasklistCheck", tokenize: N_ }
function D_() {
	return { text: { 91: O_ } }
}
function N_(e, t, n) {
	const r = this
	return i
	function i(l) {
		return r.previous !== null || !r._gfmTasklistFirstContentOfListItem
			? n(l)
			: (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), o)
	}
	function o(l) {
		return fe(l)
			? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), s)
			: l === 88 || l === 120
				? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), s)
				: n(l)
	}
	function s(l) {
		return l === 93
			? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), a)
			: n(l)
	}
	function a(l) {
		return q(l) ? t(l) : re(l) ? e.check({ tokenize: M_ }, t, n)(l) : n(l)
	}
}
function M_(e, t, n) {
	return oe(e, r, "whitespace")
	function r(i) {
		return i === null ? n(i) : t(i)
	}
}
function z_(e) {
	return sl([l_(), y_(), I_(e), R_(), D_()])
}
const V_ = {}
function B_(e) {
	const t = this,
		n = e || V_,
		r = t.data(),
		i = r.micromarkExtensions || (r.micromarkExtensions = []),
		o = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []),
		s = r.toMarkdownExtensions || (r.toMarkdownExtensions = [])
	i.push(z_(n)), o.push(i_()), s.push(o_(n))
}
let Re = class extends Error {
	constructor(t) {
		super(t), (this.name = "ShikiError")
	}
}
function F_(e) {
	return _o(e)
}
function _o(e) {
	return Array.isArray(e) ? j_(e) : e instanceof RegExp ? e : typeof e == "object" ? H_(e) : e
}
function j_(e) {
	let t = []
	for (let n = 0, r = e.length; n < r; n++) t[n] = _o(e[n])
	return t
}
function H_(e) {
	let t = {}
	for (let n in e) t[n] = _o(e[n])
	return t
}
function Xl(e, ...t) {
	return (
		t.forEach((n) => {
			for (let r in n) e[r] = n[r]
		}),
		e
	)
}
function Ql(e) {
	const t = ~e.lastIndexOf("/") || ~e.lastIndexOf("\\")
	return t === 0 ? e : ~t === e.length - 1 ? Ql(e.substring(0, e.length - 1)) : e.substr(~t + 1)
}
var ci = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g,
	Xn = class {
		static hasCaptures(e) {
			return e === null ? !1 : ((ci.lastIndex = 0), ci.test(e))
		}
		static replaceCaptures(e, t, n) {
			return e.replace(ci, (r, i, o, s) => {
				let a = n[parseInt(i || o, 10)]
				if (a) {
					let l = t.substring(a.start, a.end)
					for (; l[0] === "."; ) l = l.substring(1)
					switch (s) {
						case "downcase":
							return l.toLowerCase()
						case "upcase":
							return l.toUpperCase()
						default:
							return l
					}
				} else return r
			})
		}
	}
function Jl(e, t) {
	return e < t ? -1 : e > t ? 1 : 0
}
function Zl(e, t) {
	if (e === null && t === null) return 0
	if (!e) return -1
	if (!t) return 1
	let n = e.length,
		r = t.length
	if (n === r) {
		for (let i = 0; i < n; i++) {
			let o = Jl(e[i], t[i])
			if (o !== 0) return o
		}
		return 0
	}
	return n - r
}
function zs(e) {
	return !!(
		/^#[0-9a-f]{6}$/i.test(e) ||
		/^#[0-9a-f]{8}$/i.test(e) ||
		/^#[0-9a-f]{3}$/i.test(e) ||
		/^#[0-9a-f]{4}$/i.test(e)
	)
}
function eu(e) {
	return e.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&")
}
var tu = class {
		constructor(e) {
			R(this, "cache", new Map())
			this.fn = e
		}
		get(e) {
			if (this.cache.has(e)) return this.cache.get(e)
			const t = this.fn(e)
			return this.cache.set(e, t), t
		}
	},
	dr = class {
		constructor(e, t, n) {
			R(this, "_cachedMatchRoot", new tu((e) => this._root.match(e)))
			;(this._colorMap = e), (this._defaults = t), (this._root = n)
		}
		static createFromRawTheme(e, t) {
			return this.createFromParsedTheme(U_(e), t)
		}
		static createFromParsedTheme(e, t) {
			return W_(e, t)
		}
		getColorMap() {
			return this._colorMap.getColorMap()
		}
		getDefaults() {
			return this._defaults
		}
		match(e) {
			if (e === null) return this._defaults
			const t = e.scopeName,
				r = this._cachedMatchRoot.get(t).find((i) => G_(e.parent, i.parentScopes))
			return r ? new nu(r.fontStyle, r.foreground, r.background) : null
		}
	},
	mi = class ir {
		constructor(t, n) {
			;(this.parent = t), (this.scopeName = n)
		}
		static push(t, n) {
			for (const r of n) t = new ir(t, r)
			return t
		}
		static from(...t) {
			let n = null
			for (let r = 0; r < t.length; r++) n = new ir(n, t[r])
			return n
		}
		push(t) {
			return new ir(this, t)
		}
		getSegments() {
			let t = this
			const n = []
			for (; t; ) n.push(t.scopeName), (t = t.parent)
			return n.reverse(), n
		}
		toString() {
			return this.getSegments().join(" ")
		}
		extends(t) {
			return this === t ? !0 : this.parent === null ? !1 : this.parent.extends(t)
		}
		getExtensionIfDefined(t) {
			const n = []
			let r = this
			for (; r && r !== t; ) n.push(r.scopeName), (r = r.parent)
			return r === t ? n.reverse() : void 0
		}
	}
function G_(e, t) {
	if (t.length === 0) return !0
	for (let n = 0; n < t.length; n++) {
		let r = t[n],
			i = !1
		if (r === ">") {
			if (n === t.length - 1) return !1
			;(r = t[++n]), (i = !0)
		}
		for (; e && !$_(e.scopeName, r); ) {
			if (i) return !1
			e = e.parent
		}
		if (!e) return !1
		e = e.parent
	}
	return !0
}
function $_(e, t) {
	return t === e || (e.startsWith(t) && e[t.length] === ".")
}
var nu = class {
	constructor(e, t, n) {
		;(this.fontStyle = e), (this.foregroundId = t), (this.backgroundId = n)
	}
}
function U_(e) {
	if (!e) return []
	if (!e.settings || !Array.isArray(e.settings)) return []
	let t = e.settings,
		n = [],
		r = 0
	for (let i = 0, o = t.length; i < o; i++) {
		let s = t[i]
		if (!s.settings) continue
		let a
		if (typeof s.scope == "string") {
			let c = s.scope
			;(c = c.replace(/^[,]+/, "")), (c = c.replace(/[,]+$/, "")), (a = c.split(","))
		} else Array.isArray(s.scope) ? (a = s.scope) : (a = [""])
		let l = -1
		if (typeof s.settings.fontStyle == "string") {
			l = 0
			let c = s.settings.fontStyle.split(" ")
			for (let h = 0, p = c.length; h < p; h++)
				switch (c[h]) {
					case "italic":
						l = l | 1
						break
					case "bold":
						l = l | 2
						break
					case "underline":
						l = l | 4
						break
					case "strikethrough":
						l = l | 8
						break
				}
		}
		let u = null
		typeof s.settings.foreground == "string" && zs(s.settings.foreground) && (u = s.settings.foreground)
		let m = null
		typeof s.settings.background == "string" && zs(s.settings.background) && (m = s.settings.background)
		for (let c = 0, h = a.length; c < h; c++) {
			let f = a[c].trim().split(" "),
				y = f[f.length - 1],
				x = null
			f.length > 1 && ((x = f.slice(0, f.length - 1)), x.reverse()), (n[r++] = new q_(y, x, i, l, u, m))
		}
	}
	return n
}
var q_ = class {
		constructor(e, t, n, r, i, o) {
			;(this.scope = e),
				(this.parentScopes = t),
				(this.index = n),
				(this.fontStyle = r),
				(this.foreground = i),
				(this.background = o)
		}
	},
	Ne = ((e) => (
		(e[(e.NotSet = -1)] = "NotSet"),
		(e[(e.None = 0)] = "None"),
		(e[(e.Italic = 1)] = "Italic"),
		(e[(e.Bold = 2)] = "Bold"),
		(e[(e.Underline = 4)] = "Underline"),
		(e[(e.Strikethrough = 8)] = "Strikethrough"),
		e
	))(Ne || {})
function W_(e, t) {
	e.sort((l, u) => {
		let m = Jl(l.scope, u.scope)
		return m !== 0 || ((m = Zl(l.parentScopes, u.parentScopes)), m !== 0) ? m : l.index - u.index
	})
	let n = 0,
		r = "#000000",
		i = "#ffffff"
	for (; e.length >= 1 && e[0].scope === ""; ) {
		let l = e.shift()
		l.fontStyle !== -1 && (n = l.fontStyle),
			l.foreground !== null && (r = l.foreground),
			l.background !== null && (i = l.background)
	}
	let o = new K_(t),
		s = new nu(n, o.getId(r), o.getId(i)),
		a = new X_(new Di(0, null, -1, 0, 0), [])
	for (let l = 0, u = e.length; l < u; l++) {
		let m = e[l]
		a.insert(0, m.scope, m.parentScopes, m.fontStyle, o.getId(m.foreground), o.getId(m.background))
	}
	return new dr(o, s, a)
}
var K_ = class {
		constructor(e) {
			R(this, "_isFrozen")
			R(this, "_lastColorId")
			R(this, "_id2color")
			R(this, "_color2id")
			if (
				((this._lastColorId = 0),
				(this._id2color = []),
				(this._color2id = Object.create(null)),
				Array.isArray(e))
			) {
				this._isFrozen = !0
				for (let t = 0, n = e.length; t < n; t++) (this._color2id[e[t]] = t), (this._id2color[t] = e[t])
			} else this._isFrozen = !1
		}
		getId(e) {
			if (e === null) return 0
			e = e.toUpperCase()
			let t = this._color2id[e]
			if (t) return t
			if (this._isFrozen) throw new Error(`Missing color in color map - ${e}`)
			return (t = ++this._lastColorId), (this._color2id[e] = t), (this._id2color[t] = e), t
		}
		getColorMap() {
			return this._id2color.slice(0)
		}
	},
	Y_ = Object.freeze([]),
	Di = class ru {
		constructor(t, n, r, i, o) {
			R(this, "scopeDepth")
			R(this, "parentScopes")
			R(this, "fontStyle")
			R(this, "foreground")
			R(this, "background")
			;(this.scopeDepth = t),
				(this.parentScopes = n || Y_),
				(this.fontStyle = r),
				(this.foreground = i),
				(this.background = o)
		}
		clone() {
			return new ru(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background)
		}
		static cloneArr(t) {
			let n = []
			for (let r = 0, i = t.length; r < i; r++) n[r] = t[r].clone()
			return n
		}
		acceptOverwrite(t, n, r, i) {
			this.scopeDepth > t ? console.log("how did this happen?") : (this.scopeDepth = t),
				n !== -1 && (this.fontStyle = n),
				r !== 0 && (this.foreground = r),
				i !== 0 && (this.background = i)
		}
	},
	X_ = class Ni {
		constructor(t, n = [], r = {}) {
			R(this, "_rulesWithParentScopes")
			;(this._mainRule = t), (this._children = r), (this._rulesWithParentScopes = n)
		}
		static _cmpBySpecificity(t, n) {
			if (t.scopeDepth !== n.scopeDepth) return n.scopeDepth - t.scopeDepth
			let r = 0,
				i = 0
			for (
				;
				t.parentScopes[r] === ">" && r++,
					n.parentScopes[i] === ">" && i++,
					!(r >= t.parentScopes.length || i >= n.parentScopes.length);

			) {
				const o = n.parentScopes[i].length - t.parentScopes[r].length
				if (o !== 0) return o
				r++, i++
			}
			return n.parentScopes.length - t.parentScopes.length
		}
		match(t) {
			if (t !== "") {
				let r = t.indexOf("."),
					i,
					o
				if (
					(r === -1 ? ((i = t), (o = "")) : ((i = t.substring(0, r)), (o = t.substring(r + 1))),
					this._children.hasOwnProperty(i))
				)
					return this._children[i].match(o)
			}
			const n = this._rulesWithParentScopes.concat(this._mainRule)
			return n.sort(Ni._cmpBySpecificity), n
		}
		insert(t, n, r, i, o, s) {
			if (n === "") {
				this._doInsertHere(t, r, i, o, s)
				return
			}
			let a = n.indexOf("."),
				l,
				u
			a === -1 ? ((l = n), (u = "")) : ((l = n.substring(0, a)), (u = n.substring(a + 1)))
			let m
			this._children.hasOwnProperty(l)
				? (m = this._children[l])
				: ((m = new Ni(this._mainRule.clone(), Di.cloneArr(this._rulesWithParentScopes))),
					(this._children[l] = m)),
				m.insert(t + 1, u, r, i, o, s)
		}
		_doInsertHere(t, n, r, i, o) {
			if (n === null) {
				this._mainRule.acceptOverwrite(t, r, i, o)
				return
			}
			for (let s = 0, a = this._rulesWithParentScopes.length; s < a; s++) {
				let l = this._rulesWithParentScopes[s]
				if (Zl(l.parentScopes, n) === 0) {
					l.acceptOverwrite(t, r, i, o)
					return
				}
			}
			r === -1 && (r = this._mainRule.fontStyle),
				i === 0 && (i = this._mainRule.foreground),
				o === 0 && (o = this._mainRule.background),
				this._rulesWithParentScopes.push(new Di(t, n, r, i, o))
		}
	},
	tn = class Ze {
		static toBinaryStr(t) {
			return t.toString(2).padStart(32, "0")
		}
		static print(t) {
			const n = Ze.getLanguageId(t),
				r = Ze.getTokenType(t),
				i = Ze.getFontStyle(t),
				o = Ze.getForeground(t),
				s = Ze.getBackground(t)
			console.log({ languageId: n, tokenType: r, fontStyle: i, foreground: o, background: s })
		}
		static getLanguageId(t) {
			return (t & 255) >>> 0
		}
		static getTokenType(t) {
			return (t & 768) >>> 8
		}
		static containsBalancedBrackets(t) {
			return (t & 1024) !== 0
		}
		static getFontStyle(t) {
			return (t & 30720) >>> 11
		}
		static getForeground(t) {
			return (t & 16744448) >>> 15
		}
		static getBackground(t) {
			return (t & 4278190080) >>> 24
		}
		static set(t, n, r, i, o, s, a) {
			let l = Ze.getLanguageId(t),
				u = Ze.getTokenType(t),
				m = Ze.containsBalancedBrackets(t) ? 1 : 0,
				c = Ze.getFontStyle(t),
				h = Ze.getForeground(t),
				p = Ze.getBackground(t)
			return (
				n !== 0 && (l = n),
				r !== 8 && (u = r),
				i !== null && (m = i ? 1 : 0),
				o !== -1 && (c = o),
				s !== 0 && (h = s),
				a !== 0 && (p = a),
				((l << 0) | (u << 8) | (m << 10) | (c << 11) | (h << 15) | (p << 24)) >>> 0
			)
		}
	}
function gr(e, t) {
	const n = [],
		r = Q_(e)
	let i = r.next()
	for (; i !== null; ) {
		let l = 0
		if (i.length === 2 && i.charAt(1) === ":") {
			switch (i.charAt(0)) {
				case "R":
					l = 1
					break
				case "L":
					l = -1
					break
				default:
					console.log(`Unknown priority ${i} in scope selector`)
			}
			i = r.next()
		}
		let u = s()
		if ((n.push({ matcher: u, priority: l }), i !== ",")) break
		i = r.next()
	}
	return n
	function o() {
		if (i === "-") {
			i = r.next()
			const l = o()
			return (u) => !!l && !l(u)
		}
		if (i === "(") {
			i = r.next()
			const l = a()
			return i === ")" && (i = r.next()), l
		}
		if (Vs(i)) {
			const l = []
			do l.push(i), (i = r.next())
			while (Vs(i))
			return (u) => t(l, u)
		}
		return null
	}
	function s() {
		const l = []
		let u = o()
		for (; u; ) l.push(u), (u = o())
		return (m) => l.every((c) => c(m))
	}
	function a() {
		const l = []
		let u = s()
		for (; u && (l.push(u), i === "|" || i === ","); ) {
			do i = r.next()
			while (i === "|" || i === ",")
			u = s()
		}
		return (m) => l.some((c) => c(m))
	}
}
function Vs(e) {
	return !!e && !!e.match(/[\w\.:]+/)
}
function Q_(e) {
	let t = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g,
		n = t.exec(e)
	return {
		next: () => {
			if (!n) return null
			const r = n[0]
			return (n = t.exec(e)), r
		},
	}
}
function iu(e) {
	typeof e.dispose == "function" && e.dispose()
}
var Rn = class {
		constructor(e) {
			this.scopeName = e
		}
		toKey() {
			return this.scopeName
		}
	},
	J_ = class {
		constructor(e, t) {
			;(this.scopeName = e), (this.ruleName = t)
		}
		toKey() {
			return `${this.scopeName}#${this.ruleName}`
		}
	},
	Z_ = class {
		constructor() {
			R(this, "_references", [])
			R(this, "_seenReferenceKeys", new Set())
			R(this, "visitedRule", new Set())
		}
		get references() {
			return this._references
		}
		add(e) {
			const t = e.toKey()
			this._seenReferenceKeys.has(t) || (this._seenReferenceKeys.add(t), this._references.push(e))
		}
	},
	ey = class {
		constructor(e, t) {
			R(this, "seenFullScopeRequests", new Set())
			R(this, "seenPartialScopeRequests", new Set())
			R(this, "Q")
			;(this.repo = e),
				(this.initialScopeName = t),
				this.seenFullScopeRequests.add(this.initialScopeName),
				(this.Q = [new Rn(this.initialScopeName)])
		}
		processQueue() {
			const e = this.Q
			this.Q = []
			const t = new Z_()
			for (const n of e) ty(n, this.initialScopeName, this.repo, t)
			for (const n of t.references)
				if (n instanceof Rn) {
					if (this.seenFullScopeRequests.has(n.scopeName)) continue
					this.seenFullScopeRequests.add(n.scopeName), this.Q.push(n)
				} else {
					if (this.seenFullScopeRequests.has(n.scopeName) || this.seenPartialScopeRequests.has(n.toKey()))
						continue
					this.seenPartialScopeRequests.add(n.toKey()), this.Q.push(n)
				}
		}
	}
function ty(e, t, n, r) {
	const i = n.lookup(e.scopeName)
	if (!i) {
		if (e.scopeName === t) throw new Error(`No grammar provided for <${t}>`)
		return
	}
	const o = n.lookup(t)
	e instanceof Rn
		? or({ baseGrammar: o, selfGrammar: i }, r)
		: Mi(e.ruleName, { baseGrammar: o, selfGrammar: i, repository: i.repository }, r)
	const s = n.injections(e.scopeName)
	if (s) for (const a of s) r.add(new Rn(a))
}
function Mi(e, t, n) {
	if (t.repository && t.repository[e]) {
		const r = t.repository[e]
		_r([r], t, n)
	}
}
function or(e, t) {
	e.selfGrammar.patterns &&
		Array.isArray(e.selfGrammar.patterns) &&
		_r(e.selfGrammar.patterns, { ...e, repository: e.selfGrammar.repository }, t),
		e.selfGrammar.injections &&
			_r(Object.values(e.selfGrammar.injections), { ...e, repository: e.selfGrammar.repository }, t)
}
function _r(e, t, n) {
	for (const r of e) {
		if (n.visitedRule.has(r)) continue
		n.visitedRule.add(r)
		const i = r.repository ? Xl({}, t.repository, r.repository) : t.repository
		Array.isArray(r.patterns) && _r(r.patterns, { ...t, repository: i }, n)
		const o = r.include
		if (!o) continue
		const s = ou(o)
		switch (s.kind) {
			case 0:
				or({ ...t, selfGrammar: t.baseGrammar }, n)
				break
			case 1:
				or(t, n)
				break
			case 2:
				Mi(s.ruleName, { ...t, repository: i }, n)
				break
			case 3:
			case 4:
				const a =
					s.scopeName === t.selfGrammar.scopeName
						? t.selfGrammar
						: s.scopeName === t.baseGrammar.scopeName
							? t.baseGrammar
							: void 0
				if (a) {
					const l = { baseGrammar: t.baseGrammar, selfGrammar: a, repository: i }
					s.kind === 4 ? Mi(s.ruleName, l, n) : or(l, n)
				} else s.kind === 4 ? n.add(new J_(s.scopeName, s.ruleName)) : n.add(new Rn(s.scopeName))
				break
		}
	}
}
var ny = class {
		constructor() {
			R(this, "kind", 0)
		}
	},
	ry = class {
		constructor() {
			R(this, "kind", 1)
		}
	},
	iy = class {
		constructor(e) {
			R(this, "kind", 2)
			this.ruleName = e
		}
	},
	oy = class {
		constructor(e) {
			R(this, "kind", 3)
			this.scopeName = e
		}
	},
	sy = class {
		constructor(e, t) {
			R(this, "kind", 4)
			;(this.scopeName = e), (this.ruleName = t)
		}
	}
function ou(e) {
	if (e === "$base") return new ny()
	if (e === "$self") return new ry()
	const t = e.indexOf("#")
	if (t === -1) return new oy(e)
	if (t === 0) return new iy(e.substring(1))
	{
		const n = e.substring(0, t),
			r = e.substring(t + 1)
		return new sy(n, r)
	}
}
var ay = /\\(\d+)/,
	Bs = /\\(\d+)/g,
	ly = -1,
	su = -2
var Hn = class {
		constructor(e, t, n, r) {
			R(this, "$location")
			R(this, "id")
			R(this, "_nameIsCapturing")
			R(this, "_name")
			R(this, "_contentNameIsCapturing")
			R(this, "_contentName")
			;(this.$location = e),
				(this.id = t),
				(this._name = n || null),
				(this._nameIsCapturing = Xn.hasCaptures(this._name)),
				(this._contentName = r || null),
				(this._contentNameIsCapturing = Xn.hasCaptures(this._contentName))
		}
		get debugName() {
			const e = this.$location ? `${Ql(this.$location.filename)}:${this.$location.line}` : "unknown"
			return `${this.constructor.name}#${this.id} @ ${e}`
		}
		getName(e, t) {
			return !this._nameIsCapturing || this._name === null || e === null || t === null
				? this._name
				: Xn.replaceCaptures(this._name, e, t)
		}
		getContentName(e, t) {
			return !this._contentNameIsCapturing || this._contentName === null
				? this._contentName
				: Xn.replaceCaptures(this._contentName, e, t)
		}
	},
	uy = class extends Hn {
		constructor(t, n, r, i, o) {
			super(t, n, r, i)
			R(this, "retokenizeCapturedWithRuleId")
			this.retokenizeCapturedWithRuleId = o
		}
		dispose() {}
		collectPatterns(t, n) {
			throw new Error("Not supported!")
		}
		compile(t, n) {
			throw new Error("Not supported!")
		}
		compileAG(t, n, r, i) {
			throw new Error("Not supported!")
		}
	},
	cy = class extends Hn {
		constructor(t, n, r, i, o) {
			super(t, n, r, null)
			R(this, "_match")
			R(this, "captures")
			R(this, "_cachedCompiledPatterns")
			;(this._match = new Ln(i, this.id)), (this.captures = o), (this._cachedCompiledPatterns = null)
		}
		dispose() {
			this._cachedCompiledPatterns &&
				(this._cachedCompiledPatterns.dispose(), (this._cachedCompiledPatterns = null))
		}
		get debugMatchRegExp() {
			return `${this._match.source}`
		}
		collectPatterns(t, n) {
			n.push(this._match)
		}
		compile(t, n) {
			return this._getCachedCompiledPatterns(t).compile(t)
		}
		compileAG(t, n, r, i) {
			return this._getCachedCompiledPatterns(t).compileAG(t, r, i)
		}
		_getCachedCompiledPatterns(t) {
			return (
				this._cachedCompiledPatterns ||
					((this._cachedCompiledPatterns = new Pn()), this.collectPatterns(t, this._cachedCompiledPatterns)),
				this._cachedCompiledPatterns
			)
		}
	},
	Fs = class extends Hn {
		constructor(t, n, r, i, o) {
			super(t, n, r, i)
			R(this, "hasMissingPatterns")
			R(this, "patterns")
			R(this, "_cachedCompiledPatterns")
			;(this.patterns = o.patterns),
				(this.hasMissingPatterns = o.hasMissingPatterns),
				(this._cachedCompiledPatterns = null)
		}
		dispose() {
			this._cachedCompiledPatterns &&
				(this._cachedCompiledPatterns.dispose(), (this._cachedCompiledPatterns = null))
		}
		collectPatterns(t, n) {
			for (const r of this.patterns) t.getRule(r).collectPatterns(t, n)
		}
		compile(t, n) {
			return this._getCachedCompiledPatterns(t).compile(t)
		}
		compileAG(t, n, r, i) {
			return this._getCachedCompiledPatterns(t).compileAG(t, r, i)
		}
		_getCachedCompiledPatterns(t) {
			return (
				this._cachedCompiledPatterns ||
					((this._cachedCompiledPatterns = new Pn()), this.collectPatterns(t, this._cachedCompiledPatterns)),
				this._cachedCompiledPatterns
			)
		}
	},
	zi = class extends Hn {
		constructor(t, n, r, i, o, s, a, l, u, m) {
			super(t, n, r, i)
			R(this, "_begin")
			R(this, "beginCaptures")
			R(this, "_end")
			R(this, "endHasBackReferences")
			R(this, "endCaptures")
			R(this, "applyEndPatternLast")
			R(this, "hasMissingPatterns")
			R(this, "patterns")
			R(this, "_cachedCompiledPatterns")
			;(this._begin = new Ln(o, this.id)),
				(this.beginCaptures = s),
				(this._end = new Ln(a || "￿", -1)),
				(this.endHasBackReferences = this._end.hasBackReferences),
				(this.endCaptures = l),
				(this.applyEndPatternLast = u || !1),
				(this.patterns = m.patterns),
				(this.hasMissingPatterns = m.hasMissingPatterns),
				(this._cachedCompiledPatterns = null)
		}
		dispose() {
			this._cachedCompiledPatterns &&
				(this._cachedCompiledPatterns.dispose(), (this._cachedCompiledPatterns = null))
		}
		get debugBeginRegExp() {
			return `${this._begin.source}`
		}
		get debugEndRegExp() {
			return `${this._end.source}`
		}
		getEndWithResolvedBackReferences(t, n) {
			return this._end.resolveBackReferences(t, n)
		}
		collectPatterns(t, n) {
			n.push(this._begin)
		}
		compile(t, n) {
			return this._getCachedCompiledPatterns(t, n).compile(t)
		}
		compileAG(t, n, r, i) {
			return this._getCachedCompiledPatterns(t, n).compileAG(t, r, i)
		}
		_getCachedCompiledPatterns(t, n) {
			if (!this._cachedCompiledPatterns) {
				this._cachedCompiledPatterns = new Pn()
				for (const r of this.patterns) t.getRule(r).collectPatterns(t, this._cachedCompiledPatterns)
				this.applyEndPatternLast
					? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end)
					: this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end)
			}
			return (
				this._end.hasBackReferences &&
					(this.applyEndPatternLast
						? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, n)
						: this._cachedCompiledPatterns.setSource(0, n)),
				this._cachedCompiledPatterns
			)
		}
	},
	yr = class extends Hn {
		constructor(t, n, r, i, o, s, a, l, u) {
			super(t, n, r, i)
			R(this, "_begin")
			R(this, "beginCaptures")
			R(this, "whileCaptures")
			R(this, "_while")
			R(this, "whileHasBackReferences")
			R(this, "hasMissingPatterns")
			R(this, "patterns")
			R(this, "_cachedCompiledPatterns")
			R(this, "_cachedCompiledWhilePatterns")
			;(this._begin = new Ln(o, this.id)),
				(this.beginCaptures = s),
				(this.whileCaptures = l),
				(this._while = new Ln(a, su)),
				(this.whileHasBackReferences = this._while.hasBackReferences),
				(this.patterns = u.patterns),
				(this.hasMissingPatterns = u.hasMissingPatterns),
				(this._cachedCompiledPatterns = null),
				(this._cachedCompiledWhilePatterns = null)
		}
		dispose() {
			this._cachedCompiledPatterns &&
				(this._cachedCompiledPatterns.dispose(), (this._cachedCompiledPatterns = null)),
				this._cachedCompiledWhilePatterns &&
					(this._cachedCompiledWhilePatterns.dispose(), (this._cachedCompiledWhilePatterns = null))
		}
		get debugBeginRegExp() {
			return `${this._begin.source}`
		}
		get debugWhileRegExp() {
			return `${this._while.source}`
		}
		getWhileWithResolvedBackReferences(t, n) {
			return this._while.resolveBackReferences(t, n)
		}
		collectPatterns(t, n) {
			n.push(this._begin)
		}
		compile(t, n) {
			return this._getCachedCompiledPatterns(t).compile(t)
		}
		compileAG(t, n, r, i) {
			return this._getCachedCompiledPatterns(t).compileAG(t, r, i)
		}
		_getCachedCompiledPatterns(t) {
			if (!this._cachedCompiledPatterns) {
				this._cachedCompiledPatterns = new Pn()
				for (const n of this.patterns) t.getRule(n).collectPatterns(t, this._cachedCompiledPatterns)
			}
			return this._cachedCompiledPatterns
		}
		compileWhile(t, n) {
			return this._getCachedCompiledWhilePatterns(t, n).compile(t)
		}
		compileWhileAG(t, n, r, i) {
			return this._getCachedCompiledWhilePatterns(t, n).compileAG(t, r, i)
		}
		_getCachedCompiledWhilePatterns(t, n) {
			return (
				this._cachedCompiledWhilePatterns ||
					((this._cachedCompiledWhilePatterns = new Pn()),
					this._cachedCompiledWhilePatterns.push(
						this._while.hasBackReferences ? this._while.clone() : this._while,
					)),
				this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, n || "￿"),
				this._cachedCompiledWhilePatterns
			)
		}
	},
	au = class De {
		static createCaptureRule(t, n, r, i, o) {
			return t.registerRule((s) => new uy(n, s, r, i, o))
		}
		static getCompiledRuleId(t, n, r) {
			return (
				t.id ||
					n.registerRule((i) => {
						if (((t.id = i), t.match))
							return new cy(
								t.$vscodeTextmateLocation,
								t.id,
								t.name,
								t.match,
								De._compileCaptures(t.captures, n, r),
							)
						if (typeof t.begin > "u") {
							t.repository && (r = Xl({}, r, t.repository))
							let o = t.patterns
							return (
								typeof o > "u" && t.include && (o = [{ include: t.include }]),
								new Fs(
									t.$vscodeTextmateLocation,
									t.id,
									t.name,
									t.contentName,
									De._compilePatterns(o, n, r),
								)
							)
						}
						return t.while
							? new yr(
									t.$vscodeTextmateLocation,
									t.id,
									t.name,
									t.contentName,
									t.begin,
									De._compileCaptures(t.beginCaptures || t.captures, n, r),
									t.while,
									De._compileCaptures(t.whileCaptures || t.captures, n, r),
									De._compilePatterns(t.patterns, n, r),
								)
							: new zi(
									t.$vscodeTextmateLocation,
									t.id,
									t.name,
									t.contentName,
									t.begin,
									De._compileCaptures(t.beginCaptures || t.captures, n, r),
									t.end,
									De._compileCaptures(t.endCaptures || t.captures, n, r),
									t.applyEndPatternLast,
									De._compilePatterns(t.patterns, n, r),
								)
					}),
				t.id
			)
		}
		static _compileCaptures(t, n, r) {
			let i = []
			if (t) {
				let o = 0
				for (const s in t) {
					if (s === "$vscodeTextmateLocation") continue
					const a = parseInt(s, 10)
					a > o && (o = a)
				}
				for (let s = 0; s <= o; s++) i[s] = null
				for (const s in t) {
					if (s === "$vscodeTextmateLocation") continue
					const a = parseInt(s, 10)
					let l = 0
					t[s].patterns && (l = De.getCompiledRuleId(t[s], n, r)),
						(i[a] = De.createCaptureRule(n, t[s].$vscodeTextmateLocation, t[s].name, t[s].contentName, l))
				}
			}
			return i
		}
		static _compilePatterns(t, n, r) {
			let i = []
			if (t)
				for (let o = 0, s = t.length; o < s; o++) {
					const a = t[o]
					let l = -1
					if (a.include) {
						const u = ou(a.include)
						switch (u.kind) {
							case 0:
							case 1:
								l = De.getCompiledRuleId(r[a.include], n, r)
								break
							case 2:
								let m = r[u.ruleName]
								m && (l = De.getCompiledRuleId(m, n, r))
								break
							case 3:
							case 4:
								const c = u.scopeName,
									h = u.kind === 4 ? u.ruleName : null,
									p = n.getExternalGrammar(c, r)
								if (p)
									if (h) {
										let f = p.repository[h]
										f && (l = De.getCompiledRuleId(f, n, p.repository))
									} else l = De.getCompiledRuleId(p.repository.$self, n, p.repository)
								break
						}
					} else l = De.getCompiledRuleId(a, n, r)
					if (l !== -1) {
						const u = n.getRule(l)
						let m = !1
						if (
							((u instanceof Fs || u instanceof zi || u instanceof yr) &&
								u.hasMissingPatterns &&
								u.patterns.length === 0 &&
								(m = !0),
							m)
						)
							continue
						i.push(l)
					}
				}
			return { patterns: i, hasMissingPatterns: (t ? t.length : 0) !== i.length }
		}
	},
	Ln = class lu {
		constructor(t, n) {
			R(this, "source")
			R(this, "ruleId")
			R(this, "hasAnchor")
			R(this, "hasBackReferences")
			R(this, "_anchorCache")
			if (t && typeof t == "string") {
				const r = t.length
				let i = 0,
					o = [],
					s = !1
				for (let a = 0; a < r; a++)
					if (t.charAt(a) === "\\" && a + 1 < r) {
						const u = t.charAt(a + 1)
						u === "z"
							? (o.push(t.substring(i, a)), o.push("$(?!\\n)(?<!\\n)"), (i = a + 2))
							: (u === "A" || u === "G") && (s = !0),
							a++
					}
				;(this.hasAnchor = s),
					i === 0 ? (this.source = t) : (o.push(t.substring(i, r)), (this.source = o.join("")))
			} else (this.hasAnchor = !1), (this.source = t)
			this.hasAnchor ? (this._anchorCache = this._buildAnchorCache()) : (this._anchorCache = null),
				(this.ruleId = n),
				typeof this.source == "string"
					? (this.hasBackReferences = ay.test(this.source))
					: (this.hasBackReferences = !1)
		}
		clone() {
			return new lu(this.source, this.ruleId)
		}
		setSource(t) {
			this.source !== t && ((this.source = t), this.hasAnchor && (this._anchorCache = this._buildAnchorCache()))
		}
		resolveBackReferences(t, n) {
			if (typeof this.source != "string")
				throw new Error("This method should only be called if the source is a string")
			let r = n.map((i) => t.substring(i.start, i.end))
			return (Bs.lastIndex = 0), this.source.replace(Bs, (i, o) => eu(r[parseInt(o, 10)] || ""))
		}
		_buildAnchorCache() {
			if (typeof this.source != "string")
				throw new Error("This method should only be called if the source is a string")
			let t = [],
				n = [],
				r = [],
				i = [],
				o,
				s,
				a,
				l
			for (o = 0, s = this.source.length; o < s; o++)
				(a = this.source.charAt(o)),
					(t[o] = a),
					(n[o] = a),
					(r[o] = a),
					(i[o] = a),
					a === "\\" &&
						o + 1 < s &&
						((l = this.source.charAt(o + 1)),
						l === "A"
							? ((t[o + 1] = "￿"), (n[o + 1] = "￿"), (r[o + 1] = "A"), (i[o + 1] = "A"))
							: l === "G"
								? ((t[o + 1] = "￿"), (n[o + 1] = "G"), (r[o + 1] = "￿"), (i[o + 1] = "G"))
								: ((t[o + 1] = l), (n[o + 1] = l), (r[o + 1] = l), (i[o + 1] = l)),
						o++)
			return { A0_G0: t.join(""), A0_G1: n.join(""), A1_G0: r.join(""), A1_G1: i.join("") }
		}
		resolveAnchors(t, n) {
			return !this.hasAnchor || !this._anchorCache || typeof this.source != "string"
				? this.source
				: t
					? n
						? this._anchorCache.A1_G1
						: this._anchorCache.A1_G0
					: n
						? this._anchorCache.A0_G1
						: this._anchorCache.A0_G0
		}
	},
	Pn = class {
		constructor() {
			R(this, "_items")
			R(this, "_hasAnchors")
			R(this, "_cached")
			R(this, "_anchorCache")
			;(this._items = []),
				(this._hasAnchors = !1),
				(this._cached = null),
				(this._anchorCache = { A0_G0: null, A0_G1: null, A1_G0: null, A1_G1: null })
		}
		dispose() {
			this._disposeCaches()
		}
		_disposeCaches() {
			this._cached && (this._cached.dispose(), (this._cached = null)),
				this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), (this._anchorCache.A0_G0 = null)),
				this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), (this._anchorCache.A0_G1 = null)),
				this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), (this._anchorCache.A1_G0 = null)),
				this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), (this._anchorCache.A1_G1 = null))
		}
		push(e) {
			this._items.push(e), (this._hasAnchors = this._hasAnchors || e.hasAnchor)
		}
		unshift(e) {
			this._items.unshift(e), (this._hasAnchors = this._hasAnchors || e.hasAnchor)
		}
		length() {
			return this._items.length
		}
		setSource(e, t) {
			this._items[e].source !== t && (this._disposeCaches(), this._items[e].setSource(t))
		}
		compile(e) {
			if (!this._cached) {
				let t = this._items.map((n) => n.source)
				this._cached = new js(
					e,
					t,
					this._items.map((n) => n.ruleId),
				)
			}
			return this._cached
		}
		compileAG(e, t, n) {
			return this._hasAnchors
				? t
					? n
						? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(e, t, n)),
							this._anchorCache.A1_G1)
						: (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(e, t, n)),
							this._anchorCache.A1_G0)
					: n
						? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(e, t, n)),
							this._anchorCache.A0_G1)
						: (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(e, t, n)),
							this._anchorCache.A0_G0)
				: this.compile(e)
		}
		_resolveAnchors(e, t, n) {
			let r = this._items.map((i) => i.resolveAnchors(t, n))
			return new js(
				e,
				r,
				this._items.map((i) => i.ruleId),
			)
		}
	},
	js = class {
		constructor(e, t, n) {
			R(this, "scanner")
			;(this.regExps = t), (this.rules = n), (this.scanner = e.createOnigScanner(t))
		}
		dispose() {
			typeof this.scanner.dispose == "function" && this.scanner.dispose()
		}
		toString() {
			const e = []
			for (let t = 0, n = this.rules.length; t < n; t++) e.push("   - " + this.rules[t] + ": " + this.regExps[t])
			return e.join(`
`)
		}
		findNextMatchSync(e, t, n) {
			const r = this.scanner.findNextMatchSync(e, t, n)
			return r ? { ruleId: this.rules[r.index], captureIndices: r.captureIndices } : null
		}
	},
	pi = class {
		constructor(e, t) {
			;(this.languageId = e), (this.tokenType = t)
		}
	},
	wt,
	my =
		((wt = class {
			constructor(t, n) {
				R(this, "_defaultAttributes")
				R(this, "_embeddedLanguagesMatcher")
				R(
					this,
					"_getBasicScopeAttributes",
					new tu((t) => {
						const n = this._scopeToLanguage(t),
							r = this._toStandardTokenType(t)
						return new pi(n, r)
					}),
				)
				;(this._defaultAttributes = new pi(t, 8)),
					(this._embeddedLanguagesMatcher = new py(Object.entries(n || {})))
			}
			getDefaultAttributes() {
				return this._defaultAttributes
			}
			getBasicScopeAttributes(t) {
				return t === null ? wt._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(t)
			}
			_scopeToLanguage(t) {
				return this._embeddedLanguagesMatcher.match(t) || 0
			}
			_toStandardTokenType(t) {
				const n = t.match(wt.STANDARD_TOKEN_TYPE_REGEXP)
				if (!n) return 8
				switch (n[1]) {
					case "comment":
						return 1
					case "string":
						return 2
					case "regex":
						return 3
					case "meta.embedded":
						return 0
				}
				throw new Error("Unexpected match for standard token type!")
			}
		}),
		R(wt, "_NULL_SCOPE_METADATA", new pi(0, 0)),
		R(wt, "STANDARD_TOKEN_TYPE_REGEXP", /\b(comment|string|regex|meta\.embedded)\b/),
		wt),
	py = class {
		constructor(e) {
			R(this, "values")
			R(this, "scopesRegExp")
			if (e.length === 0) (this.values = null), (this.scopesRegExp = null)
			else {
				this.values = new Map(e)
				const t = e.map(([n, r]) => eu(n))
				t.sort(), t.reverse(), (this.scopesRegExp = new RegExp(`^((${t.join(")|(")}))($|\\.)`, ""))
			}
		}
		match(e) {
			if (!this.scopesRegExp) return
			const t = e.match(this.scopesRegExp)
			if (t) return this.values.get(t[1])
		}
	},
	Hs = class {
		constructor(e, t) {
			;(this.stack = e), (this.stoppedEarly = t)
		}
	}
function uu(e, t, n, r, i, o, s, a) {
	const l = t.content.length
	let u = !1,
		m = -1
	if (s) {
		const p = hy(e, t, n, r, i, o)
		;(i = p.stack), (r = p.linePos), (n = p.isFirstLine), (m = p.anchorPosition)
	}
	const c = Date.now()
	for (; !u; ) {
		if (a !== 0 && Date.now() - c > a) return new Hs(i, !0)
		h()
	}
	return new Hs(i, !1)
	function h() {
		const p = fy(e, t, n, r, i, m)
		if (!p) {
			o.produce(i, l), (u = !0)
			return
		}
		const f = p.captureIndices,
			y = p.matchedRuleId,
			x = f && f.length > 0 ? f[0].end > r : !1
		if (y === ly) {
			const d = i.getRule(e)
			o.produce(i, f[0].start),
				(i = i.withContentNameScopesList(i.nameScopesList)),
				gn(e, t, n, i, o, d.endCaptures, f),
				o.produce(i, f[0].end)
			const _ = i
			if (((i = i.parent), (m = _.getAnchorPos()), !x && _.getEnterPos() === r)) {
				;(i = _), o.produce(i, l), (u = !0)
				return
			}
		} else {
			const d = e.getRule(y)
			o.produce(i, f[0].start)
			const _ = i,
				w = d.getName(t.content, f),
				I = i.contentNameScopesList.pushAttributed(w, e)
			if (((i = i.push(y, r, m, f[0].end === l, null, I, I)), d instanceof zi)) {
				const S = d
				gn(e, t, n, i, o, S.beginCaptures, f), o.produce(i, f[0].end), (m = f[0].end)
				const b = S.getContentName(t.content, f),
					T = I.pushAttributed(b, e)
				if (
					((i = i.withContentNameScopesList(T)),
					S.endHasBackReferences && (i = i.withEndRule(S.getEndWithResolvedBackReferences(t.content, f))),
					!x && _.hasSameRuleAs(i))
				) {
					;(i = i.pop()), o.produce(i, l), (u = !0)
					return
				}
			} else if (d instanceof yr) {
				const S = d
				gn(e, t, n, i, o, S.beginCaptures, f), o.produce(i, f[0].end), (m = f[0].end)
				const b = S.getContentName(t.content, f),
					T = I.pushAttributed(b, e)
				if (
					((i = i.withContentNameScopesList(T)),
					S.whileHasBackReferences && (i = i.withEndRule(S.getWhileWithResolvedBackReferences(t.content, f))),
					!x && _.hasSameRuleAs(i))
				) {
					;(i = i.pop()), o.produce(i, l), (u = !0)
					return
				}
			} else if ((gn(e, t, n, i, o, d.captures, f), o.produce(i, f[0].end), (i = i.pop()), !x)) {
				;(i = i.safePop()), o.produce(i, l), (u = !0)
				return
			}
		}
		f[0].end > r && ((r = f[0].end), (n = !1))
	}
}
function hy(e, t, n, r, i, o) {
	let s = i.beginRuleCapturedEOL ? 0 : -1
	const a = []
	for (let l = i; l; l = l.pop()) {
		const u = l.getRule(e)
		u instanceof yr && a.push({ rule: u, stack: l })
	}
	for (let l = a.pop(); l; l = a.pop()) {
		const { ruleScanner: u, findOptions: m } = _y(l.rule, e, l.stack.endRule, n, r === s),
			c = u.findNextMatchSync(t, r, m)
		if (c) {
			if (c.ruleId !== su) {
				i = l.stack.pop()
				break
			}
			c.captureIndices &&
				c.captureIndices.length &&
				(o.produce(l.stack, c.captureIndices[0].start),
				gn(e, t, n, l.stack, o, l.rule.whileCaptures, c.captureIndices),
				o.produce(l.stack, c.captureIndices[0].end),
				(s = c.captureIndices[0].end),
				c.captureIndices[0].end > r && ((r = c.captureIndices[0].end), (n = !1)))
		} else {
			i = l.stack.pop()
			break
		}
	}
	return { stack: i, linePos: r, anchorPosition: s, isFirstLine: n }
}
function fy(e, t, n, r, i, o) {
	const s = dy(e, t, n, r, i, o),
		a = e.getInjections()
	if (a.length === 0) return s
	const l = gy(a, e, t, n, r, i, o)
	if (!l) return s
	if (!s) return l
	const u = s.captureIndices[0].start,
		m = l.captureIndices[0].start
	return m < u || (l.priorityMatch && m === u) ? l : s
}
function dy(e, t, n, r, i, o) {
	const s = i.getRule(e),
		{ ruleScanner: a, findOptions: l } = cu(s, e, i.endRule, n, r === o),
		u = a.findNextMatchSync(t, r, l)
	return u ? { captureIndices: u.captureIndices, matchedRuleId: u.ruleId } : null
}
function gy(e, t, n, r, i, o, s) {
	let a = Number.MAX_VALUE,
		l = null,
		u,
		m = 0
	const c = o.contentNameScopesList.getScopeNames()
	for (let h = 0, p = e.length; h < p; h++) {
		const f = e[h]
		if (!f.matcher(c)) continue
		const y = t.getRule(f.ruleId),
			{ ruleScanner: x, findOptions: d } = cu(y, t, null, r, i === s),
			_ = x.findNextMatchSync(n, i, d)
		if (!_) continue
		const w = _.captureIndices[0].start
		if (!(w >= a) && ((a = w), (l = _.captureIndices), (u = _.ruleId), (m = f.priority), a === i)) break
	}
	return l ? { priorityMatch: m === -1, captureIndices: l, matchedRuleId: u } : null
}
function cu(e, t, n, r, i) {
	return { ruleScanner: e.compileAG(t, n, r, i), findOptions: 0 }
}
function _y(e, t, n, r, i) {
	return { ruleScanner: e.compileWhileAG(t, n, r, i), findOptions: 0 }
}
function gn(e, t, n, r, i, o, s) {
	if (o.length === 0) return
	const a = t.content,
		l = Math.min(o.length, s.length),
		u = [],
		m = s[0].end
	for (let c = 0; c < l; c++) {
		const h = o[c]
		if (h === null) continue
		const p = s[c]
		if (p.length === 0) continue
		if (p.start > m) break
		for (; u.length > 0 && u[u.length - 1].endPos <= p.start; )
			i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop()
		if (
			(u.length > 0 ? i.produceFromScopes(u[u.length - 1].scopes, p.start) : i.produce(r, p.start),
			h.retokenizeCapturedWithRuleId)
		) {
			const y = h.getName(a, s),
				x = r.contentNameScopesList.pushAttributed(y, e),
				d = h.getContentName(a, s),
				_ = x.pushAttributed(d, e),
				w = r.push(h.retokenizeCapturedWithRuleId, p.start, -1, !1, null, x, _),
				I = e.createOnigString(a.substring(0, p.end))
			uu(e, I, n && p.start === 0, p.start, w, i, !1, 0), iu(I)
			continue
		}
		const f = h.getName(a, s)
		if (f !== null) {
			const x = (u.length > 0 ? u[u.length - 1].scopes : r.contentNameScopesList).pushAttributed(f, e)
			u.push(new yy(x, p.end))
		}
	}
	for (; u.length > 0; ) i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop()
}
var yy = class {
	constructor(e, t) {
		R(this, "scopes")
		R(this, "endPos")
		;(this.scopes = e), (this.endPos = t)
	}
}
function xy(e, t, n, r, i, o, s, a) {
	return new ky(e, t, n, r, i, o, s, a)
}
function Gs(e, t, n, r, i) {
	const o = gr(t, xr),
		s = au.getCompiledRuleId(n, r, i.repository)
	for (const a of o) e.push({ debugSelector: t, matcher: a.matcher, ruleId: s, grammar: i, priority: a.priority })
}
function xr(e, t) {
	if (t.length < e.length) return !1
	let n = 0
	return e.every((r) => {
		for (let i = n; i < t.length; i++) if (by(t[i], r)) return (n = i + 1), !0
		return !1
	})
}
function by(e, t) {
	if (!e) return !1
	if (e === t) return !0
	const n = t.length
	return e.length > n && e.substr(0, n) === t && e[n] === "."
}
var ky = class {
	constructor(e, t, n, r, i, o, s, a) {
		R(this, "_rootId")
		R(this, "_lastRuleId")
		R(this, "_ruleId2desc")
		R(this, "_includedGrammars")
		R(this, "_grammarRepository")
		R(this, "_grammar")
		R(this, "_injections")
		R(this, "_basicScopeAttributesProvider")
		R(this, "_tokenTypeMatchers")
		if (
			((this._rootScopeName = e),
			(this.balancedBracketSelectors = o),
			(this._onigLib = a),
			(this._basicScopeAttributesProvider = new my(n, r)),
			(this._rootId = -1),
			(this._lastRuleId = 0),
			(this._ruleId2desc = [null]),
			(this._includedGrammars = {}),
			(this._grammarRepository = s),
			(this._grammar = $s(t, null)),
			(this._injections = null),
			(this._tokenTypeMatchers = []),
			i)
		)
			for (const l of Object.keys(i)) {
				const u = gr(l, xr)
				for (const m of u) this._tokenTypeMatchers.push({ matcher: m.matcher, type: i[l] })
			}
	}
	get themeProvider() {
		return this._grammarRepository
	}
	dispose() {
		for (const e of this._ruleId2desc) e && e.dispose()
	}
	createOnigScanner(e) {
		return this._onigLib.createOnigScanner(e)
	}
	createOnigString(e) {
		return this._onigLib.createOnigString(e)
	}
	getMetadataForScope(e) {
		return this._basicScopeAttributesProvider.getBasicScopeAttributes(e)
	}
	_collectInjections() {
		const e = {
				lookup: (i) => (i === this._rootScopeName ? this._grammar : this.getExternalGrammar(i)),
				injections: (i) => this._grammarRepository.injections(i),
			},
			t = [],
			n = this._rootScopeName,
			r = e.lookup(n)
		if (r) {
			const i = r.injections
			if (i) for (let s in i) Gs(t, s, i[s], this, r)
			const o = this._grammarRepository.injections(n)
			o &&
				o.forEach((s) => {
					const a = this.getExternalGrammar(s)
					if (a) {
						const l = a.injectionSelector
						l && Gs(t, l, a, this, a)
					}
				})
		}
		return t.sort((i, o) => i.priority - o.priority), t
	}
	getInjections() {
		return this._injections === null && (this._injections = this._collectInjections()), this._injections
	}
	registerRule(e) {
		const t = ++this._lastRuleId,
			n = e(t)
		return (this._ruleId2desc[t] = n), n
	}
	getRule(e) {
		return this._ruleId2desc[e]
	}
	getExternalGrammar(e, t) {
		if (this._includedGrammars[e]) return this._includedGrammars[e]
		if (this._grammarRepository) {
			const n = this._grammarRepository.lookup(e)
			if (n) return (this._includedGrammars[e] = $s(n, t && t.$base)), this._includedGrammars[e]
		}
	}
	tokenizeLine(e, t, n = 0) {
		const r = this._tokenize(e, t, !1, n)
		return {
			tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),
			ruleStack: r.ruleStack,
			stoppedEarly: r.stoppedEarly,
		}
	}
	tokenizeLine2(e, t, n = 0) {
		const r = this._tokenize(e, t, !0, n)
		return {
			tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),
			ruleStack: r.ruleStack,
			stoppedEarly: r.stoppedEarly,
		}
	}
	_tokenize(e, t, n, r) {
		this._rootId === -1 &&
			((this._rootId = au.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository)),
			this.getInjections())
		let i
		if (!t || t === Vi.NULL) {
			i = !0
			const u = this._basicScopeAttributesProvider.getDefaultAttributes(),
				m = this.themeProvider.getDefaults(),
				c = tn.set(0, u.languageId, u.tokenType, null, m.fontStyle, m.foregroundId, m.backgroundId),
				h = this.getRule(this._rootId).getName(null, null)
			let p
			h ? (p = wn.createRootAndLookUpScopeName(h, c, this)) : (p = wn.createRoot("unknown", c)),
				(t = new Vi(null, this._rootId, -1, -1, !1, null, p, p))
		} else (i = !1), t.reset()
		e =
			e +
			`
`
		const o = this.createOnigString(e),
			s = o.content.length,
			a = new Ey(n, e, this._tokenTypeMatchers, this.balancedBracketSelectors),
			l = uu(this, o, i, 0, t, a, !0, r)
		return iu(o), { lineLength: s, lineTokens: a, ruleStack: l.stack, stoppedEarly: l.stoppedEarly }
	}
}
function $s(e, t) {
	return (
		(e = F_(e)),
		(e.repository = e.repository || {}),
		(e.repository.$self = {
			$vscodeTextmateLocation: e.$vscodeTextmateLocation,
			patterns: e.patterns,
			name: e.scopeName,
		}),
		(e.repository.$base = t || e.repository.$self),
		e
	)
}
var wn = class lt {
		constructor(t, n, r) {
			;(this.parent = t), (this.scopePath = n), (this.tokenAttributes = r)
		}
		static fromExtension(t, n) {
			let r = t,
				i = (t == null ? void 0 : t.scopePath) ?? null
			for (const o of n) (i = mi.push(i, o.scopeNames)), (r = new lt(r, i, o.encodedTokenAttributes))
			return r
		}
		static createRoot(t, n) {
			return new lt(null, new mi(null, t), n)
		}
		static createRootAndLookUpScopeName(t, n, r) {
			const i = r.getMetadataForScope(t),
				o = new mi(null, t),
				s = r.themeProvider.themeMatch(o),
				a = lt.mergeAttributes(n, i, s)
			return new lt(null, o, a)
		}
		get scopeName() {
			return this.scopePath.scopeName
		}
		toString() {
			return this.getScopeNames().join(" ")
		}
		equals(t) {
			return lt.equals(this, t)
		}
		static equals(t, n) {
			do {
				if (t === n || (!t && !n)) return !0
				if (!t || !n || t.scopeName !== n.scopeName || t.tokenAttributes !== n.tokenAttributes) return !1
				;(t = t.parent), (n = n.parent)
			} while (!0)
		}
		static mergeAttributes(t, n, r) {
			let i = -1,
				o = 0,
				s = 0
			return (
				r !== null && ((i = r.fontStyle), (o = r.foregroundId), (s = r.backgroundId)),
				tn.set(t, n.languageId, n.tokenType, null, i, o, s)
			)
		}
		pushAttributed(t, n) {
			if (t === null) return this
			if (t.indexOf(" ") === -1) return lt._pushAttributed(this, t, n)
			const r = t.split(/ /g)
			let i = this
			for (const o of r) i = lt._pushAttributed(i, o, n)
			return i
		}
		static _pushAttributed(t, n, r) {
			const i = r.getMetadataForScope(n),
				o = t.scopePath.push(n),
				s = r.themeProvider.themeMatch(o),
				a = lt.mergeAttributes(t.tokenAttributes, i, s)
			return new lt(t, o, a)
		}
		getScopeNames() {
			return this.scopePath.getSegments()
		}
		getExtensionIfDefined(t) {
			var i
			const n = []
			let r = this
			for (; r && r !== t; )
				n.push({
					encodedTokenAttributes: r.tokenAttributes,
					scopeNames: r.scopePath.getExtensionIfDefined(
						((i = r.parent) == null ? void 0 : i.scopePath) ?? null,
					),
				}),
					(r = r.parent)
			return r === t ? n.reverse() : void 0
		}
	},
	tt,
	Vi =
		((tt = class {
			constructor(t, n, r, i, o, s, a, l) {
				R(this, "_stackElementBrand")
				R(this, "_enterPos")
				R(this, "_anchorPos")
				R(this, "depth")
				;(this.parent = t),
					(this.ruleId = n),
					(this.beginRuleCapturedEOL = o),
					(this.endRule = s),
					(this.nameScopesList = a),
					(this.contentNameScopesList = l),
					(this.depth = this.parent ? this.parent.depth + 1 : 1),
					(this._enterPos = r),
					(this._anchorPos = i)
			}
			equals(t) {
				return t === null ? !1 : tt._equals(this, t)
			}
			static _equals(t, n) {
				return t === n
					? !0
					: this._structuralEquals(t, n)
						? wn.equals(t.contentNameScopesList, n.contentNameScopesList)
						: !1
			}
			static _structuralEquals(t, n) {
				do {
					if (t === n || (!t && !n)) return !0
					if (!t || !n || t.depth !== n.depth || t.ruleId !== n.ruleId || t.endRule !== n.endRule) return !1
					;(t = t.parent), (n = n.parent)
				} while (!0)
			}
			clone() {
				return this
			}
			static _reset(t) {
				for (; t; ) (t._enterPos = -1), (t._anchorPos = -1), (t = t.parent)
			}
			reset() {
				tt._reset(this)
			}
			pop() {
				return this.parent
			}
			safePop() {
				return this.parent ? this.parent : this
			}
			push(t, n, r, i, o, s, a) {
				return new tt(this, t, n, r, i, o, s, a)
			}
			getEnterPos() {
				return this._enterPos
			}
			getAnchorPos() {
				return this._anchorPos
			}
			getRule(t) {
				return t.getRule(this.ruleId)
			}
			toString() {
				const t = []
				return this._writeString(t, 0), "[" + t.join(",") + "]"
			}
			_writeString(t, n) {
				var r, i
				return (
					this.parent && (n = this.parent._writeString(t, n)),
					(t[n++] =
						`(${this.ruleId}, ${(r = this.nameScopesList) == null ? void 0 : r.toString()}, ${(i = this.contentNameScopesList) == null ? void 0 : i.toString()})`),
					n
				)
			}
			withContentNameScopesList(t) {
				return this.contentNameScopesList === t
					? this
					: this.parent.push(
							this.ruleId,
							this._enterPos,
							this._anchorPos,
							this.beginRuleCapturedEOL,
							this.endRule,
							this.nameScopesList,
							t,
						)
			}
			withEndRule(t) {
				return this.endRule === t
					? this
					: new tt(
							this.parent,
							this.ruleId,
							this._enterPos,
							this._anchorPos,
							this.beginRuleCapturedEOL,
							t,
							this.nameScopesList,
							this.contentNameScopesList,
						)
			}
			hasSameRuleAs(t) {
				let n = this
				for (; n && n._enterPos === t._enterPos; ) {
					if (n.ruleId === t.ruleId) return !0
					n = n.parent
				}
				return !1
			}
			toStateStackFrame() {
				var t, n, r
				return {
					ruleId: this.ruleId,
					beginRuleCapturedEOL: this.beginRuleCapturedEOL,
					endRule: this.endRule,
					nameScopesList:
						((n = this.nameScopesList) == null
							? void 0
							: n.getExtensionIfDefined(
									((t = this.parent) == null ? void 0 : t.nameScopesList) ?? null,
								)) ?? [],
					contentNameScopesList:
						((r = this.contentNameScopesList) == null
							? void 0
							: r.getExtensionIfDefined(this.nameScopesList)) ?? [],
				}
			}
			static pushFrame(t, n) {
				const r = wn.fromExtension((t == null ? void 0 : t.nameScopesList) ?? null, n.nameScopesList)
				return new tt(
					t,
					n.ruleId,
					n.enterPos ?? -1,
					n.anchorPos ?? -1,
					n.beginRuleCapturedEOL,
					n.endRule,
					r,
					wn.fromExtension(r, n.contentNameScopesList),
				)
			}
		}),
		R(tt, "NULL", new tt(null, 0, 0, 0, !1, null, null, null)),
		tt),
	wy = class {
		constructor(e, t) {
			R(this, "balancedBracketScopes")
			R(this, "unbalancedBracketScopes")
			R(this, "allowAny", !1)
			;(this.balancedBracketScopes = e.flatMap((n) =>
				n === "*" ? ((this.allowAny = !0), []) : gr(n, xr).map((r) => r.matcher),
			)),
				(this.unbalancedBracketScopes = t.flatMap((n) => gr(n, xr).map((r) => r.matcher)))
		}
		get matchesAlways() {
			return this.allowAny && this.unbalancedBracketScopes.length === 0
		}
		get matchesNever() {
			return this.balancedBracketScopes.length === 0 && !this.allowAny
		}
		match(e) {
			for (const t of this.unbalancedBracketScopes) if (t(e)) return !1
			for (const t of this.balancedBracketScopes) if (t(e)) return !0
			return this.allowAny
		}
	},
	Ey = class {
		constructor(e, t, n, r) {
			R(this, "_emitBinaryTokens")
			R(this, "_lineText")
			R(this, "_tokens")
			R(this, "_binaryTokens")
			R(this, "_lastTokenEndIndex")
			R(this, "_tokenTypeOverrides")
			;(this.balancedBracketSelectors = r),
				(this._emitBinaryTokens = e),
				(this._tokenTypeOverrides = n),
				(this._lineText = null),
				(this._tokens = []),
				(this._binaryTokens = []),
				(this._lastTokenEndIndex = 0)
		}
		produce(e, t) {
			this.produceFromScopes(e.contentNameScopesList, t)
		}
		produceFromScopes(e, t) {
			var r
			if (this._lastTokenEndIndex >= t) return
			if (this._emitBinaryTokens) {
				let i = (e == null ? void 0 : e.tokenAttributes) ?? 0,
					o = !1
				if (
					((r = this.balancedBracketSelectors) != null && r.matchesAlways && (o = !0),
					this._tokenTypeOverrides.length > 0 ||
						(this.balancedBracketSelectors &&
							!this.balancedBracketSelectors.matchesAlways &&
							!this.balancedBracketSelectors.matchesNever))
				) {
					const s = (e == null ? void 0 : e.getScopeNames()) ?? []
					for (const a of this._tokenTypeOverrides) a.matcher(s) && (i = tn.set(i, 0, a.type, null, -1, 0, 0))
					this.balancedBracketSelectors && (o = this.balancedBracketSelectors.match(s))
				}
				if (
					(o && (i = tn.set(i, 0, 8, o, -1, 0, 0)),
					this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === i)
				) {
					this._lastTokenEndIndex = t
					return
				}
				this._binaryTokens.push(this._lastTokenEndIndex),
					this._binaryTokens.push(i),
					(this._lastTokenEndIndex = t)
				return
			}
			const n = (e == null ? void 0 : e.getScopeNames()) ?? []
			this._tokens.push({ startIndex: this._lastTokenEndIndex, endIndex: t, scopes: n }),
				(this._lastTokenEndIndex = t)
		}
		getResult(e, t) {
			return (
				this._tokens.length > 0 &&
					this._tokens[this._tokens.length - 1].startIndex === t - 1 &&
					this._tokens.pop(),
				this._tokens.length === 0 &&
					((this._lastTokenEndIndex = -1),
					this.produce(e, t),
					(this._tokens[this._tokens.length - 1].startIndex = 0)),
				this._tokens
			)
		}
		getBinaryResult(e, t) {
			this._binaryTokens.length > 0 &&
				this._binaryTokens[this._binaryTokens.length - 2] === t - 1 &&
				(this._binaryTokens.pop(), this._binaryTokens.pop()),
				this._binaryTokens.length === 0 &&
					((this._lastTokenEndIndex = -1),
					this.produce(e, t),
					(this._binaryTokens[this._binaryTokens.length - 2] = 0))
			const n = new Uint32Array(this._binaryTokens.length)
			for (let r = 0, i = this._binaryTokens.length; r < i; r++) n[r] = this._binaryTokens[r]
			return n
		}
	},
	vy = class {
		constructor(e, t) {
			R(this, "_grammars", new Map())
			R(this, "_rawGrammars", new Map())
			R(this, "_injectionGrammars", new Map())
			R(this, "_theme")
			;(this._onigLib = t), (this._theme = e)
		}
		dispose() {
			for (const e of this._grammars.values()) e.dispose()
		}
		setTheme(e) {
			this._theme = e
		}
		getColorMap() {
			return this._theme.getColorMap()
		}
		addGrammar(e, t) {
			this._rawGrammars.set(e.scopeName, e), t && this._injectionGrammars.set(e.scopeName, t)
		}
		lookup(e) {
			return this._rawGrammars.get(e)
		}
		injections(e) {
			return this._injectionGrammars.get(e)
		}
		getDefaults() {
			return this._theme.getDefaults()
		}
		themeMatch(e) {
			return this._theme.match(e)
		}
		grammarForScopeName(e, t, n, r, i) {
			if (!this._grammars.has(e)) {
				let o = this._rawGrammars.get(e)
				if (!o) return null
				this._grammars.set(e, xy(e, o, t, n, r, i, this, this._onigLib))
			}
			return this._grammars.get(e)
		}
	},
	Sy = class {
		constructor(t) {
			R(this, "_options")
			R(this, "_syncRegistry")
			R(this, "_ensureGrammarCache")
			;(this._options = t),
				(this._syncRegistry = new vy(dr.createFromRawTheme(t.theme, t.colorMap), t.onigLib)),
				(this._ensureGrammarCache = new Map())
		}
		dispose() {
			this._syncRegistry.dispose()
		}
		setTheme(t, n) {
			this._syncRegistry.setTheme(dr.createFromRawTheme(t, n))
		}
		getColorMap() {
			return this._syncRegistry.getColorMap()
		}
		loadGrammarWithEmbeddedLanguages(t, n, r) {
			return this.loadGrammarWithConfiguration(t, n, { embeddedLanguages: r })
		}
		loadGrammarWithConfiguration(t, n, r) {
			return this._loadGrammar(
				t,
				n,
				r.embeddedLanguages,
				r.tokenTypes,
				new wy(r.balancedBracketSelectors || [], r.unbalancedBracketSelectors || []),
			)
		}
		loadGrammar(t) {
			return this._loadGrammar(t, 0, null, null, null)
		}
		_loadGrammar(t, n, r, i, o) {
			const s = new ey(this._syncRegistry, t)
			for (; s.Q.length > 0; ) s.Q.map((a) => this._loadSingleGrammar(a.scopeName)), s.processQueue()
			return this._grammarForScopeName(t, n, r, i, o)
		}
		_loadSingleGrammar(t) {
			this._ensureGrammarCache.has(t) || (this._doLoadSingleGrammar(t), this._ensureGrammarCache.set(t, !0))
		}
		_doLoadSingleGrammar(t) {
			const n = this._options.loadGrammar(t)
			if (n) {
				const r = typeof this._options.getInjections == "function" ? this._options.getInjections(t) : void 0
				this._syncRegistry.addGrammar(n, r)
			}
		}
		addGrammar(t, n = [], r = 0, i = null) {
			return this._syncRegistry.addGrammar(t, n), this._grammarForScopeName(t.scopeName, r, i)
		}
		_grammarForScopeName(t, n = 0, r = null, i = null, o = null) {
			return this._syncRegistry.grammarForScopeName(t, n, r, i, o)
		}
	},
	Bi = Vi.NULL
const Iy = [
		"area",
		"base",
		"basefont",
		"bgsound",
		"br",
		"col",
		"command",
		"embed",
		"frame",
		"hr",
		"image",
		"img",
		"input",
		"keygen",
		"link",
		"meta",
		"param",
		"source",
		"track",
		"wbr",
	],
	Ty = /["&'<>`]/g,
	Cy = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
	Ay = /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
	Ry = /[|\\{}()[\]^$+*?.]/g,
	Us = new WeakMap()
function Ly(e, t) {
	if (((e = e.replace(t.subset ? Py(t.subset) : Ty, r)), t.subset || t.escapeOnly)) return e
	return e.replace(Cy, n).replace(Ay, r)
	function n(i, o, s) {
		return t.format((i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536, s.charCodeAt(o + 2), t)
	}
	function r(i, o, s) {
		return t.format(i.charCodeAt(0), s.charCodeAt(o + 1), t)
	}
}
function Py(e) {
	let t = Us.get(e)
	return t || ((t = Oy(e)), Us.set(e, t)), t
}
function Oy(e) {
	const t = []
	let n = -1
	for (; ++n < e.length; ) t.push(e[n].replace(Ry, "\\$&"))
	return new RegExp("(?:" + t.join("|") + ")", "g")
}
const Dy = /[\dA-Fa-f]/
function Ny(e, t, n) {
	const r = "&#x" + e.toString(16).toUpperCase()
	return n && t && !Dy.test(String.fromCharCode(t)) ? r : r + ";"
}
const My = /\d/
function zy(e, t, n) {
	const r = "&#" + String(e)
	return n && t && !My.test(String.fromCharCode(t)) ? r : r + ";"
}
const Vy = [
		"AElig",
		"AMP",
		"Aacute",
		"Acirc",
		"Agrave",
		"Aring",
		"Atilde",
		"Auml",
		"COPY",
		"Ccedil",
		"ETH",
		"Eacute",
		"Ecirc",
		"Egrave",
		"Euml",
		"GT",
		"Iacute",
		"Icirc",
		"Igrave",
		"Iuml",
		"LT",
		"Ntilde",
		"Oacute",
		"Ocirc",
		"Ograve",
		"Oslash",
		"Otilde",
		"Ouml",
		"QUOT",
		"REG",
		"THORN",
		"Uacute",
		"Ucirc",
		"Ugrave",
		"Uuml",
		"Yacute",
		"aacute",
		"acirc",
		"acute",
		"aelig",
		"agrave",
		"amp",
		"aring",
		"atilde",
		"auml",
		"brvbar",
		"ccedil",
		"cedil",
		"cent",
		"copy",
		"curren",
		"deg",
		"divide",
		"eacute",
		"ecirc",
		"egrave",
		"eth",
		"euml",
		"frac12",
		"frac14",
		"frac34",
		"gt",
		"iacute",
		"icirc",
		"iexcl",
		"igrave",
		"iquest",
		"iuml",
		"laquo",
		"lt",
		"macr",
		"micro",
		"middot",
		"nbsp",
		"not",
		"ntilde",
		"oacute",
		"ocirc",
		"ograve",
		"ordf",
		"ordm",
		"oslash",
		"otilde",
		"ouml",
		"para",
		"plusmn",
		"pound",
		"quot",
		"raquo",
		"reg",
		"sect",
		"shy",
		"sup1",
		"sup2",
		"sup3",
		"szlig",
		"thorn",
		"times",
		"uacute",
		"ucirc",
		"ugrave",
		"uml",
		"uuml",
		"yacute",
		"yen",
		"yuml",
	],
	hi = {
		nbsp: " ",
		iexcl: "¡",
		cent: "¢",
		pound: "£",
		curren: "¤",
		yen: "¥",
		brvbar: "¦",
		sect: "§",
		uml: "¨",
		copy: "©",
		ordf: "ª",
		laquo: "«",
		not: "¬",
		shy: "­",
		reg: "®",
		macr: "¯",
		deg: "°",
		plusmn: "±",
		sup2: "²",
		sup3: "³",
		acute: "´",
		micro: "µ",
		para: "¶",
		middot: "·",
		cedil: "¸",
		sup1: "¹",
		ordm: "º",
		raquo: "»",
		frac14: "¼",
		frac12: "½",
		frac34: "¾",
		iquest: "¿",
		Agrave: "À",
		Aacute: "Á",
		Acirc: "Â",
		Atilde: "Ã",
		Auml: "Ä",
		Aring: "Å",
		AElig: "Æ",
		Ccedil: "Ç",
		Egrave: "È",
		Eacute: "É",
		Ecirc: "Ê",
		Euml: "Ë",
		Igrave: "Ì",
		Iacute: "Í",
		Icirc: "Î",
		Iuml: "Ï",
		ETH: "Ð",
		Ntilde: "Ñ",
		Ograve: "Ò",
		Oacute: "Ó",
		Ocirc: "Ô",
		Otilde: "Õ",
		Ouml: "Ö",
		times: "×",
		Oslash: "Ø",
		Ugrave: "Ù",
		Uacute: "Ú",
		Ucirc: "Û",
		Uuml: "Ü",
		Yacute: "Ý",
		THORN: "Þ",
		szlig: "ß",
		agrave: "à",
		aacute: "á",
		acirc: "â",
		atilde: "ã",
		auml: "ä",
		aring: "å",
		aelig: "æ",
		ccedil: "ç",
		egrave: "è",
		eacute: "é",
		ecirc: "ê",
		euml: "ë",
		igrave: "ì",
		iacute: "í",
		icirc: "î",
		iuml: "ï",
		eth: "ð",
		ntilde: "ñ",
		ograve: "ò",
		oacute: "ó",
		ocirc: "ô",
		otilde: "õ",
		ouml: "ö",
		divide: "÷",
		oslash: "ø",
		ugrave: "ù",
		uacute: "ú",
		ucirc: "û",
		uuml: "ü",
		yacute: "ý",
		thorn: "þ",
		yuml: "ÿ",
		fnof: "ƒ",
		Alpha: "Α",
		Beta: "Β",
		Gamma: "Γ",
		Delta: "Δ",
		Epsilon: "Ε",
		Zeta: "Ζ",
		Eta: "Η",
		Theta: "Θ",
		Iota: "Ι",
		Kappa: "Κ",
		Lambda: "Λ",
		Mu: "Μ",
		Nu: "Ν",
		Xi: "Ξ",
		Omicron: "Ο",
		Pi: "Π",
		Rho: "Ρ",
		Sigma: "Σ",
		Tau: "Τ",
		Upsilon: "Υ",
		Phi: "Φ",
		Chi: "Χ",
		Psi: "Ψ",
		Omega: "Ω",
		alpha: "α",
		beta: "β",
		gamma: "γ",
		delta: "δ",
		epsilon: "ε",
		zeta: "ζ",
		eta: "η",
		theta: "θ",
		iota: "ι",
		kappa: "κ",
		lambda: "λ",
		mu: "μ",
		nu: "ν",
		xi: "ξ",
		omicron: "ο",
		pi: "π",
		rho: "ρ",
		sigmaf: "ς",
		sigma: "σ",
		tau: "τ",
		upsilon: "υ",
		phi: "φ",
		chi: "χ",
		psi: "ψ",
		omega: "ω",
		thetasym: "ϑ",
		upsih: "ϒ",
		piv: "ϖ",
		bull: "•",
		hellip: "…",
		prime: "′",
		Prime: "″",
		oline: "‾",
		frasl: "⁄",
		weierp: "℘",
		image: "ℑ",
		real: "ℜ",
		trade: "™",
		alefsym: "ℵ",
		larr: "←",
		uarr: "↑",
		rarr: "→",
		darr: "↓",
		harr: "↔",
		crarr: "↵",
		lArr: "⇐",
		uArr: "⇑",
		rArr: "⇒",
		dArr: "⇓",
		hArr: "⇔",
		forall: "∀",
		part: "∂",
		exist: "∃",
		empty: "∅",
		nabla: "∇",
		isin: "∈",
		notin: "∉",
		ni: "∋",
		prod: "∏",
		sum: "∑",
		minus: "−",
		lowast: "∗",
		radic: "√",
		prop: "∝",
		infin: "∞",
		ang: "∠",
		and: "∧",
		or: "∨",
		cap: "∩",
		cup: "∪",
		int: "∫",
		there4: "∴",
		sim: "∼",
		cong: "≅",
		asymp: "≈",
		ne: "≠",
		equiv: "≡",
		le: "≤",
		ge: "≥",
		sub: "⊂",
		sup: "⊃",
		nsub: "⊄",
		sube: "⊆",
		supe: "⊇",
		oplus: "⊕",
		otimes: "⊗",
		perp: "⊥",
		sdot: "⋅",
		lceil: "⌈",
		rceil: "⌉",
		lfloor: "⌊",
		rfloor: "⌋",
		lang: "〈",
		rang: "〉",
		loz: "◊",
		spades: "♠",
		clubs: "♣",
		hearts: "♥",
		diams: "♦",
		quot: '"',
		amp: "&",
		lt: "<",
		gt: ">",
		OElig: "Œ",
		oelig: "œ",
		Scaron: "Š",
		scaron: "š",
		Yuml: "Ÿ",
		circ: "ˆ",
		tilde: "˜",
		ensp: " ",
		emsp: " ",
		thinsp: " ",
		zwnj: "‌",
		zwj: "‍",
		lrm: "‎",
		rlm: "‏",
		ndash: "–",
		mdash: "—",
		lsquo: "‘",
		rsquo: "’",
		sbquo: "‚",
		ldquo: "“",
		rdquo: "”",
		bdquo: "„",
		dagger: "†",
		Dagger: "‡",
		permil: "‰",
		lsaquo: "‹",
		rsaquo: "›",
		euro: "€",
	},
	By = ["cent", "copy", "divide", "gt", "lt", "not", "para", "times"],
	mu = {}.hasOwnProperty,
	Fi = {}
let Qn
for (Qn in hi) mu.call(hi, Qn) && (Fi[hi[Qn]] = Qn)
const Fy = /[^\dA-Za-z]/
function jy(e, t, n, r) {
	const i = String.fromCharCode(e)
	if (mu.call(Fi, i)) {
		const o = Fi[i],
			s = "&" + o
		return n && Vy.includes(o) && !By.includes(o) && (!r || (t && t !== 61 && Fy.test(String.fromCharCode(t))))
			? s
			: s + ";"
	}
	return ""
}
function Hy(e, t, n) {
	let r = Ny(e, t, n.omitOptionalSemicolons),
		i
	if (
		((n.useNamedReferences || n.useShortestReferences) && (i = jy(e, t, n.omitOptionalSemicolons, n.attribute)),
		(n.useShortestReferences || !i) && n.useShortestReferences)
	) {
		const o = zy(e, t, n.omitOptionalSemicolons)
		o.length < r.length && (r = o)
	}
	return i && (!n.useShortestReferences || i.length < r.length) ? i : r
}
function Jt(e, t) {
	return Ly(e, Object.assign({ format: Hy }, t))
}
const Gy = /^>|^->|<!--|-->|--!>|<!-$/g,
	$y = [">"],
	Uy = ["<", ">"]
function qy(e, t, n, r) {
	return r.settings.bogusComments
		? "<?" + Jt(e.value, Object.assign({}, r.settings.characterReferences, { subset: $y })) + ">"
		: "<!--" + e.value.replace(Gy, i) + "-->"
	function i(o) {
		return Jt(o, Object.assign({}, r.settings.characterReferences, { subset: Uy }))
	}
}
function Wy(e, t, n, r) {
	return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>"
}
const Ce = hu(1),
	pu = hu(-1),
	Ky = []
function hu(e) {
	return t
	function t(n, r, i) {
		const o = n ? n.children : Ky
		let s = (r || 0) + e,
			a = o[s]
		if (!i) for (; a && Pr(a); ) (s += e), (a = o[s])
		return a
	}
}
const Yy = {}.hasOwnProperty
function fu(e) {
	return t
	function t(n, r, i) {
		return Yy.call(e, n.tagName) && e[n.tagName](n, r, i)
	}
}
const yo = fu({
	body: Qy,
	caption: fi,
	colgroup: fi,
	dd: tx,
	dt: ex,
	head: fi,
	html: Xy,
	li: Zy,
	optgroup: nx,
	option: rx,
	p: Jy,
	rp: qs,
	rt: qs,
	tbody: ox,
	td: Ws,
	tfoot: sx,
	th: Ws,
	thead: ix,
	tr: ax,
})
function fi(e, t, n) {
	const r = Ce(n, t, !0)
	return !r || (r.type !== "comment" && !(r.type === "text" && Pr(r.value.charAt(0))))
}
function Xy(e, t, n) {
	const r = Ce(n, t)
	return !r || r.type !== "comment"
}
function Qy(e, t, n) {
	const r = Ce(n, t)
	return !r || r.type !== "comment"
}
function Jy(e, t, n) {
	const r = Ce(n, t)
	return r
		? r.type === "element" &&
				(r.tagName === "address" ||
					r.tagName === "article" ||
					r.tagName === "aside" ||
					r.tagName === "blockquote" ||
					r.tagName === "details" ||
					r.tagName === "div" ||
					r.tagName === "dl" ||
					r.tagName === "fieldset" ||
					r.tagName === "figcaption" ||
					r.tagName === "figure" ||
					r.tagName === "footer" ||
					r.tagName === "form" ||
					r.tagName === "h1" ||
					r.tagName === "h2" ||
					r.tagName === "h3" ||
					r.tagName === "h4" ||
					r.tagName === "h5" ||
					r.tagName === "h6" ||
					r.tagName === "header" ||
					r.tagName === "hgroup" ||
					r.tagName === "hr" ||
					r.tagName === "main" ||
					r.tagName === "menu" ||
					r.tagName === "nav" ||
					r.tagName === "ol" ||
					r.tagName === "p" ||
					r.tagName === "pre" ||
					r.tagName === "section" ||
					r.tagName === "table" ||
					r.tagName === "ul")
		: !n ||
				!(
					n.type === "element" &&
					(n.tagName === "a" ||
						n.tagName === "audio" ||
						n.tagName === "del" ||
						n.tagName === "ins" ||
						n.tagName === "map" ||
						n.tagName === "noscript" ||
						n.tagName === "video")
				)
}
function Zy(e, t, n) {
	const r = Ce(n, t)
	return !r || (r.type === "element" && r.tagName === "li")
}
function ex(e, t, n) {
	const r = Ce(n, t)
	return !!(r && r.type === "element" && (r.tagName === "dt" || r.tagName === "dd"))
}
function tx(e, t, n) {
	const r = Ce(n, t)
	return !r || (r.type === "element" && (r.tagName === "dt" || r.tagName === "dd"))
}
function qs(e, t, n) {
	const r = Ce(n, t)
	return !r || (r.type === "element" && (r.tagName === "rp" || r.tagName === "rt"))
}
function nx(e, t, n) {
	const r = Ce(n, t)
	return !r || (r.type === "element" && r.tagName === "optgroup")
}
function rx(e, t, n) {
	const r = Ce(n, t)
	return !r || (r.type === "element" && (r.tagName === "option" || r.tagName === "optgroup"))
}
function ix(e, t, n) {
	const r = Ce(n, t)
	return !!(r && r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot"))
}
function ox(e, t, n) {
	const r = Ce(n, t)
	return !r || (r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot"))
}
function sx(e, t, n) {
	return !Ce(n, t)
}
function ax(e, t, n) {
	const r = Ce(n, t)
	return !r || (r.type === "element" && r.tagName === "tr")
}
function Ws(e, t, n) {
	const r = Ce(n, t)
	return !r || (r.type === "element" && (r.tagName === "td" || r.tagName === "th"))
}
const lx = fu({ body: mx, colgroup: px, head: cx, html: ux, tbody: hx })
function ux(e) {
	const t = Ce(e, -1)
	return !t || t.type !== "comment"
}
function cx(e) {
	const t = new Set()
	for (const r of e.children)
		if (r.type === "element" && (r.tagName === "base" || r.tagName === "title")) {
			if (t.has(r.tagName)) return !1
			t.add(r.tagName)
		}
	const n = e.children[0]
	return !n || n.type === "element"
}
function mx(e) {
	const t = Ce(e, -1, !0)
	return (
		!t ||
		(t.type !== "comment" &&
			!(t.type === "text" && Pr(t.value.charAt(0))) &&
			!(
				t.type === "element" &&
				(t.tagName === "meta" ||
					t.tagName === "link" ||
					t.tagName === "script" ||
					t.tagName === "style" ||
					t.tagName === "template")
			))
	)
}
function px(e, t, n) {
	const r = pu(n, t),
		i = Ce(e, -1, !0)
	return n && r && r.type === "element" && r.tagName === "colgroup" && yo(r, n.children.indexOf(r), n)
		? !1
		: !!(i && i.type === "element" && i.tagName === "col")
}
function hx(e, t, n) {
	const r = pu(n, t),
		i = Ce(e, -1)
	return n &&
		r &&
		r.type === "element" &&
		(r.tagName === "thead" || r.tagName === "tbody") &&
		yo(r, n.children.indexOf(r), n)
		? !1
		: !!(i && i.type === "element" && i.tagName === "tr")
}
const Jn = {
	name: [
		[
			`	
\f\r &/=>`.split(""),
			`	
\f\r "&'/=>\``.split(""),
		],
		[
			`\0	
\f\r "&'/<=>`.split(""),
			`\0	
\f\r "&'/<=>\``.split(""),
		],
	],
	unquoted: [
		[
			`	
\f\r &>`.split(""),
			`\0	
\f\r "&'<=>\``.split(""),
		],
		[
			`\0	
\f\r "&'<=>\``.split(""),
			`\0	
\f\r "&'<=>\``.split(""),
		],
	],
	single: [
		["&'".split(""), "\"&'`".split("")],
		["\0&'".split(""), "\0\"&'`".split("")],
	],
	double: [
		['"&'.split(""), "\"&'`".split("")],
		['\0"&'.split(""), "\0\"&'`".split("")],
	],
}
function fx(e, t, n, r) {
	const i = r.schema,
		o = i.space === "svg" ? !1 : r.settings.omitOptionalTags
	let s = i.space === "svg" ? r.settings.closeEmptyElements : r.settings.voids.includes(e.tagName.toLowerCase())
	const a = []
	let l
	i.space === "html" && e.tagName === "svg" && (r.schema = Bn)
	const u = dx(r, e.properties),
		m = r.all(i.space === "html" && e.tagName === "template" ? e.content : e)
	return (
		(r.schema = i),
		m && (s = !1),
		(u || !o || !lx(e, t, n)) &&
			(a.push("<", e.tagName, u ? " " + u : ""),
			s &&
				(i.space === "svg" || r.settings.closeSelfClosing) &&
				((l = u.charAt(u.length - 1)),
				(!r.settings.tightSelfClosing || l === "/" || (l && l !== '"' && l !== "'")) && a.push(" "),
				a.push("/")),
			a.push(">")),
		a.push(m),
		!s && (!o || !yo(e, t, n)) && a.push("</" + e.tagName + ">"),
		a.join("")
	)
}
function dx(e, t) {
	const n = []
	let r = -1,
		i
	if (t) {
		for (i in t)
			if (t[i] !== null && t[i] !== void 0) {
				const o = gx(e, i, t[i])
				o && n.push(o)
			}
	}
	for (; ++r < n.length; ) {
		const o = e.settings.tightAttributes ? n[r].charAt(n[r].length - 1) : void 0
		r !== n.length - 1 && o !== '"' && o !== "'" && (n[r] += " ")
	}
	return n.join("")
}
function gx(e, t, n) {
	const r = Xa(e.schema, t),
		i = e.settings.allowParseErrors && e.schema.space === "html" ? 0 : 1,
		o = e.settings.allowDangerousCharacters ? 0 : 1
	let s = e.quote,
		a
	if (
		(r.overloadedBoolean && (n === r.attribute || n === "")
			? (n = !0)
			: (r.boolean || r.overloadedBoolean) &&
				(typeof n != "string" || n === r.attribute || n === "") &&
				(n = !!n),
		n == null || n === !1 || (typeof n == "number" && Number.isNaN(n)))
	)
		return ""
	const l = Jt(r.attribute, Object.assign({}, e.settings.characterReferences, { subset: Jn.name[i][o] }))
	return n === !0 ||
		((n = Array.isArray(n)
			? (r.commaSeparated ? Ha : Ja)(n, { padLeft: !e.settings.tightCommaSeparatedLists })
			: String(n)),
		e.settings.collapseEmptyAttributes && !n)
		? l
		: (e.settings.preferUnquoted &&
				(a = Jt(
					n,
					Object.assign({}, e.settings.characterReferences, { attribute: !0, subset: Jn.unquoted[i][o] }),
				)),
			a !== n &&
				(e.settings.quoteSmart && hr(n, s) > hr(n, e.alternative) && (s = e.alternative),
				(a =
					s +
					Jt(
						n,
						Object.assign({}, e.settings.characterReferences, {
							subset: (s === "'" ? Jn.single : Jn.double)[i][o],
							attribute: !0,
						}),
					) +
					s)),
			l + (a && "=" + a))
}
const _x = ["<", "&"]
function du(e, t, n, r) {
	return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style")
		? e.value
		: Jt(e.value, Object.assign({}, r.settings.characterReferences, { subset: _x }))
}
function yx(e, t, n, r) {
	return r.settings.allowDangerousHtml ? e.value : du(e, t, n, r)
}
function xx(e, t, n, r) {
	return r.all(e)
}
const bx = fg("type", {
	invalid: kx,
	unknown: wx,
	handlers: { comment: qy, doctype: Wy, element: fx, raw: yx, root: xx, text: du },
})
function kx(e) {
	throw new Error("Expected node, not `" + e + "`")
}
function wx(e) {
	const t = e
	throw new Error("Cannot compile unknown node `" + t.type + "`")
}
const Ex = {},
	vx = {},
	Sx = []
function Ix(e, t) {
	const n = t || Ex,
		r = n.quote || '"',
		i = r === '"' ? "'" : '"'
	if (r !== '"' && r !== "'") throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`")
	return {
		one: Tx,
		all: Cx,
		settings: {
			omitOptionalTags: n.omitOptionalTags || !1,
			allowParseErrors: n.allowParseErrors || !1,
			allowDangerousCharacters: n.allowDangerousCharacters || !1,
			quoteSmart: n.quoteSmart || !1,
			preferUnquoted: n.preferUnquoted || !1,
			tightAttributes: n.tightAttributes || !1,
			upperDoctype: n.upperDoctype || !1,
			tightDoctype: n.tightDoctype || !1,
			bogusComments: n.bogusComments || !1,
			tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
			tightSelfClosing: n.tightSelfClosing || !1,
			collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
			allowDangerousHtml: n.allowDangerousHtml || !1,
			voids: n.voids || Iy,
			characterReferences: n.characterReferences || vx,
			closeSelfClosing: n.closeSelfClosing || !1,
			closeEmptyElements: n.closeEmptyElements || !1,
		},
		schema: n.space === "svg" ? Bn : Qa,
		quote: r,
		alternative: i,
	}.one(Array.isArray(e) ? { type: "root", children: e } : e, void 0, void 0)
}
function Tx(e, t, n) {
	return bx(e, t, n, this)
}
function Cx(e) {
	const t = [],
		n = (e && e.children) || Sx
	let r = -1
	for (; ++r < n.length; ) t[r] = this.one(n[r], r, e)
	return t.join("")
}
function br(e, t) {
	const n = typeof e == "string" ? {} : { ...e.colorReplacements },
		r = typeof e == "string" ? e : e.name
	for (const [i, o] of Object.entries((t == null ? void 0 : t.colorReplacements) || {}))
		typeof o == "string" ? (n[i] = o) : i === r && Object.assign(n, o)
	return n
}
function Vt(e, t) {
	return e && ((t == null ? void 0 : t[e == null ? void 0 : e.toLowerCase()]) || e)
}
function Ax(e) {
	return Array.isArray(e) ? e : [e]
}
async function gu(e) {
	return Promise.resolve(typeof e == "function" ? e() : e).then((t) => t.default || t)
}
function xo(e) {
	return !e || ["plaintext", "txt", "text", "plain"].includes(e)
}
function _u(e) {
	return e === "ansi" || xo(e)
}
function bo(e) {
	return e === "none"
}
function yu(e) {
	return bo(e)
}
function xu(e, t) {
	var r
	if (!t) return e
	e.properties || (e.properties = {}),
		(r = e.properties).class || (r.class = []),
		typeof e.properties.class == "string" && (e.properties.class = e.properties.class.split(/\s+/g)),
		Array.isArray(e.properties.class) || (e.properties.class = [])
	const n = Array.isArray(t) ? t : t.split(/\s+/g)
	for (const i of n) i && !e.properties.class.includes(i) && e.properties.class.push(i)
	return e
}
function Vr(e, t = !1) {
	var o
	const n = e.split(/(\r?\n)/g)
	let r = 0
	const i = []
	for (let s = 0; s < n.length; s += 2) {
		const a = t ? n[s] + (n[s + 1] || "") : n[s]
		i.push([a, r]), (r += n[s].length), (r += ((o = n[s + 1]) == null ? void 0 : o.length) || 0)
	}
	return i
}
function Rx(e) {
	const t = Vr(e, !0).map(([i]) => i)
	function n(i) {
		if (i === e.length) return { line: t.length - 1, character: t[t.length - 1].length }
		let o = i,
			s = 0
		for (const a of t) {
			if (o < a.length) break
			;(o -= a.length), s++
		}
		return { line: s, character: o }
	}
	function r(i, o) {
		let s = 0
		for (let a = 0; a < i; a++) s += t[a].length
		return (s += o), s
	}
	return { lines: t, indexToPos: n, posToIndex: r }
}
function Lx(e, t, n) {
	const r = new Set()
	for (const o of e.matchAll(/lang=["']([\w-]+)["']/g)) r.add(o[1])
	for (const o of e.matchAll(/(?:```|~~~)([\w-]+)/g)) r.add(o[1])
	for (const o of e.matchAll(/\\begin\{([\w-]+)\}/g)) r.add(o[1])
	if (!n) return Array.from(r)
	const i = n.getBundledLanguages()
	return Array.from(r).filter((o) => o && i[o])
}
function Px(e, t) {
	let n = 0
	const r = []
	for (const i of t) i > n && r.push({ ...e, content: e.content.slice(n, i), offset: e.offset + n }), (n = i)
	return n < e.content.length && r.push({ ...e, content: e.content.slice(n), offset: e.offset + n }), r
}
function Ox(e, t) {
	const n = Array.from(t instanceof Set ? t : new Set(t)).sort((r, i) => r - i)
	return n.length
		? e.map((r) =>
				r.flatMap((i) => {
					const o = n
						.filter((s) => i.offset < s && s < i.offset + i.content.length)
						.map((s) => s - i.offset)
						.sort((s, a) => s - a)
					return o.length ? Px(i, o) : i
				}),
			)
		: e
}
function Dx(e, t, n, r) {
	const i = { content: e.content, explanation: e.explanation, offset: e.offset },
		o = t.map((l) => kr(e.variants[l])),
		s = new Set(o.flatMap((l) => Object.keys(l))),
		a = {}
	return (
		o.forEach((l, u) => {
			for (const m of s) {
				const c = l[m] || "inherit"
				if (u === 0 && r) a[m] = c
				else {
					const h = m === "color" ? "" : m === "background-color" ? "-bg" : `-${m}`,
						p = n + t[u] + (m === "color" ? "" : h)
					a[p] = c
				}
			}
		}),
		(i.htmlStyle = a),
		i
	)
}
function kr(e) {
	const t = {}
	if ((e.color && (t.color = e.color), e.bgColor && (t["background-color"] = e.bgColor), e.fontStyle)) {
		e.fontStyle & Ne.Italic && (t["font-style"] = "italic"), e.fontStyle & Ne.Bold && (t["font-weight"] = "bold")
		const n = []
		e.fontStyle & Ne.Underline && n.push("underline"),
			e.fontStyle & Ne.Strikethrough && n.push("line-through"),
			n.length && (t["text-decoration"] = n.join(" "))
	}
	return t
}
function ji(e) {
	return typeof e == "string"
		? e
		: Object.entries(e)
				.map(([t, n]) => `${t}:${n}`)
				.join(";")
}
const bu = new WeakMap()
function Br(e, t) {
	bu.set(e, t)
}
function On(e) {
	return bu.get(e)
}
class an {
	constructor(...t) {
		R(this, "_stacks", {})
		R(this, "lang")
		if (t.length === 2) {
			const [n, r] = t
			;(this.lang = r), (this._stacks = n)
		} else {
			const [n, r, i] = t
			;(this.lang = r), (this._stacks = { [i]: n })
		}
	}
	get themes() {
		return Object.keys(this._stacks)
	}
	get theme() {
		return this.themes[0]
	}
	get _stack() {
		return this._stacks[this.theme]
	}
	static initial(t, n) {
		return new an(Object.fromEntries(Ax(n).map((r) => [r, Bi])), t)
	}
	getInternalStack(t = this.theme) {
		return this._stacks[t]
	}
	getScopes(t = this.theme) {
		return Nx(this._stacks[t])
	}
	toJSON() {
		return { lang: this.lang, theme: this.theme, themes: this.themes, scopes: this.getScopes() }
	}
}
function Nx(e) {
	const t = [],
		n = new Set()
	function r(i) {
		var s
		if (n.has(i)) return
		n.add(i)
		const o = (s = i == null ? void 0 : i.nameScopesList) == null ? void 0 : s.scopeName
		o && t.push(o), i.parent && r(i.parent)
	}
	return r(e), t
}
function Mx(e, t) {
	if (!(e instanceof an)) throw new Re("Invalid grammar state")
	return e.getInternalStack(t)
}
function zx() {
	const e = new WeakMap()
	function t(n) {
		if (!e.has(n.meta)) {
			let r = function (s) {
				if (typeof s == "number") {
					if (s < 0 || s > n.source.length)
						throw new Re(`Invalid decoration offset: ${s}. Code length: ${n.source.length}`)
					return { ...i.indexToPos(s), offset: s }
				} else {
					const a = i.lines[s.line]
					if (a === void 0)
						throw new Re(
							`Invalid decoration position ${JSON.stringify(s)}. Lines length: ${i.lines.length}`,
						)
					if (s.character < 0 || s.character > a.length)
						throw new Re(
							`Invalid decoration position ${JSON.stringify(s)}. Line ${s.line} length: ${a.length}`,
						)
					return { ...s, offset: i.posToIndex(s.line, s.character) }
				}
			}
			const i = Rx(n.source),
				o = (n.options.decorations || []).map((s) => ({ ...s, start: r(s.start), end: r(s.end) }))
			Vx(o), e.set(n.meta, { decorations: o, converter: i, source: n.source })
		}
		return e.get(n.meta)
	}
	return {
		name: "shiki:decorations",
		tokens(n) {
			var s
			if (!((s = this.options.decorations) != null && s.length)) return
			const i = t(this).decorations.flatMap((a) => [a.start.offset, a.end.offset])
			return Ox(n, i)
		},
		code(n) {
			var m
			if (!((m = this.options.decorations) != null && m.length)) return
			const r = t(this),
				i = Array.from(n.children).filter((c) => c.type === "element" && c.tagName === "span")
			if (i.length !== r.converter.lines.length)
				throw new Re(
					`Number of lines in code element (${i.length}) does not match the number of lines in the source (${r.converter.lines.length}). Failed to apply decorations.`,
				)
			function o(c, h, p, f) {
				const y = i[c]
				let x = "",
					d = -1,
					_ = -1
				if (
					(h === 0 && (d = 0),
					p === 0 && (_ = 0),
					p === Number.POSITIVE_INFINITY && (_ = y.children.length),
					d === -1 || _ === -1)
				)
					for (let I = 0; I < y.children.length; I++)
						(x += ku(y.children[I])),
							d === -1 && x.length === h && (d = I + 1),
							_ === -1 && x.length === p && (_ = I + 1)
				if (d === -1) throw new Re(`Failed to find start index for decoration ${JSON.stringify(f.start)}`)
				if (_ === -1) throw new Re(`Failed to find end index for decoration ${JSON.stringify(f.end)}`)
				const w = y.children.slice(d, _)
				if (!f.alwaysWrap && w.length === y.children.length) a(y, f, "line")
				else if (!f.alwaysWrap && w.length === 1 && w[0].type === "element") a(w[0], f, "token")
				else {
					const I = { type: "element", tagName: "span", properties: {}, children: w }
					a(I, f, "wrapper"), y.children.splice(d, w.length, I)
				}
			}
			function s(c, h) {
				i[c] = a(i[c], h, "line")
			}
			function a(c, h, p) {
				var x
				const f = h.properties || {},
					y = h.transform || ((d) => d)
				return (
					(c.tagName = h.tagName || "span"),
					(c.properties = { ...c.properties, ...f, class: c.properties.class }),
					(x = h.properties) != null && x.class && xu(c, h.properties.class),
					(c = y(c, p) || c),
					c
				)
			}
			const l = [],
				u = r.decorations.sort((c, h) => h.start.offset - c.start.offset || c.end.offset - h.end.offset)
			for (const c of u) {
				const { start: h, end: p } = c
				if (h.line === p.line) o(h.line, h.character, p.character, c)
				else if (h.line < p.line) {
					o(h.line, h.character, Number.POSITIVE_INFINITY, c)
					for (let f = h.line + 1; f < p.line; f++) l.unshift(() => s(f, c))
					o(p.line, 0, p.character, c)
				}
			}
			l.forEach((c) => c())
		},
	}
}
function Vx(e) {
	for (let t = 0; t < e.length; t++) {
		const n = e[t]
		if (n.start.offset > n.end.offset)
			throw new Re(`Invalid decoration range: ${JSON.stringify(n.start)} - ${JSON.stringify(n.end)}`)
		for (let r = t + 1; r < e.length; r++) {
			const i = e[r],
				o = n.start.offset <= i.start.offset && i.start.offset < n.end.offset,
				s = n.start.offset < i.end.offset && i.end.offset <= n.end.offset,
				a = i.start.offset <= n.start.offset && n.start.offset < i.end.offset,
				l = i.start.offset < n.end.offset && n.end.offset <= i.end.offset
			if (o || s || a || l) {
				if ((o && s) || (a && l)) continue
				throw new Re(`Decorations ${JSON.stringify(n.start)} and ${JSON.stringify(i.start)} intersect.`)
			}
		}
	}
}
function ku(e) {
	return e.type === "text" ? e.value : e.type === "element" ? e.children.map(ku).join("") : ""
}
const Bx = [zx()]
function wr(e) {
	return [...(e.transformers || []), ...Bx]
}
var Bt = [
		"black",
		"red",
		"green",
		"yellow",
		"blue",
		"magenta",
		"cyan",
		"white",
		"brightBlack",
		"brightRed",
		"brightGreen",
		"brightYellow",
		"brightBlue",
		"brightMagenta",
		"brightCyan",
		"brightWhite",
	],
	di = { 1: "bold", 2: "dim", 3: "italic", 4: "underline", 7: "reverse", 8: "hidden", 9: "strikethrough" }
function Fx(e, t) {
	const n = e.indexOf("\x1B", t)
	if (n !== -1 && e[n + 1] === "[") {
		const r = e.indexOf("m", n)
		if (r !== -1) return { sequence: e.substring(n + 2, r).split(";"), startPosition: n, position: r + 1 }
	}
	return { position: e.length }
}
function Ks(e) {
	const t = e.shift()
	if (t === "2") {
		const n = e.splice(0, 3).map((r) => Number.parseInt(r))
		return n.length !== 3 || n.some((r) => Number.isNaN(r)) ? void 0 : { type: "rgb", rgb: n }
	} else if (t === "5") {
		const n = e.shift()
		if (n) return { type: "table", index: Number(n) }
	}
}
function jx(e) {
	const t = []
	for (; e.length > 0; ) {
		const n = e.shift()
		if (!n) continue
		const r = Number.parseInt(n)
		if (!Number.isNaN(r))
			if (r === 0) t.push({ type: "resetAll" })
			else if (r <= 9) di[r] && t.push({ type: "setDecoration", value: di[r] })
			else if (r <= 29) {
				const i = di[r - 20]
				i &&
					(t.push({ type: "resetDecoration", value: i }),
					i === "dim" && t.push({ type: "resetDecoration", value: "bold" }))
			} else if (r <= 37) t.push({ type: "setForegroundColor", value: { type: "named", name: Bt[r - 30] } })
			else if (r === 38) {
				const i = Ks(e)
				i && t.push({ type: "setForegroundColor", value: i })
			} else if (r === 39) t.push({ type: "resetForegroundColor" })
			else if (r <= 47) t.push({ type: "setBackgroundColor", value: { type: "named", name: Bt[r - 40] } })
			else if (r === 48) {
				const i = Ks(e)
				i && t.push({ type: "setBackgroundColor", value: i })
			} else
				r === 49
					? t.push({ type: "resetBackgroundColor" })
					: r === 53
						? t.push({ type: "setDecoration", value: "overline" })
						: r === 55
							? t.push({ type: "resetDecoration", value: "overline" })
							: r >= 90 && r <= 97
								? t.push({ type: "setForegroundColor", value: { type: "named", name: Bt[r - 90 + 8] } })
								: r >= 100 &&
									r <= 107 &&
									t.push({
										type: "setBackgroundColor",
										value: { type: "named", name: Bt[r - 100 + 8] },
									})
	}
	return t
}
function Hx() {
	let e = null,
		t = null,
		n = new Set()
	return {
		parse(r) {
			const i = []
			let o = 0
			do {
				const s = Fx(r, o),
					a = s.sequence ? r.substring(o, s.startPosition) : r.substring(o)
				if (
					(a.length > 0 && i.push({ value: a, foreground: e, background: t, decorations: new Set(n) }),
					s.sequence)
				) {
					const l = jx(s.sequence)
					for (const u of l)
						u.type === "resetAll"
							? ((e = null), (t = null), n.clear())
							: u.type === "resetForegroundColor"
								? (e = null)
								: u.type === "resetBackgroundColor"
									? (t = null)
									: u.type === "resetDecoration" && n.delete(u.value)
					for (const u of l)
						u.type === "setForegroundColor"
							? (e = u.value)
							: u.type === "setBackgroundColor"
								? (t = u.value)
								: u.type === "setDecoration" && n.add(u.value)
				}
				o = s.position
			} while (o < r.length)
			return i
		},
	}
}
var Gx = {
	black: "#000000",
	red: "#bb0000",
	green: "#00bb00",
	yellow: "#bbbb00",
	blue: "#0000bb",
	magenta: "#ff00ff",
	cyan: "#00bbbb",
	white: "#eeeeee",
	brightBlack: "#555555",
	brightRed: "#ff5555",
	brightGreen: "#00ff00",
	brightYellow: "#ffff55",
	brightBlue: "#5555ff",
	brightMagenta: "#ff55ff",
	brightCyan: "#55ffff",
	brightWhite: "#ffffff",
}
function $x(e = Gx) {
	function t(a) {
		return e[a]
	}
	function n(a) {
		return `#${a.map((l) => Math.max(0, Math.min(l, 255)).toString(16).padStart(2, "0")).join("")}`
	}
	let r
	function i() {
		if (r) return r
		r = []
		for (let u = 0; u < Bt.length; u++) r.push(t(Bt[u]))
		let a = [0, 95, 135, 175, 215, 255]
		for (let u = 0; u < 6; u++)
			for (let m = 0; m < 6; m++) for (let c = 0; c < 6; c++) r.push(n([a[u], a[m], a[c]]))
		let l = 8
		for (let u = 0; u < 24; u++, l += 10) r.push(n([l, l, l]))
		return r
	}
	function o(a) {
		return i()[a]
	}
	function s(a) {
		switch (a.type) {
			case "named":
				return t(a.name)
			case "rgb":
				return n(a.rgb)
			case "table":
				return o(a.index)
		}
	}
	return { value: s }
}
function Ux(e, t, n) {
	const r = br(e, n),
		i = Vr(t),
		o = $x(
			Object.fromEntries(
				Bt.map((a) => {
					var l
					return [
						a,
						(l = e.colors) == null ? void 0 : l[`terminal.ansi${a[0].toUpperCase()}${a.substring(1)}`],
					]
				}),
			),
		),
		s = Hx()
	return i.map((a) =>
		s.parse(a[0]).map((l) => {
			let u, m
			l.decorations.has("reverse")
				? ((u = l.background ? o.value(l.background) : e.bg), (m = l.foreground ? o.value(l.foreground) : e.fg))
				: ((u = l.foreground ? o.value(l.foreground) : e.fg),
					(m = l.background ? o.value(l.background) : void 0)),
				(u = Vt(u, r)),
				(m = Vt(m, r)),
				l.decorations.has("dim") && (u = qx(u))
			let c = Ne.None
			return (
				l.decorations.has("bold") && (c |= Ne.Bold),
				l.decorations.has("italic") && (c |= Ne.Italic),
				l.decorations.has("underline") && (c |= Ne.Underline),
				l.decorations.has("strikethrough") && (c |= Ne.Strikethrough),
				{ content: l.value, offset: a[1], color: u, bgColor: m, fontStyle: c }
			)
		}),
	)
}
function qx(e) {
	const t = e.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/)
	if (t)
		if (t[3]) {
			const r = Math.round(Number.parseInt(t[3], 16) / 2)
				.toString(16)
				.padStart(2, "0")
			return `#${t[1]}${t[2]}${r}`
		} else
			return t[2]
				? `#${t[1]}${t[2]}80`
				: `#${Array.from(t[1])
						.map((r) => `${r}${r}`)
						.join("")}80`
	const n = e.match(/var\((--[\w-]+-ansi-[\w-]+)\)/)
	return n ? `var(${n[1]}-dim)` : e
}
function ko(e, t, n = {}) {
	const { lang: r = "text", theme: i = e.getLoadedThemes()[0] } = n
	if (xo(r) || bo(i)) return Vr(t).map((l) => [{ content: l[0], offset: l[1] }])
	const { theme: o, colorMap: s } = e.setTheme(i)
	if (r === "ansi") return Ux(o, t, n)
	const a = e.getLanguage(r)
	if (n.grammarState) {
		if (n.grammarState.lang !== a.name)
			throw new Re(
				`Grammar state language "${n.grammarState.lang}" does not match highlight language "${a.name}"`,
			)
		if (!n.grammarState.themes.includes(o.name))
			throw new Re(`Grammar state themes "${n.grammarState.themes}" do not contain highlight theme "${o.name}"`)
	}
	return Kx(t, a, o, s, n)
}
function Wx(...e) {
	if (e.length === 2) return On(e[1])
	const [t, n, r = {}] = e,
		{ lang: i = "text", theme: o = t.getLoadedThemes()[0] } = r
	if (xo(i) || bo(o)) throw new Re("Plain language does not have grammar state")
	if (i === "ansi") throw new Re("ANSI language does not have grammar state")
	const { theme: s, colorMap: a } = t.setTheme(o),
		l = t.getLanguage(i)
	return new an(Er(n, l, s, a, r).stateStack, l.name, s.name)
}
function Kx(e, t, n, r, i) {
	const o = Er(e, t, n, r, i),
		s = new an(Er(e, t, n, r, i).stateStack, t.name, n.name)
	return Br(o.tokens, s), o.tokens
}
function Er(e, t, n, r, i) {
	const o = br(n, i),
		{ tokenizeMaxLineLength: s = 0, tokenizeTimeLimit: a = 500 } = i,
		l = Vr(e)
	let u = i.grammarState
			? (Mx(i.grammarState, n.name) ?? Bi)
			: i.grammarContextCode != null
				? Er(i.grammarContextCode, t, n, r, { ...i, grammarState: void 0, grammarContextCode: void 0 })
						.stateStack
				: Bi,
		m = []
	const c = []
	for (let h = 0, p = l.length; h < p; h++) {
		const [f, y] = l[h]
		if (f === "") {
			;(m = []), c.push([])
			continue
		}
		if (s > 0 && f.length >= s) {
			;(m = []), c.push([{ content: f, offset: y, color: "", fontStyle: 0 }])
			continue
		}
		let x, d, _
		i.includeExplanation && ((x = t.tokenizeLine(f, u, a)), (d = x.tokens), (_ = 0))
		const w = t.tokenizeLine2(f, u, a),
			I = w.tokens.length / 2
		for (let S = 0; S < I; S++) {
			const b = w.tokens[2 * S],
				T = S + 1 < I ? w.tokens[2 * S + 2] : f.length
			if (b === T) continue
			const P = w.tokens[2 * S + 1],
				z = Vt(r[tn.getForeground(P)], o),
				v = tn.getFontStyle(P),
				L = { content: f.substring(b, T), offset: y + b, color: z, fontStyle: v }
			if (i.includeExplanation) {
				const M = []
				if (i.includeExplanation !== "scopeName")
					for (const C of n.settings) {
						let j
						switch (typeof C.scope) {
							case "string":
								j = C.scope.split(/,/).map((Z) => Z.trim())
								break
							case "object":
								j = C.scope
								break
							default:
								continue
						}
						M.push({ settings: C, selectors: j.map((Z) => Z.split(/ /)) })
					}
				L.explanation = []
				let B = 0
				for (; b + B < T; ) {
					const C = d[_],
						j = f.substring(C.startIndex, C.endIndex)
					;(B += j.length),
						L.explanation.push({
							content: j,
							scopes: i.includeExplanation === "scopeName" ? Yx(C.scopes) : Xx(M, C.scopes),
						}),
						(_ += 1)
				}
			}
			m.push(L)
		}
		c.push(m), (m = []), (u = w.ruleStack)
	}
	return { tokens: c, stateStack: u }
}
function Yx(e) {
	return e.map((t) => ({ scopeName: t }))
}
function Xx(e, t) {
	const n = []
	for (let r = 0, i = t.length; r < i; r++) {
		const o = t[r]
		n[r] = { scopeName: o, themeMatches: Jx(e, o, t.slice(0, r)) }
	}
	return n
}
function Ys(e, t) {
	return e === t || (t.substring(0, e.length) === e && t[e.length] === ".")
}
function Qx(e, t, n) {
	if (!Ys(e[e.length - 1], t)) return !1
	let r = e.length - 2,
		i = n.length - 1
	for (; r >= 0 && i >= 0; ) Ys(e[r], n[i]) && (r -= 1), (i -= 1)
	return r === -1
}
function Jx(e, t, n) {
	const r = []
	for (const { selectors: i, settings: o } of e)
		for (const s of i)
			if (Qx(s, t, n)) {
				r.push(o)
				break
			}
	return r
}
function wu(e, t, n) {
	const r = Object.entries(n.themes)
			.filter((l) => l[1])
			.map((l) => ({ color: l[0], theme: l[1] })),
		i = r.map((l) => {
			const u = ko(e, t, { ...n, theme: l.theme }),
				m = On(u),
				c = typeof l.theme == "string" ? l.theme : l.theme.name
			return { tokens: u, state: m, theme: c }
		}),
		o = Zx(...i.map((l) => l.tokens)),
		s = o[0].map((l, u) =>
			l.map((m, c) => {
				const h = { content: m.content, variants: {}, offset: m.offset }
				return (
					"includeExplanation" in n && n.includeExplanation && (h.explanation = m.explanation),
					o.forEach((p, f) => {
						const { content: y, explanation: x, offset: d, ..._ } = p[u][c]
						h.variants[r[f].color] = _
					}),
					h
				)
			}),
		),
		a = i[0].state
			? new an(
					Object.fromEntries(
						i.map((l) => {
							var u
							return [l.theme, (u = l.state) == null ? void 0 : u.getInternalStack(l.theme)]
						}),
					),
					i[0].state.lang,
				)
			: void 0
	return a && Br(s, a), s
}
function Zx(...e) {
	const t = e.map(() => []),
		n = e.length
	for (let r = 0; r < e[0].length; r++) {
		const i = e.map((l) => l[r]),
			o = t.map(() => [])
		t.forEach((l, u) => l.push(o[u]))
		const s = i.map(() => 0),
			a = i.map((l) => l[0])
		for (; a.every((l) => l); ) {
			const l = Math.min(...a.map((u) => u.content.length))
			for (let u = 0; u < n; u++) {
				const m = a[u]
				m.content.length === l
					? (o[u].push(m), (s[u] += 1), (a[u] = i[u][s[u]]))
					: (o[u].push({ ...m, content: m.content.slice(0, l) }),
						(a[u] = { ...m, content: m.content.slice(l), offset: m.offset + l }))
			}
		}
	}
	return t
}
function vr(e, t, n) {
	let r, i, o, s, a, l
	if ("themes" in n) {
		const { defaultColor: u = "light", cssVariablePrefix: m = "--shiki-" } = n,
			c = Object.entries(n.themes)
				.filter((x) => x[1])
				.map((x) => ({ color: x[0], theme: x[1] }))
				.sort((x, d) => (x.color === u ? -1 : d.color === u ? 1 : 0))
		if (c.length === 0) throw new Re("`themes` option must not be empty")
		const h = wu(e, t, n)
		if (((l = On(h)), u && !c.find((x) => x.color === u)))
			throw new Re(`\`themes\` option must contain the defaultColor key \`${u}\``)
		const p = c.map((x) => e.getTheme(x.theme)),
			f = c.map((x) => x.color)
		;(o = h.map((x) => x.map((d) => Dx(d, f, m, u)))), l && Br(o, l)
		const y = c.map((x) => br(x.theme, n))
		;(i = c.map((x, d) => (d === 0 && u ? "" : `${m + x.color}:`) + (Vt(p[d].fg, y[d]) || "inherit")).join(";")),
			(r = c
				.map((x, d) => (d === 0 && u ? "" : `${m + x.color}-bg:`) + (Vt(p[d].bg, y[d]) || "inherit"))
				.join(";")),
			(s = `shiki-themes ${p.map((x) => x.name).join(" ")}`),
			(a = u ? void 0 : [i, r].join(";"))
	} else if ("theme" in n) {
		const u = br(n.theme, n)
		o = ko(e, t, n)
		const m = e.getTheme(n.theme)
		;(r = Vt(m.bg, u)), (i = Vt(m.fg, u)), (s = m.name), (l = On(o))
	} else throw new Re("Invalid options, either `theme` or `themes` must be provided")
	return { tokens: o, fg: i, bg: r, themeName: s, rootStyle: a, grammarState: l }
}
function Sr(
	e,
	t,
	n,
	r = { meta: {}, options: n, codeToHast: (i, o) => Sr(e, i, o), codeToTokens: (i, o) => vr(e, i, o) },
) {
	var f, y
	let i = t
	for (const x of wr(n)) i = ((f = x.preprocess) == null ? void 0 : f.call(r, i, n)) || i
	let { tokens: o, fg: s, bg: a, themeName: l, rootStyle: u, grammarState: m } = vr(e, i, n)
	const { mergeWhitespaces: c = !0, mergeSameStyleTokens: h = !1 } = n
	c === !0 ? (o = t0(o)) : c === "never" && (o = n0(o)), h && (o = r0(o))
	const p = {
		...r,
		get source() {
			return i
		},
	}
	for (const x of wr(n)) o = ((y = x.tokens) == null ? void 0 : y.call(p, o)) || o
	return e0(o, { ...n, fg: s, bg: a, themeName: l, rootStyle: u }, p, m)
}
function e0(e, t, n, r = On(e)) {
	var f, y, x
	const i = wr(t),
		o = [],
		s = { type: "root", children: [] },
		{ structure: a = "classic", tabindex: l = "0" } = t
	let u = {
			type: "element",
			tagName: "pre",
			properties: {
				class: `shiki ${t.themeName || ""}`,
				style: t.rootStyle || `background-color:${t.bg};color:${t.fg}`,
				...(l !== !1 && l != null ? { tabindex: l.toString() } : {}),
				...Object.fromEntries(Array.from(Object.entries(t.meta || {})).filter(([d]) => !d.startsWith("_"))),
			},
			children: [],
		},
		m = { type: "element", tagName: "code", properties: {}, children: o }
	const c = [],
		h = {
			...n,
			structure: a,
			addClassToHast: xu,
			get source() {
				return n.source
			},
			get tokens() {
				return e
			},
			get options() {
				return t
			},
			get root() {
				return s
			},
			get pre() {
				return u
			},
			get code() {
				return m
			},
			get lines() {
				return c
			},
		}
	if (
		(e.forEach((d, _) => {
			var S, b
			_ &&
				(a === "inline"
					? s.children.push({ type: "element", tagName: "br", properties: {}, children: [] })
					: a === "classic" &&
						o.push({
							type: "text",
							value: `
`,
						}))
			let w = { type: "element", tagName: "span", properties: { class: "line" }, children: [] },
				I = 0
			for (const T of d) {
				let P = {
					type: "element",
					tagName: "span",
					properties: { ...T.htmlAttrs },
					children: [{ type: "text", value: T.content }],
				}
				const z = ji(T.htmlStyle || kr(T))
				z && (P.properties.style = z)
				for (const v of i)
					P = ((S = v == null ? void 0 : v.span) == null ? void 0 : S.call(h, P, _ + 1, I, w, T)) || P
				a === "inline" ? s.children.push(P) : a === "classic" && w.children.push(P), (I += T.content.length)
			}
			if (a === "classic") {
				for (const T of i) w = ((b = T == null ? void 0 : T.line) == null ? void 0 : b.call(h, w, _ + 1)) || w
				c.push(w), o.push(w)
			}
		}),
		a === "classic")
	) {
		for (const d of i) m = ((f = d == null ? void 0 : d.code) == null ? void 0 : f.call(h, m)) || m
		u.children.push(m)
		for (const d of i) u = ((y = d == null ? void 0 : d.pre) == null ? void 0 : y.call(h, u)) || u
		s.children.push(u)
	}
	let p = s
	for (const d of i) p = ((x = d == null ? void 0 : d.root) == null ? void 0 : x.call(h, p)) || p
	return r && Br(p, r), p
}
function t0(e) {
	return e.map((t) => {
		const n = []
		let r = "",
			i = 0
		return (
			t.forEach((o, s) => {
				const l = !(o.fontStyle && (o.fontStyle & Ne.Underline || o.fontStyle & Ne.Strikethrough))
				l && o.content.match(/^\s+$/) && t[s + 1]
					? (i || (i = o.offset), (r += o.content))
					: r
						? (l
								? n.push({ ...o, offset: i, content: r + o.content })
								: n.push({ content: r, offset: i }, o),
							(i = 0),
							(r = ""))
						: n.push(o)
			}),
			n
		)
	})
}
function n0(e) {
	return e.map((t) =>
		t.flatMap((n) => {
			if (n.content.match(/^\s+$/)) return n
			const r = n.content.match(/^(\s*)(.*?)(\s*)$/)
			if (!r) return n
			const [, i, o, s] = r
			if (!i && !s) return n
			const a = [{ ...n, offset: n.offset + i.length, content: o }]
			return (
				i && a.unshift({ content: i, offset: n.offset }),
				s && a.push({ content: s, offset: n.offset + i.length + o.length }),
				a
			)
		}),
	)
}
function r0(e) {
	return e.map((t) => {
		const n = []
		for (const r of t) {
			if (n.length === 0) {
				n.push({ ...r })
				continue
			}
			const i = n[n.length - 1],
				o = i.htmlStyle || ji(kr(i)),
				s = r.htmlStyle || ji(kr(r)),
				a = i.fontStyle && (i.fontStyle & Ne.Underline || i.fontStyle & Ne.Strikethrough),
				l = r.fontStyle && (r.fontStyle & Ne.Underline || r.fontStyle & Ne.Strikethrough)
			!a && !l && o === s ? (i.content += r.content) : n.push({ ...r })
		}
		return n
	})
}
const i0 = Ix
function o0(e, t, n) {
	var o
	const r = { meta: {}, options: n, codeToHast: (s, a) => Sr(e, s, a), codeToTokens: (s, a) => vr(e, s, a) }
	let i = i0(Sr(e, t, n, r))
	for (const s of wr(n)) i = ((o = s.postprocess) == null ? void 0 : o.call(r, i, n)) || i
	return i
}
const Xs = { light: "#333333", dark: "#bbbbbb" },
	Qs = { light: "#fffffe", dark: "#1e1e1e" },
	Js = "__shiki_resolved"
function wo(e) {
	var a, l, u, m, c
	if (e != null && e[Js]) return e
	const t = { ...e }
	t.tokenColors && !t.settings && ((t.settings = t.tokenColors), delete t.tokenColors),
		t.type || (t.type = "dark"),
		(t.colorReplacements = { ...t.colorReplacements }),
		t.settings || (t.settings = [])
	let { bg: n, fg: r } = t
	if (!n || !r) {
		const h = t.settings ? t.settings.find((p) => !p.name && !p.scope) : void 0
		;(a = h == null ? void 0 : h.settings) != null && a.foreground && (r = h.settings.foreground),
			(l = h == null ? void 0 : h.settings) != null && l.background && (n = h.settings.background),
			!r &&
				(u = t == null ? void 0 : t.colors) != null &&
				u["editor.foreground"] &&
				(r = t.colors["editor.foreground"]),
			!n &&
				(m = t == null ? void 0 : t.colors) != null &&
				m["editor.background"] &&
				(n = t.colors["editor.background"]),
			r || (r = t.type === "light" ? Xs.light : Xs.dark),
			n || (n = t.type === "light" ? Qs.light : Qs.dark),
			(t.fg = r),
			(t.bg = n)
	}
	;(t.settings[0] && t.settings[0].settings && !t.settings[0].scope) ||
		t.settings.unshift({ settings: { foreground: t.fg, background: t.bg } })
	let i = 0
	const o = new Map()
	function s(h) {
		var f
		if (o.has(h)) return o.get(h)
		i += 1
		const p = `#${i.toString(16).padStart(8, "0").toLowerCase()}`
		return (f = t.colorReplacements) != null && f[`#${p}`] ? s(h) : (o.set(h, p), p)
	}
	t.settings = t.settings.map((h) => {
		var x, d
		const p = ((x = h.settings) == null ? void 0 : x.foreground) && !h.settings.foreground.startsWith("#"),
			f = ((d = h.settings) == null ? void 0 : d.background) && !h.settings.background.startsWith("#")
		if (!p && !f) return h
		const y = { ...h, settings: { ...h.settings } }
		if (p) {
			const _ = s(h.settings.foreground)
			;(t.colorReplacements[_] = h.settings.foreground), (y.settings.foreground = _)
		}
		if (f) {
			const _ = s(h.settings.background)
			;(t.colorReplacements[_] = h.settings.background), (y.settings.background = _)
		}
		return y
	})
	for (const h of Object.keys(t.colors || {}))
		if (
			(h === "editor.foreground" || h === "editor.background" || h.startsWith("terminal.ansi")) &&
			!((c = t.colors[h]) != null && c.startsWith("#"))
		) {
			const p = s(t.colors[h])
			;(t.colorReplacements[p] = t.colors[h]), (t.colors[h] = p)
		}
	return Object.defineProperty(t, Js, { enumerable: !1, writable: !1, value: !0 }), t
}
async function Eu(e) {
	return Array.from(
		new Set(
			(
				await Promise.all(
					e.filter((t) => !_u(t)).map(async (t) => await gu(t).then((n) => (Array.isArray(n) ? n : [n]))),
				)
			).flat(),
		),
	)
}
async function vu(e) {
	return (await Promise.all(e.map(async (n) => (yu(n) ? null : wo(await gu(n)))))).filter((n) => !!n)
}
let s0 = 3
function a0(e, t = 3) {
	t > s0 || console.trace(`[SHIKI DEPRECATE]: ${e}`)
}
let Yt = class extends Error {
	constructor(t) {
		super(t), (this.name = "ShikiError")
	}
}
class l0 extends Sy {
	constructor(n, r, i, o = {}) {
		super(n)
		R(this, "_resolvedThemes", new Map())
		R(this, "_resolvedGrammars", new Map())
		R(this, "_langMap", new Map())
		R(this, "_langGraph", new Map())
		R(this, "_textmateThemeCache", new WeakMap())
		R(this, "_loadedThemesCache", null)
		R(this, "_loadedLanguagesCache", null)
		;(this._resolver = n),
			(this._themes = r),
			(this._langs = i),
			(this._alias = o),
			this._themes.map((s) => this.loadTheme(s)),
			this.loadLanguages(this._langs)
	}
	getTheme(n) {
		return typeof n == "string" ? this._resolvedThemes.get(n) : this.loadTheme(n)
	}
	loadTheme(n) {
		const r = wo(n)
		return r.name && (this._resolvedThemes.set(r.name, r), (this._loadedThemesCache = null)), r
	}
	getLoadedThemes() {
		return (
			this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]),
			this._loadedThemesCache
		)
	}
	setTheme(n) {
		let r = this._textmateThemeCache.get(n)
		r || ((r = dr.createFromRawTheme(n)), this._textmateThemeCache.set(n, r)), this._syncRegistry.setTheme(r)
	}
	getGrammar(n) {
		if (this._alias[n]) {
			const r = new Set([n])
			for (; this._alias[n]; ) {
				if (((n = this._alias[n]), r.has(n)))
					throw new Yt(`Circular alias \`${Array.from(r).join(" -> ")} -> ${n}\``)
				r.add(n)
			}
		}
		return this._resolvedGrammars.get(n)
	}
	loadLanguage(n) {
		var s, a, l, u
		if (this.getGrammar(n.name)) return
		const r = new Set(
			[...this._langMap.values()].filter((m) => {
				var c
				return (c = m.embeddedLangsLazy) == null ? void 0 : c.includes(n.name)
			}),
		)
		this._resolver.addLanguage(n)
		const i = {
			balancedBracketSelectors: n.balancedBracketSelectors || ["*"],
			unbalancedBracketSelectors: n.unbalancedBracketSelectors || [],
		}
		this._syncRegistry._rawGrammars.set(n.scopeName, n)
		const o = this.loadGrammarWithConfiguration(n.scopeName, 1, i)
		if (
			((o.name = n.name),
			this._resolvedGrammars.set(n.name, o),
			n.aliases &&
				n.aliases.forEach((m) => {
					this._alias[m] = n.name
				}),
			(this._loadedLanguagesCache = null),
			r.size)
		)
			for (const m of r)
				this._resolvedGrammars.delete(m.name),
					(this._loadedLanguagesCache = null),
					(a = (s = this._syncRegistry) == null ? void 0 : s._injectionGrammars) == null ||
						a.delete(m.scopeName),
					(u = (l = this._syncRegistry) == null ? void 0 : l._grammars) == null || u.delete(m.scopeName),
					this.loadLanguage(this._langMap.get(m.name))
	}
	dispose() {
		super.dispose(),
			this._resolvedThemes.clear(),
			this._resolvedGrammars.clear(),
			this._langMap.clear(),
			this._langGraph.clear(),
			(this._loadedThemesCache = null)
	}
	loadLanguages(n) {
		for (const o of n) this.resolveEmbeddedLanguages(o)
		const r = Array.from(this._langGraph.entries()),
			i = r.filter(([o, s]) => !s)
		if (i.length) {
			const o = r
				.filter(([s, a]) => {
					var l
					return a && ((l = a.embeddedLangs) == null ? void 0 : l.some((u) => i.map(([m]) => m).includes(u)))
				})
				.filter((s) => !i.includes(s))
			throw new Yt(
				`Missing languages ${i.map(([s]) => `\`${s}\``).join(", ")}, required by ${o.map(([s]) => `\`${s}\``).join(", ")}`,
			)
		}
		for (const [o, s] of r) this._resolver.addLanguage(s)
		for (const [o, s] of r) this.loadLanguage(s)
	}
	getLoadedLanguages() {
		return (
			this._loadedLanguagesCache ||
				(this._loadedLanguagesCache = [
					...new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)]),
				]),
			this._loadedLanguagesCache
		)
	}
	resolveEmbeddedLanguages(n) {
		if ((this._langMap.set(n.name, n), this._langGraph.set(n.name, n), n.embeddedLangs))
			for (const r of n.embeddedLangs) this._langGraph.set(r, this._langMap.get(r))
	}
}
class u0 {
	constructor(t, n) {
		R(this, "_langs", new Map())
		R(this, "_scopeToLang", new Map())
		R(this, "_injections", new Map())
		R(this, "_onigLib")
		;(this._onigLib = { createOnigScanner: (r) => t.createScanner(r), createOnigString: (r) => t.createString(r) }),
			n.forEach((r) => this.addLanguage(r))
	}
	get onigLib() {
		return this._onigLib
	}
	getLangRegistration(t) {
		return this._langs.get(t)
	}
	loadGrammar(t) {
		return this._scopeToLang.get(t)
	}
	addLanguage(t) {
		this._langs.set(t.name, t),
			t.aliases &&
				t.aliases.forEach((n) => {
					this._langs.set(n, t)
				}),
			this._scopeToLang.set(t.scopeName, t),
			t.injectTo &&
				t.injectTo.forEach((n) => {
					this._injections.get(n) || this._injections.set(n, []), this._injections.get(n).push(t.scopeName)
				})
	}
	getInjections(t) {
		const n = t.split(".")
		let r = []
		for (let i = 1; i <= n.length; i++) {
			const o = n.slice(0, i).join(".")
			r = [...r, ...(this._injections.get(o) || [])]
		}
		return r
	}
}
let dn = 0
function c0(e) {
	;(dn += 1),
		e.warnings !== !1 &&
			dn >= 10 &&
			dn % 10 === 0 &&
			console.warn(
				`[Shiki] ${dn} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`,
			)
	let t = !1
	if (!e.engine) throw new Yt("`engine` option is required for synchronous mode")
	const n = (e.langs || []).flat(1),
		r = (e.themes || []).flat(1).map(wo),
		i = new u0(e.engine, n),
		o = new l0(i, r, n, e.langAlias)
	let s
	function a(_) {
		x()
		const w = o.getGrammar(typeof _ == "string" ? _ : _.name)
		if (!w) throw new Yt(`Language \`${_}\` not found, you may need to load it first`)
		return w
	}
	function l(_) {
		if (_ === "none") return { bg: "", fg: "", name: "none", settings: [], type: "dark" }
		x()
		const w = o.getTheme(_)
		if (!w) throw new Yt(`Theme \`${_}\` not found, you may need to load it first`)
		return w
	}
	function u(_) {
		x()
		const w = l(_)
		s !== _ && (o.setTheme(w), (s = _))
		const I = o.getColorMap()
		return { theme: w, colorMap: I }
	}
	function m() {
		return x(), o.getLoadedThemes()
	}
	function c() {
		return x(), o.getLoadedLanguages()
	}
	function h(..._) {
		x(), o.loadLanguages(_.flat(1))
	}
	async function p(..._) {
		return h(await Eu(_))
	}
	function f(..._) {
		x()
		for (const w of _.flat(1)) o.loadTheme(w)
	}
	async function y(..._) {
		return x(), f(await vu(_))
	}
	function x() {
		if (t) throw new Yt("Shiki instance has been disposed")
	}
	function d() {
		t || ((t = !0), o.dispose(), (dn -= 1))
	}
	return {
		setTheme: u,
		getTheme: l,
		getLanguage: a,
		getLoadedThemes: m,
		getLoadedLanguages: c,
		loadLanguage: p,
		loadLanguageSync: h,
		loadTheme: y,
		loadThemeSync: f,
		dispose: d,
		[Symbol.dispose]: d,
	}
}
async function m0(e) {
	e.engine ||
		a0(
			"`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.",
		)
	const [t, n, r] = await Promise.all([vu(e.themes || []), Eu(e.langs || []), e.engine])
	return c0({ ...e, themes: t, langs: n, engine: r })
}
async function p0(e) {
	const t = await m0(e)
	return {
		getLastGrammarState: (...n) => Wx(t, ...n),
		codeToTokensBase: (n, r) => ko(t, n, r),
		codeToTokensWithThemes: (n, r) => wu(t, n, r),
		codeToTokens: (n, r) => vr(t, n, r),
		codeToHast: (n, r) => Sr(t, n, r),
		codeToHtml: (n, r) => o0(t, n, r),
		getBundledLanguages: () => ({}),
		getBundledThemes: () => ({}),
		...t,
		getInternalContext: () => t,
	}
}
function h0(e) {
	const t = e.langs,
		n = e.themes,
		r = e.engine
	async function i(o) {
		function s(c) {
			if (typeof c == "string") {
				if (_u(c)) return []
				const h = t[c]
				if (!h)
					throw new Re(
						`Language \`${c}\` is not included in this bundle. You may want to load it from external source.`,
					)
				return h
			}
			return c
		}
		function a(c) {
			if (yu(c)) return "none"
			if (typeof c == "string") {
				const h = n[c]
				if (!h)
					throw new Re(
						`Theme \`${c}\` is not included in this bundle. You may want to load it from external source.`,
					)
				return h
			}
			return c
		}
		const l = (o.themes ?? []).map((c) => a(c)),
			u = (o.langs ?? []).map((c) => s(c)),
			m = await p0({ engine: o.engine ?? r(), ...o, themes: l, langs: u })
		return {
			...m,
			loadLanguage(...c) {
				return m.loadLanguage(...c.map(s))
			},
			loadTheme(...c) {
				return m.loadTheme(...c.map(a))
			},
			getBundledLanguages() {
				return t
			},
			getBundledThemes() {
				return n
			},
		}
	}
	return i
}
function f0(e) {
	let t
	async function n(r = {}) {
		if (t) {
			const i = await t
			return await Promise.all([i.loadTheme(...(r.themes || [])), i.loadLanguage(...(r.langs || []))]), i
		} else return (t = e({ ...r, themes: r.themes || [], langs: r.langs || [] })), t
	}
	return n
}
function d0(e, t) {
	const n = f0(e)
	async function r(i, o) {
		var l
		const s = await n({ langs: [o.lang], themes: "theme" in o ? [o.theme] : Object.values(o.themes) }),
			a = await ((l = t == null ? void 0 : t.guessEmbeddedLanguages) == null ? void 0 : l.call(t, i, o.lang, s))
		return a && (await s.loadLanguage(...a)), s
	}
	return {
		getSingletonHighlighter(i) {
			return n(i)
		},
		async codeToHtml(i, o) {
			return (await r(i, o)).codeToHtml(i, o)
		},
		async codeToHast(i, o) {
			return (await r(i, o)).codeToHast(i, o)
		},
		async codeToTokens(i, o) {
			return (await r(i, o)).codeToTokens(i, o)
		},
		async codeToTokensBase(i, o) {
			return (await r(i, o)).codeToTokensBase(i, o)
		},
		async codeToTokensWithThemes(i, o) {
			return (await r(i, o)).codeToTokensWithThemes(i, o)
		},
		async getLastGrammarState(i, o) {
			return (await n({ langs: [o.lang], themes: [o.theme] })).getLastGrammarState(i, o)
		},
	}
}
const Su = [
		{ id: "abap", name: "ABAP", import: () => g(() => import("./abap-BdImnpbu.js"), [], import.meta.url) },
		{
			id: "actionscript-3",
			name: "ActionScript",
			import: () => g(() => import("./actionscript-3-CfeIJUat.js"), [], import.meta.url),
		},
		{ id: "ada", name: "Ada", import: () => g(() => import("./ada-bCR0ucgS.js"), [], import.meta.url) },
		{
			id: "angular-html",
			name: "Angular HTML",
			import: () =>
				g(
					() => import("./angular-html-Bbf3ZyxA.js").then((e) => e.f),
					__vite__mapDeps([0, 1, 2, 3]),
					import.meta.url,
				),
		},
		{
			id: "angular-ts",
			name: "Angular TypeScript",
			import: () =>
				g(() => import("./angular-ts-C26w9mnW.js"), __vite__mapDeps([4, 0, 1, 2, 3, 5]), import.meta.url),
		},
		{
			id: "apache",
			name: "Apache Conf",
			import: () => g(() => import("./apache-Pmp26Uib.js"), [], import.meta.url),
		},
		{ id: "apex", name: "Apex", import: () => g(() => import("./apex-QX45V2Sx.js"), [], import.meta.url) },
		{
			id: "apl",
			name: "APL",
			import: () => g(() => import("./apl-e980N3t4.js"), __vite__mapDeps([6, 1, 2, 3, 7, 8, 9]), import.meta.url),
		},
		{
			id: "applescript",
			name: "AppleScript",
			import: () => g(() => import("./applescript-Co6uUVPk.js"), [], import.meta.url),
		},
		{ id: "ara", name: "Ara", import: () => g(() => import("./ara-BRHolxvo.js"), [], import.meta.url) },
		{
			id: "asciidoc",
			name: "AsciiDoc",
			aliases: ["adoc"],
			import: () => g(() => import("./asciidoc-CdggvHu8.js"), [], import.meta.url),
		},
		{ id: "asm", name: "Assembly", import: () => g(() => import("./asm-D_Q5rh1f.js"), [], import.meta.url) },
		{
			id: "astro",
			name: "Astro",
			import: () =>
				g(() => import("./astro-DAp1zUbp.js"), __vite__mapDeps([10, 9, 2, 11, 3, 12]), import.meta.url),
		},
		{ id: "awk", name: "AWK", import: () => g(() => import("./awk-DMzUqQB5.js"), [], import.meta.url) },
		{
			id: "ballerina",
			name: "Ballerina",
			import: () => g(() => import("./ballerina-BFfxhgS-.js"), [], import.meta.url),
		},
		{
			id: "bat",
			name: "Batch File",
			aliases: ["batch"],
			import: () => g(() => import("./bat-BkioyH1T.js"), [], import.meta.url),
		},
		{
			id: "beancount",
			name: "Beancount",
			import: () => g(() => import("./beancount-BoKiGodi.js"), [], import.meta.url),
		},
		{
			id: "berry",
			name: "Berry",
			aliases: ["be"],
			import: () => g(() => import("./berry-D08WgyRC.js"), [], import.meta.url),
		},
		{ id: "bibtex", name: "BibTeX", import: () => g(() => import("./bibtex-CHM0blh-.js"), [], import.meta.url) },
		{ id: "bicep", name: "Bicep", import: () => g(() => import("./bicep-6nHXG8SA.js"), [], import.meta.url) },
		{
			id: "blade",
			name: "Blade",
			import: () =>
				g(
					() => import("./blade-DGJDb2eD.js"),
					__vite__mapDeps([13, 14, 1, 2, 3, 7, 8, 15, 9]),
					import.meta.url,
				),
		},
		{
			id: "bsl",
			name: "1C (Enterprise)",
			aliases: ["1c"],
			import: () => g(() => import("./bsl-BO_Y6i37.js"), __vite__mapDeps([16, 17]), import.meta.url),
		},
		{ id: "c", name: "C", import: () => g(() => import("./c-BIGW1oBm.js"), [], import.meta.url) },
		{
			id: "cadence",
			name: "Cadence",
			aliases: ["cdc"],
			import: () => g(() => import("./cadence-D2CYqzqI.js"), [], import.meta.url),
		},
		{
			id: "cairo",
			name: "Cairo",
			import: () => g(() => import("./cairo-KRGpt6FW.js"), __vite__mapDeps([18, 19]), import.meta.url),
		},
		{ id: "clarity", name: "Clarity", import: () => g(() => import("./clarity-CHh-QcGE.js"), [], import.meta.url) },
		{
			id: "clojure",
			name: "Clojure",
			aliases: ["clj"],
			import: () => g(() => import("./clojure-P80f7IUj.js"), [], import.meta.url),
		},
		{ id: "cmake", name: "CMake", import: () => g(() => import("./cmake-D1j8_8rp.js"), [], import.meta.url) },
		{
			id: "cobol",
			name: "COBOL",
			import: () => g(() => import("./cobol-CCPHrsME.js"), __vite__mapDeps([20, 1, 2, 3, 8]), import.meta.url),
		},
		{
			id: "codeowners",
			name: "CODEOWNERS",
			import: () => g(() => import("./codeowners-Bp6g37R7.js"), [], import.meta.url),
		},
		{
			id: "codeql",
			name: "CodeQL",
			aliases: ["ql"],
			import: () => g(() => import("./codeql-DsOJ9woJ.js"), [], import.meta.url),
		},
		{
			id: "coffee",
			name: "CoffeeScript",
			aliases: ["coffeescript"],
			import: () => g(() => import("./coffee-JUOWOZUj.js"), __vite__mapDeps([21, 2]), import.meta.url),
		},
		{
			id: "common-lisp",
			name: "Common Lisp",
			aliases: ["lisp"],
			import: () => g(() => import("./common-lisp-Cg-RD9OK.js"), [], import.meta.url),
		},
		{ id: "coq", name: "Coq", import: () => g(() => import("./coq-CMdgaOU9.js"), [], import.meta.url) },
		{
			id: "cpp",
			name: "C++",
			aliases: ["c++"],
			import: () => g(() => import("./cpp-ChttZZSa.js"), __vite__mapDeps([22, 23, 24, 25, 15]), import.meta.url),
		},
		{
			id: "crystal",
			name: "Crystal",
			import: () =>
				g(() => import("./crystal-CfkhwHAQ.js"), __vite__mapDeps([26, 1, 2, 3, 15, 25, 27]), import.meta.url),
		},
		{
			id: "csharp",
			name: "C#",
			aliases: ["c#", "cs"],
			import: () => g(() => import("./csharp-CHadp7IV.js"), [], import.meta.url),
		},
		{ id: "css", name: "CSS", import: () => g(() => import("./css-DPfMkruS.js"), [], import.meta.url) },
		{ id: "csv", name: "CSV", import: () => g(() => import("./csv-fuZLfV_i.js"), [], import.meta.url) },
		{ id: "cue", name: "CUE", import: () => g(() => import("./cue-D82EKSYY.js"), [], import.meta.url) },
		{
			id: "cypher",
			name: "Cypher",
			aliases: ["cql"],
			import: () => g(() => import("./cypher-COkxafJQ.js"), [], import.meta.url),
		},
		{ id: "d", name: "D", import: () => g(() => import("./d-85-TOEBH.js"), [], import.meta.url) },
		{ id: "dart", name: "Dart", import: () => g(() => import("./dart-CF10PKvl.js"), [], import.meta.url) },
		{ id: "dax", name: "DAX", import: () => g(() => import("./dax-CEL-wOlO.js"), [], import.meta.url) },
		{ id: "desktop", name: "Desktop", import: () => g(() => import("./desktop-BmXAJ9_W.js"), [], import.meta.url) },
		{ id: "diff", name: "Diff", import: () => g(() => import("./diff-D97Zzqfu.js"), [], import.meta.url) },
		{
			id: "docker",
			name: "Dockerfile",
			aliases: ["dockerfile"],
			import: () => g(() => import("./docker-BcOcwvcX.js"), [], import.meta.url),
		},
		{ id: "dotenv", name: "dotEnv", import: () => g(() => import("./dotenv-Da5cRb03.js"), [], import.meta.url) },
		{
			id: "dream-maker",
			name: "Dream Maker",
			import: () => g(() => import("./dream-maker-BtqSS_iP.js"), [], import.meta.url),
		},
		{
			id: "edge",
			name: "Edge",
			import: () =>
				g(() => import("./edge-CKszZCnI.js"), __vite__mapDeps([28, 11, 1, 2, 3, 14]), import.meta.url),
		},
		{
			id: "elixir",
			name: "Elixir",
			import: () => g(() => import("./elixir-Cc7HHYVZ.js"), __vite__mapDeps([29, 1, 2, 3]), import.meta.url),
		},
		{
			id: "elm",
			name: "Elm",
			import: () => g(() => import("./elm-DbKCFpqz.js"), __vite__mapDeps([30, 24, 25]), import.meta.url),
		},
		{
			id: "emacs-lisp",
			name: "Emacs Lisp",
			aliases: ["elisp"],
			import: () => g(() => import("./emacs-lisp-C9XAeP06.js"), [], import.meta.url),
		},
		{
			id: "erb",
			name: "ERB",
			import: () =>
				g(
					() => import("./erb-D3EuUlpm.js"),
					__vite__mapDeps([31, 1, 2, 3, 32, 33, 7, 8, 15, 34, 11, 35, 36, 22, 23, 24, 25, 27, 37, 38]),
					import.meta.url,
				),
		},
		{
			id: "erlang",
			name: "Erlang",
			aliases: ["erl"],
			import: () => g(() => import("./erlang-DpOm0zC4.js"), [], import.meta.url),
		},
		{ id: "fennel", name: "Fennel", import: () => g(() => import("./fennel-BYunw83y.js"), [], import.meta.url) },
		{ id: "fish", name: "Fish", import: () => g(() => import("./fish-Bl2oy6fF.js"), [], import.meta.url) },
		{
			id: "fluent",
			name: "Fluent",
			aliases: ["ftl"],
			import: () => g(() => import("./fluent-C4IJs8-o.js"), [], import.meta.url),
		},
		{
			id: "fortran-fixed-form",
			name: "Fortran (Fixed Form)",
			aliases: ["f", "for", "f77"],
			import: () =>
				g(() => import("./fortran-fixed-form-BZjJHVRy.js"), __vite__mapDeps([39, 40]), import.meta.url),
		},
		{
			id: "fortran-free-form",
			name: "Fortran (Free Form)",
			aliases: ["f90", "f95", "f03", "f08", "f18"],
			import: () => g(() => import("./fortran-free-form-D22FLkUw.js"), [], import.meta.url),
		},
		{
			id: "fsharp",
			name: "F#",
			aliases: ["f#", "fs"],
			import: () => g(() => import("./fsharp-DQy8In2x.js"), __vite__mapDeps([41, 42]), import.meta.url),
		},
		{
			id: "gdresource",
			name: "GDResource",
			import: () => g(() => import("./gdresource-BSDf9Pz1.js"), __vite__mapDeps([43, 44, 45]), import.meta.url),
		},
		{
			id: "gdscript",
			name: "GDScript",
			import: () => g(() => import("./gdscript-Bty6elJm.js"), [], import.meta.url),
		},
		{
			id: "gdshader",
			name: "GDShader",
			import: () => g(() => import("./gdshader-DkwncUOv.js"), [], import.meta.url),
		},
		{ id: "genie", name: "Genie", import: () => g(() => import("./genie-D0YGMca9.js"), [], import.meta.url) },
		{ id: "gherkin", name: "Gherkin", import: () => g(() => import("./gherkin-DyxjwDmM.js"), [], import.meta.url) },
		{
			id: "git-commit",
			name: "Git Commit Message",
			import: () => g(() => import("./git-commit-F4YmCXRG.js"), __vite__mapDeps([46, 47]), import.meta.url),
		},
		{
			id: "git-rebase",
			name: "Git Rebase Message",
			import: () => g(() => import("./git-rebase-r7XF79zn.js"), __vite__mapDeps([48, 27]), import.meta.url),
		},
		{ id: "gleam", name: "Gleam", import: () => g(() => import("./gleam-BspZqrRM.js"), [], import.meta.url) },
		{
			id: "glimmer-js",
			name: "Glimmer JS",
			aliases: ["gjs"],
			import: () =>
				g(() => import("./glimmer-js-Dz9X99Cm.js"), __vite__mapDeps([49, 2, 11, 3, 1]), import.meta.url),
		},
		{
			id: "glimmer-ts",
			name: "Glimmer TS",
			aliases: ["gts"],
			import: () =>
				g(() => import("./glimmer-ts-aQ3p29eY.js"), __vite__mapDeps([50, 11, 3, 2, 1]), import.meta.url),
		},
		{
			id: "glsl",
			name: "GLSL",
			import: () => g(() => import("./glsl-DplSGwfg.js"), __vite__mapDeps([24, 25]), import.meta.url),
		},
		{ id: "gnuplot", name: "Gnuplot", import: () => g(() => import("./gnuplot-DdkO51Og.js"), [], import.meta.url) },
		{ id: "go", name: "Go", import: () => g(() => import("./go-PEFJdsE-.js"), [], import.meta.url) },
		{
			id: "graphql",
			name: "GraphQL",
			aliases: ["gql"],
			import: () =>
				g(() => import("./graphql-Caa12_AY.js"), __vite__mapDeps([34, 2, 11, 35, 36]), import.meta.url),
		},
		{ id: "groovy", name: "Groovy", import: () => g(() => import("./groovy-gcz8RCvz.js"), [], import.meta.url) },
		{
			id: "hack",
			name: "Hack",
			import: () => g(() => import("./hack-C1oSbnf3.js"), __vite__mapDeps([51, 1, 2, 3, 15]), import.meta.url),
		},
		{
			id: "haml",
			name: "Ruby Haml",
			import: () => g(() => import("./haml-AZXGPtNI.js"), __vite__mapDeps([33, 2, 3]), import.meta.url),
		},
		{
			id: "handlebars",
			name: "Handlebars",
			aliases: ["hbs"],
			import: () =>
				g(() => import("./handlebars-YebKLiTq.js"), __vite__mapDeps([52, 1, 2, 3, 38]), import.meta.url),
		},
		{
			id: "haskell",
			name: "Haskell",
			aliases: ["hs"],
			import: () => g(() => import("./haskell-Df6bDoY_.js"), [], import.meta.url),
		},
		{ id: "haxe", name: "Haxe", import: () => g(() => import("./haxe-BP3HzMA6.js"), [], import.meta.url) },
		{ id: "hcl", name: "HashiCorp HCL", import: () => g(() => import("./hcl-BWvSN4gD.js"), [], import.meta.url) },
		{ id: "hjson", name: "Hjson", import: () => g(() => import("./hjson-D5-asLiD.js"), [], import.meta.url) },
		{ id: "hlsl", name: "HLSL", import: () => g(() => import("./hlsl-D3lLCCz7.js"), [], import.meta.url) },
		{
			id: "html",
			name: "HTML",
			import: () => g(() => import("./html-B8pBdPMQ.js"), __vite__mapDeps([1, 2, 3]), import.meta.url),
		},
		{
			id: "html-derivative",
			name: "HTML (Derivative)",
			import: () =>
				g(() => import("./html-derivative-ZQ8onl8Z.js"), __vite__mapDeps([14, 1, 2, 3]), import.meta.url),
		},
		{
			id: "http",
			name: "HTTP",
			import: () =>
				g(
					() => import("./http-C38VWM-o.js"),
					__vite__mapDeps([53, 27, 9, 7, 8, 34, 2, 11, 35, 36]),
					import.meta.url,
				),
		},
		{
			id: "hxml",
			name: "HXML",
			import: () => g(() => import("./hxml-B2Z6b3nn.js"), __vite__mapDeps([54, 55]), import.meta.url),
		},
		{ id: "hy", name: "Hy", import: () => g(() => import("./hy-DFXneXwc.js"), [], import.meta.url) },
		{ id: "imba", name: "Imba", import: () => g(() => import("./imba-DGztddWO.js"), [], import.meta.url) },
		{
			id: "ini",
			name: "INI",
			aliases: ["properties"],
			import: () => g(() => import("./ini-BEwlwnbL.js"), [], import.meta.url),
		},
		{ id: "java", name: "Java", import: () => g(() => import("./java-CylS5w8V.js"), [], import.meta.url) },
		{
			id: "javascript",
			name: "JavaScript",
			aliases: ["js"],
			import: () => g(() => import("./javascript-BMMyXqK5.js"), [], import.meta.url),
		},
		{
			id: "jinja",
			name: "Jinja",
			import: () => g(() => import("./jinja-BJmZiE_F.js"), __vite__mapDeps([56, 1, 2, 3]), import.meta.url),
		},
		{
			id: "jison",
			name: "Jison",
			import: () => g(() => import("./jison-BCRtk9Os.js"), __vite__mapDeps([57, 2]), import.meta.url),
		},
		{ id: "json", name: "JSON", import: () => g(() => import("./json-Cp-IABpG.js"), [], import.meta.url) },
		{ id: "json5", name: "JSON5", import: () => g(() => import("./json5-C9tS-k6U.js"), [], import.meta.url) },
		{
			id: "jsonc",
			name: "JSON with Comments",
			import: () => g(() => import("./jsonc-Des-eS-w.js"), [], import.meta.url),
		},
		{ id: "jsonl", name: "JSON Lines", import: () => g(() => import("./jsonl-DcaNXYhu.js"), [], import.meta.url) },
		{ id: "jsonnet", name: "Jsonnet", import: () => g(() => import("./jsonnet-DFQXde-d.js"), [], import.meta.url) },
		{
			id: "jssm",
			name: "JSSM",
			aliases: ["fsl"],
			import: () => g(() => import("./jssm-C2t-YnRu.js"), [], import.meta.url),
		},
		{ id: "jsx", name: "JSX", import: () => g(() => import("./jsx-g9-lgVsj.js"), [], import.meta.url) },
		{
			id: "julia",
			name: "Julia",
			aliases: ["jl"],
			import: () =>
				g(
					() => import("./julia-Db79kMu7.js"),
					__vite__mapDeps([58, 22, 23, 24, 25, 15, 19, 2, 59]),
					import.meta.url,
				),
		},
		{
			id: "kotlin",
			name: "Kotlin",
			aliases: ["kt", "kts"],
			import: () => g(() => import("./kotlin-BdnUsdx6.js"), [], import.meta.url),
		},
		{
			id: "kusto",
			name: "Kusto",
			aliases: ["kql"],
			import: () => g(() => import("./kusto-BvAqAH-y.js"), [], import.meta.url),
		},
		{
			id: "latex",
			name: "LaTeX",
			import: () => g(() => import("./latex-okZ41ve_.js"), __vite__mapDeps([60, 61, 59]), import.meta.url),
		},
		{
			id: "lean",
			name: "Lean 4",
			aliases: ["lean4"],
			import: () => g(() => import("./lean-c1G5yEKj.js"), [], import.meta.url),
		},
		{ id: "less", name: "Less", import: () => g(() => import("./less-B1dDrJ26.js"), [], import.meta.url) },
		{
			id: "liquid",
			name: "Liquid",
			import: () => g(() => import("./liquid-C1lUkxsO.js"), __vite__mapDeps([62, 1, 2, 3, 9]), import.meta.url),
		},
		{ id: "llvm", name: "LLVM IR", import: () => g(() => import("./llvm-D32k8WzR.js"), [], import.meta.url) },
		{ id: "log", name: "Log file", import: () => g(() => import("./log-BFvZA1X9.js"), [], import.meta.url) },
		{ id: "logo", name: "Logo", import: () => g(() => import("./logo-BtOb2qkB.js"), [], import.meta.url) },
		{
			id: "lua",
			name: "Lua",
			import: () => g(() => import("./lua-BbnMAYS6.js"), __vite__mapDeps([37, 25]), import.meta.url),
		},
		{ id: "luau", name: "Luau", import: () => g(() => import("./luau-irsrSlf-.js"), [], import.meta.url) },
		{
			id: "make",
			name: "Makefile",
			aliases: ["makefile"],
			import: () => g(() => import("./make-CHLpvVh8.js"), [], import.meta.url),
		},
		{
			id: "markdown",
			name: "Markdown",
			aliases: ["md"],
			import: () => g(() => import("./markdown-RrBGtqGR.js"), [], import.meta.url),
		},
		{
			id: "marko",
			name: "Marko",
			import: () => g(() => import("./marko-C0z8HR23.js"), __vite__mapDeps([63, 3, 64, 5, 2]), import.meta.url),
		},
		{ id: "matlab", name: "MATLAB", import: () => g(() => import("./matlab-D7o27uSR.js"), [], import.meta.url) },
		{
			id: "mdc",
			name: "MDC",
			import: () =>
				g(() => import("./mdc-02rxpBA4.js"), __vite__mapDeps([65, 42, 38, 14, 1, 2, 3]), import.meta.url),
		},
		{ id: "mdx", name: "MDX", import: () => g(() => import("./mdx-Cmh6b_Ma.js"), [], import.meta.url) },
		{
			id: "mermaid",
			name: "Mermaid",
			aliases: ["mmd"],
			import: () => g(() => import("./mermaid-DfEE3Bzs.js"), [], import.meta.url),
		},
		{
			id: "mipsasm",
			name: "MIPS Assembly",
			aliases: ["mips"],
			import: () => g(() => import("./mipsasm-CKIfxQSi.js"), [], import.meta.url),
		},
		{ id: "mojo", name: "Mojo", import: () => g(() => import("./mojo-1DNp92w6.js"), [], import.meta.url) },
		{ id: "move", name: "Move", import: () => g(() => import("./move-BkPM1oy1.js"), [], import.meta.url) },
		{
			id: "narrat",
			name: "Narrat Language",
			aliases: ["nar"],
			import: () => g(() => import("./narrat-DRg8JJMk.js"), [], import.meta.url),
		},
		{
			id: "nextflow",
			name: "Nextflow",
			aliases: ["nf"],
			import: () => g(() => import("./nextflow-BU0udk1K.js"), [], import.meta.url),
		},
		{
			id: "nginx",
			name: "Nginx",
			import: () => g(() => import("./nginx-DknmC5AR.js"), __vite__mapDeps([66, 37, 25]), import.meta.url),
		},
		{
			id: "nim",
			name: "Nim",
			import: () =>
				g(() => import("./nim-ANgMEeb1.js"), __vite__mapDeps([67, 25, 1, 2, 3, 7, 8, 24, 42]), import.meta.url),
		},
		{ id: "nix", name: "Nix", import: () => g(() => import("./nix-BepWV7mh.js"), [], import.meta.url) },
		{
			id: "nushell",
			name: "nushell",
			aliases: ["nu"],
			import: () => g(() => import("./nushell-I3RK9BU8.js"), [], import.meta.url),
		},
		{
			id: "objective-c",
			name: "Objective-C",
			aliases: ["objc"],
			import: () => g(() => import("./objective-c-DXmwc3jG.js"), [], import.meta.url),
		},
		{
			id: "objective-cpp",
			name: "Objective-C++",
			import: () => g(() => import("./objective-cpp-CLxacb5B.js"), [], import.meta.url),
		},
		{ id: "ocaml", name: "OCaml", import: () => g(() => import("./ocaml-C0hk2d4L.js"), [], import.meta.url) },
		{ id: "pascal", name: "Pascal", import: () => g(() => import("./pascal-D93ZcfNL.js"), [], import.meta.url) },
		{
			id: "perl",
			name: "Perl",
			import: () =>
				g(() => import("./perl-EWVMYlR0.js"), __vite__mapDeps([68, 1, 2, 3, 7, 8, 15]), import.meta.url),
		},
		{
			id: "php",
			name: "PHP",
			import: () =>
				g(() => import("./php-9PMsNEzE.js"), __vite__mapDeps([69, 1, 2, 3, 7, 8, 15, 9]), import.meta.url),
		},
		{ id: "plsql", name: "PL/SQL", import: () => g(() => import("./plsql-ChMvpjG-.js"), [], import.meta.url) },
		{
			id: "po",
			name: "Gettext PO",
			aliases: ["pot", "potx"],
			import: () => g(() => import("./po-BTJTHyun.js"), [], import.meta.url),
		},
		{ id: "polar", name: "Polar", import: () => g(() => import("./polar-C0HS_06l.js"), [], import.meta.url) },
		{ id: "postcss", name: "PostCSS", import: () => g(() => import("./postcss-CXtECtnM.js"), [], import.meta.url) },
		{
			id: "powerquery",
			name: "PowerQuery",
			import: () => g(() => import("./powerquery-CEu0bR-o.js"), [], import.meta.url),
		},
		{
			id: "powershell",
			name: "PowerShell",
			aliases: ["ps", "ps1"],
			import: () => g(() => import("./powershell-Dpen1YoG.js"), [], import.meta.url),
		},
		{ id: "prisma", name: "Prisma", import: () => g(() => import("./prisma-Dd19v3D-.js"), [], import.meta.url) },
		{ id: "prolog", name: "Prolog", import: () => g(() => import("./prolog-CbFg5uaA.js"), [], import.meta.url) },
		{
			id: "proto",
			name: "Protocol Buffer 3",
			aliases: ["protobuf"],
			import: () => g(() => import("./proto-DyJlTyXw.js"), [], import.meta.url),
		},
		{
			id: "pug",
			name: "Pug",
			aliases: ["jade"],
			import: () => g(() => import("./pug-Ch9lOoSd.js"), __vite__mapDeps([70, 2, 3, 1]), import.meta.url),
		},
		{ id: "puppet", name: "Puppet", import: () => g(() => import("./puppet-BMWR74SV.js"), [], import.meta.url) },
		{
			id: "purescript",
			name: "PureScript",
			import: () => g(() => import("./purescript-CtrldY6v.js"), [], import.meta.url),
		},
		{
			id: "python",
			name: "Python",
			aliases: ["py"],
			import: () => g(() => import("./python-B6aJPvgy.js"), [], import.meta.url),
		},
		{
			id: "qml",
			name: "QML",
			import: () => g(() => import("./qml-CHzV51_b.js"), __vite__mapDeps([71, 2]), import.meta.url),
		},
		{
			id: "qmldir",
			name: "QML Directory",
			import: () => g(() => import("./qmldir-C8lEn-DE.js"), [], import.meta.url),
		},
		{ id: "qss", name: "Qt Style Sheets", import: () => g(() => import("./qss-IeuSbFQv.js"), [], import.meta.url) },
		{ id: "r", name: "R", import: () => g(() => import("./r-C2tOF0e5.js"), [], import.meta.url) },
		{ id: "racket", name: "Racket", import: () => g(() => import("./racket-BqYA7rlc.js"), [], import.meta.url) },
		{
			id: "raku",
			name: "Raku",
			aliases: ["perl6"],
			import: () => g(() => import("./raku-DXvB9xmW.js"), [], import.meta.url),
		},
		{
			id: "razor",
			name: "ASP.NET Razor",
			import: () => g(() => import("./razor-CNXmhs1n.js"), __vite__mapDeps([72, 1, 2, 3, 73]), import.meta.url),
		},
		{
			id: "reg",
			name: "Windows Registry Script",
			import: () => g(() => import("./reg-C-SQnVFl.js"), [], import.meta.url),
		},
		{
			id: "regexp",
			name: "RegExp",
			aliases: ["regex"],
			import: () => g(() => import("./regexp-CDVJQ6XC.js"), [], import.meta.url),
		},
		{ id: "rel", name: "Rel", import: () => g(() => import("./rel-C3B-1QV4.js"), [], import.meta.url) },
		{ id: "riscv", name: "RISC-V", import: () => g(() => import("./riscv-BM1_JUlF.js"), [], import.meta.url) },
		{
			id: "rst",
			name: "reStructuredText",
			import: () =>
				g(
					() => import("./rst-DHpKpUMA.js"),
					__vite__mapDeps([
						74, 14, 1, 2, 3, 22, 23, 24, 25, 15, 19, 27, 38, 75, 32, 33, 7, 8, 34, 11, 35, 36, 37,
					]),
					import.meta.url,
				),
		},
		{
			id: "ruby",
			name: "Ruby",
			aliases: ["rb"],
			import: () =>
				g(
					() => import("./ruby-C5MNRm7z.js"),
					__vite__mapDeps([32, 1, 2, 3, 33, 7, 8, 15, 34, 11, 35, 36, 22, 23, 24, 25, 27, 37, 38]),
					import.meta.url,
				),
		},
		{
			id: "rust",
			name: "Rust",
			aliases: ["rs"],
			import: () => g(() => import("./rust-B1yitclQ.js"), [], import.meta.url),
		},
		{
			id: "sas",
			name: "SAS",
			import: () => g(() => import("./sas-Dlf3BogE.js"), __vite__mapDeps([76, 15]), import.meta.url),
		},
		{ id: "sass", name: "Sass", import: () => g(() => import("./sass-Cj5Yp3dK.js"), [], import.meta.url) },
		{ id: "scala", name: "Scala", import: () => g(() => import("./scala-C151Ov-r.js"), [], import.meta.url) },
		{ id: "scheme", name: "Scheme", import: () => g(() => import("./scheme-C98Dy4si.js"), [], import.meta.url) },
		{
			id: "scss",
			name: "SCSS",
			import: () => g(() => import("./scss-OYdSNvt2.js"), __vite__mapDeps([5, 3]), import.meta.url),
		},
		{
			id: "sdbl",
			name: "1C (Query)",
			aliases: ["1c-query"],
			import: () => g(() => import("./sdbl-DVxCFoDh.js"), [], import.meta.url),
		},
		{
			id: "shaderlab",
			name: "ShaderLab",
			aliases: ["shader"],
			import: () => g(() => import("./shaderlab-Dg9Lc6iA.js"), __vite__mapDeps([77, 78]), import.meta.url),
		},
		{
			id: "shellscript",
			name: "Shell",
			aliases: ["bash", "sh", "shell", "zsh"],
			import: () => g(() => import("./shellscript-Yzrsuije.js"), [], import.meta.url),
		},
		{
			id: "shellsession",
			name: "Shell Session",
			aliases: ["console"],
			import: () => g(() => import("./shellsession-BADoaaVG.js"), __vite__mapDeps([79, 27]), import.meta.url),
		},
		{
			id: "smalltalk",
			name: "Smalltalk",
			import: () => g(() => import("./smalltalk-BERRCDM3.js"), [], import.meta.url),
		},
		{
			id: "solidity",
			name: "Solidity",
			import: () => g(() => import("./solidity-BbcW6ACK.js"), [], import.meta.url),
		},
		{
			id: "soy",
			name: "Closure Templates",
			aliases: ["closure-templates"],
			import: () => g(() => import("./soy-B_7ge1HE.js"), __vite__mapDeps([80, 1, 2, 3]), import.meta.url),
		},
		{
			id: "sparql",
			name: "SPARQL",
			import: () => g(() => import("./sparql-rVzFXLq3.js"), __vite__mapDeps([81, 82]), import.meta.url),
		},
		{
			id: "splunk",
			name: "Splunk Query Language",
			aliases: ["spl"],
			import: () => g(() => import("./splunk-BtCnVYZw.js"), [], import.meta.url),
		},
		{ id: "sql", name: "SQL", import: () => g(() => import("./sql-B9xm8XSJ.js"), [], import.meta.url) },
		{
			id: "ssh-config",
			name: "SSH Config",
			import: () => g(() => import("./ssh-config-_ykCGR6B.js"), [], import.meta.url),
		},
		{
			id: "stata",
			name: "Stata",
			import: () => g(() => import("./stata-C5TGba-T.js"), __vite__mapDeps([83, 15]), import.meta.url),
		},
		{
			id: "stylus",
			name: "Stylus",
			aliases: ["styl"],
			import: () => g(() => import("./stylus-BEDo0Tqx.js"), [], import.meta.url),
		},
		{
			id: "svelte",
			name: "Svelte",
			import: () => g(() => import("./svelte-BFkwb7XM.js"), __vite__mapDeps([84, 2, 11, 3, 12]), import.meta.url),
		},
		{ id: "swift", name: "Swift", import: () => g(() => import("./swift-fve9TYiY.js"), [], import.meta.url) },
		{
			id: "system-verilog",
			name: "SystemVerilog",
			import: () => g(() => import("./system-verilog-CnnmHF94.js"), [], import.meta.url),
		},
		{
			id: "systemd",
			name: "Systemd Units",
			import: () => g(() => import("./systemd-4A_iFExJ.js"), [], import.meta.url),
		},
		{
			id: "talonscript",
			name: "TalonScript",
			aliases: ["talon"],
			import: () => g(() => import("./talonscript-CkByrt1z.js"), [], import.meta.url),
		},
		{ id: "tasl", name: "Tasl", import: () => g(() => import("./tasl-QIJgUcNo.js"), [], import.meta.url) },
		{ id: "tcl", name: "Tcl", import: () => g(() => import("./tcl-dwOrl1Do.js"), [], import.meta.url) },
		{
			id: "templ",
			name: "Templ",
			import: () => g(() => import("./templ-kZcegUSt.js"), __vite__mapDeps([85, 86, 2, 3]), import.meta.url),
		},
		{
			id: "terraform",
			name: "Terraform",
			aliases: ["tf", "tfvars"],
			import: () => g(() => import("./terraform-BETggiCN.js"), [], import.meta.url),
		},
		{
			id: "tex",
			name: "TeX",
			import: () => g(() => import("./tex-mQPFytnq.js"), __vite__mapDeps([61, 59]), import.meta.url),
		},
		{ id: "toml", name: "TOML", import: () => g(() => import("./toml-vGWfd6FD.js"), [], import.meta.url) },
		{
			id: "ts-tags",
			name: "TypeScript with Tags",
			aliases: ["lit"],
			import: () =>
				g(
					() => import("./ts-tags-CHnADXob.js"),
					__vite__mapDeps([87, 11, 3, 2, 24, 25, 1, 15, 7, 8]),
					import.meta.url,
				),
		},
		{ id: "tsv", name: "TSV", import: () => g(() => import("./tsv-B_m7g4N7.js"), [], import.meta.url) },
		{ id: "tsx", name: "TSX", import: () => g(() => import("./tsx-COt5Ahok.js"), [], import.meta.url) },
		{ id: "turtle", name: "Turtle", import: () => g(() => import("./turtle-BsS91CYL.js"), [], import.meta.url) },
		{
			id: "twig",
			name: "Twig",
			import: () =>
				g(
					() => import("./twig-febACT8g.js"),
					__vite__mapDeps([
						88, 3, 2, 5, 69, 1, 7, 8, 15, 9, 19, 32, 33, 34, 11, 35, 36, 22, 23, 24, 25, 27, 37, 38,
					]),
					import.meta.url,
				),
		},
		{
			id: "typescript",
			name: "TypeScript",
			aliases: ["ts"],
			import: () => g(() => import("./typescript-DlfHMoPT.js"), [], import.meta.url),
		},
		{
			id: "typespec",
			name: "TypeSpec",
			aliases: ["tsp"],
			import: () => g(() => import("./typespec-Df68jz8_.js"), [], import.meta.url),
		},
		{
			id: "typst",
			name: "Typst",
			aliases: ["typ"],
			import: () => g(() => import("./typst-DHCkPAjA.js"), [], import.meta.url),
		},
		{ id: "v", name: "V", import: () => g(() => import("./v-DljmTZ5-.js"), [], import.meta.url) },
		{ id: "vala", name: "Vala", import: () => g(() => import("./vala-CsfeWuGM.js"), [], import.meta.url) },
		{
			id: "vb",
			name: "Visual Basic",
			aliases: ["cmd"],
			import: () => g(() => import("./vb-D17OF-Vu.js"), [], import.meta.url),
		},
		{ id: "verilog", name: "Verilog", import: () => g(() => import("./verilog-BQ8w6xss.js"), [], import.meta.url) },
		{ id: "vhdl", name: "VHDL", import: () => g(() => import("./vhdl-CeAyd5Ju.js"), [], import.meta.url) },
		{
			id: "viml",
			name: "Vim Script",
			aliases: ["vim", "vimscript"],
			import: () => g(() => import("./viml-CJc9bBzg.js"), [], import.meta.url),
		},
		{
			id: "vue",
			name: "Vue",
			import: () =>
				g(() => import("./vue-xz9K_ZKN.js"), __vite__mapDeps([89, 3, 2, 11, 9, 14, 1]), import.meta.url),
		},
		{
			id: "vue-html",
			name: "Vue HTML",
			import: () =>
				g(
					() => import("./vue-html-dOMv_FQ0.js"),
					__vite__mapDeps([90, 89, 3, 2, 11, 9, 14, 1]),
					import.meta.url,
				),
		},
		{
			id: "vyper",
			name: "Vyper",
			aliases: ["vy"],
			import: () => g(() => import("./vyper-CDx5xZoG.js"), [], import.meta.url),
		},
		{ id: "wasm", name: "WebAssembly", import: () => g(() => import("./wasm-MzD3tlZU.js"), [], import.meta.url) },
		{
			id: "wenyan",
			name: "Wenyan",
			aliases: ["文言"],
			import: () => g(() => import("./wenyan-BV7otONQ.js"), [], import.meta.url),
		},
		{ id: "wgsl", name: "WGSL", import: () => g(() => import("./wgsl-Dx-B1_4e.js"), [], import.meta.url) },
		{
			id: "wikitext",
			name: "Wikitext",
			aliases: ["mediawiki", "wiki"],
			import: () => g(() => import("./wikitext-BhOHFoWU.js"), [], import.meta.url),
		},
		{
			id: "wit",
			name: "WebAssembly Interface Types",
			import: () => g(() => import("./wit-5i3qLPDT.js"), [], import.meta.url),
		},
		{
			id: "wolfram",
			name: "Wolfram",
			aliases: ["wl"],
			import: () => g(() => import("./wolfram-lXgVvXCa.js"), [], import.meta.url),
		},
		{
			id: "xml",
			name: "XML",
			import: () => g(() => import("./xml-sdJ4AIDG.js"), __vite__mapDeps([7, 8]), import.meta.url),
		},
		{
			id: "xsl",
			name: "XSL",
			import: () => g(() => import("./xsl-CtQFsRM5.js"), __vite__mapDeps([91, 7, 8]), import.meta.url),
		},
		{
			id: "yaml",
			name: "YAML",
			aliases: ["yml"],
			import: () => g(() => import("./yaml-Buea-lGh.js"), [], import.meta.url),
		},
		{
			id: "zenscript",
			name: "ZenScript",
			import: () => g(() => import("./zenscript-DVFEvuxE.js"), [], import.meta.url),
		},
		{ id: "zig", name: "Zig", import: () => g(() => import("./zig-CK-KhNJq.js"), [], import.meta.url) },
	],
	g0 = Object.fromEntries(Su.map((e) => [e.id, e.import])),
	_0 = Object.fromEntries(
		Su.flatMap((e) => {
			var t
			return ((t = e.aliases) == null ? void 0 : t.map((n) => [n, e.import])) || []
		}),
	),
	y0 = { ...g0, ..._0 },
	x0 = [
		{
			id: "andromeeda",
			displayName: "Andromeeda",
			type: "dark",
			import: () => g(() => import("./andromeeda-C3khCPGq.js"), [], import.meta.url),
		},
		{
			id: "aurora-x",
			displayName: "Aurora X",
			type: "dark",
			import: () => g(() => import("./aurora-x-D-2ljcwZ.js"), [], import.meta.url),
		},
		{
			id: "ayu-dark",
			displayName: "Ayu Dark",
			type: "dark",
			import: () => g(() => import("./ayu-dark-Cv9koXgw.js"), [], import.meta.url),
		},
		{
			id: "catppuccin-frappe",
			displayName: "Catppuccin Frappé",
			type: "dark",
			import: () => g(() => import("./catppuccin-frappe-Btyk0a-E.js"), [], import.meta.url),
		},
		{
			id: "catppuccin-latte",
			displayName: "Catppuccin Latte",
			type: "light",
			import: () => g(() => import("./catppuccin-latte-q-j0iyEw.js"), [], import.meta.url),
		},
		{
			id: "catppuccin-macchiato",
			displayName: "Catppuccin Macchiato",
			type: "dark",
			import: () => g(() => import("./catppuccin-macchiato-brDaU2vB.js"), [], import.meta.url),
		},
		{
			id: "catppuccin-mocha",
			displayName: "Catppuccin Mocha",
			type: "dark",
			import: () => g(() => import("./catppuccin-mocha-BR7mELCv.js"), [], import.meta.url),
		},
		{
			id: "dark-plus",
			displayName: "Dark Plus",
			type: "dark",
			import: () => g(() => import("./dark-plus-C3mMm8J8.js"), [], import.meta.url),
		},
		{
			id: "dracula",
			displayName: "Dracula Theme",
			type: "dark",
			import: () => g(() => import("./dracula-BzJJZx-M.js"), [], import.meta.url),
		},
		{
			id: "dracula-soft",
			displayName: "Dracula Theme Soft",
			type: "dark",
			import: () => g(() => import("./dracula-soft-BXkSAIEj.js"), [], import.meta.url),
		},
		{
			id: "everforest-dark",
			displayName: "Everforest Dark",
			type: "dark",
			import: () => g(() => import("./everforest-dark-BgDCqdQA.js"), [], import.meta.url),
		},
		{
			id: "everforest-light",
			displayName: "Everforest Light",
			type: "light",
			import: () => g(() => import("./everforest-light-C8M2exoo.js"), [], import.meta.url),
		},
		{
			id: "github-dark",
			displayName: "GitHub Dark",
			type: "dark",
			import: () => g(() => import("./github-dark-DHJKELXO.js"), [], import.meta.url),
		},
		{
			id: "github-dark-default",
			displayName: "GitHub Dark Default",
			type: "dark",
			import: () => g(() => import("./github-dark-default-Cuk6v7N8.js"), [], import.meta.url),
		},
		{
			id: "github-dark-dimmed",
			displayName: "GitHub Dark Dimmed",
			type: "dark",
			import: () => g(() => import("./github-dark-dimmed-DH5Ifo-i.js"), [], import.meta.url),
		},
		{
			id: "github-dark-high-contrast",
			displayName: "GitHub Dark High Contrast",
			type: "dark",
			import: () => g(() => import("./github-dark-high-contrast-E3gJ1_iC.js"), [], import.meta.url),
		},
		{
			id: "github-light",
			displayName: "GitHub Light",
			type: "light",
			import: () => g(() => import("./github-light-DAi9KRSo.js"), [], import.meta.url),
		},
		{
			id: "github-light-default",
			displayName: "GitHub Light Default",
			type: "light",
			import: () => g(() => import("./github-light-default-D7oLnXFd.js"), [], import.meta.url),
		},
		{
			id: "github-light-high-contrast",
			displayName: "GitHub Light High Contrast",
			type: "light",
			import: () => g(() => import("./github-light-high-contrast-BfjtVDDH.js"), [], import.meta.url),
		},
		{
			id: "gruvbox-dark-hard",
			displayName: "Gruvbox Dark Hard",
			type: "dark",
			import: () => g(() => import("./gruvbox-dark-hard-Hhtzho9R.js"), [], import.meta.url),
		},
		{
			id: "gruvbox-dark-medium",
			displayName: "Gruvbox Dark Medium",
			type: "dark",
			import: () => g(() => import("./gruvbox-dark-medium-DFR6f4Jn.js"), [], import.meta.url),
		},
		{
			id: "gruvbox-dark-soft",
			displayName: "Gruvbox Dark Soft",
			type: "dark",
			import: () => g(() => import("./gruvbox-dark-soft-BFVdkX1U.js"), [], import.meta.url),
		},
		{
			id: "gruvbox-light-hard",
			displayName: "Gruvbox Light Hard",
			type: "light",
			import: () => g(() => import("./gruvbox-light-hard-7i6GEmcB.js"), [], import.meta.url),
		},
		{
			id: "gruvbox-light-medium",
			displayName: "Gruvbox Light Medium",
			type: "light",
			import: () => g(() => import("./gruvbox-light-medium-Dcsh5twl.js"), [], import.meta.url),
		},
		{
			id: "gruvbox-light-soft",
			displayName: "Gruvbox Light Soft",
			type: "light",
			import: () => g(() => import("./gruvbox-light-soft-leinZj1a.js"), [], import.meta.url),
		},
		{
			id: "houston",
			displayName: "Houston",
			type: "dark",
			import: () => g(() => import("./houston-DnULxvSX.js"), [], import.meta.url),
		},
		{
			id: "kanagawa-dragon",
			displayName: "Kanagawa Dragon",
			type: "dark",
			import: () => g(() => import("./kanagawa-dragon-CkXjmgJE.js"), [], import.meta.url),
		},
		{
			id: "kanagawa-lotus",
			displayName: "Kanagawa Lotus",
			type: "light",
			import: () => g(() => import("./kanagawa-lotus-CfQXZHmo.js"), [], import.meta.url),
		},
		{
			id: "kanagawa-wave",
			displayName: "Kanagawa Wave",
			type: "dark",
			import: () => g(() => import("./kanagawa-wave-DWedfzmr.js"), [], import.meta.url),
		},
		{
			id: "laserwave",
			displayName: "LaserWave",
			type: "dark",
			import: () => g(() => import("./laserwave-DUszq2jm.js"), [], import.meta.url),
		},
		{
			id: "light-plus",
			displayName: "Light Plus",
			type: "light",
			import: () => g(() => import("./light-plus-B7mTdjB0.js"), [], import.meta.url),
		},
		{
			id: "material-theme",
			displayName: "Material Theme",
			type: "dark",
			import: () => g(() => import("./material-theme-D5KoaKCx.js"), [], import.meta.url),
		},
		{
			id: "material-theme-darker",
			displayName: "Material Theme Darker",
			type: "dark",
			import: () => g(() => import("./material-theme-darker-BfHTSMKl.js"), [], import.meta.url),
		},
		{
			id: "material-theme-lighter",
			displayName: "Material Theme Lighter",
			type: "light",
			import: () => g(() => import("./material-theme-lighter-B0m2ddpp.js"), [], import.meta.url),
		},
		{
			id: "material-theme-ocean",
			displayName: "Material Theme Ocean",
			type: "dark",
			import: () => g(() => import("./material-theme-ocean-CyktbL80.js"), [], import.meta.url),
		},
		{
			id: "material-theme-palenight",
			displayName: "Material Theme Palenight",
			type: "dark",
			import: () => g(() => import("./material-theme-palenight-Csfq5Kiy.js"), [], import.meta.url),
		},
		{
			id: "min-dark",
			displayName: "Min Dark",
			type: "dark",
			import: () => g(() => import("./min-dark-CafNBF8u.js"), [], import.meta.url),
		},
		{
			id: "min-light",
			displayName: "Min Light",
			type: "light",
			import: () => g(() => import("./min-light-CTRr51gU.js"), [], import.meta.url),
		},
		{
			id: "monokai",
			displayName: "Monokai",
			type: "dark",
			import: () => g(() => import("./monokai-D4h5O-jR.js"), [], import.meta.url),
		},
		{
			id: "night-owl",
			displayName: "Night Owl",
			type: "dark",
			import: () => g(() => import("./night-owl-C39BiMTA.js"), [], import.meta.url),
		},
		{
			id: "nord",
			displayName: "Nord",
			type: "dark",
			import: () => g(() => import("./nord-Ddv68eIx.js"), [], import.meta.url),
		},
		{
			id: "one-dark-pro",
			displayName: "One Dark Pro",
			type: "dark",
			import: () => g(() => import("./one-dark-pro-DVMEJ2y_.js"), [], import.meta.url),
		},
		{
			id: "one-light",
			displayName: "One Light",
			type: "light",
			import: () => g(() => import("./one-light-PoHY5YXO.js"), [], import.meta.url),
		},
		{
			id: "plastic",
			displayName: "Plastic",
			type: "dark",
			import: () => g(() => import("./plastic-3e1v2bzS.js"), [], import.meta.url),
		},
		{
			id: "poimandres",
			displayName: "Poimandres",
			type: "dark",
			import: () => g(() => import("./poimandres-CS3Unz2-.js"), [], import.meta.url),
		},
		{
			id: "red",
			displayName: "Red",
			type: "dark",
			import: () => g(() => import("./red-bN70gL4F.js"), [], import.meta.url),
		},
		{
			id: "rose-pine",
			displayName: "Rosé Pine",
			type: "dark",
			import: () => g(() => import("./rose-pine-BHrmToEH.js"), [], import.meta.url),
		},
		{
			id: "rose-pine-dawn",
			displayName: "Rosé Pine Dawn",
			type: "light",
			import: () => g(() => import("./rose-pine-dawn-CnK8MTSM.js"), [], import.meta.url),
		},
		{
			id: "rose-pine-moon",
			displayName: "Rosé Pine Moon",
			type: "dark",
			import: () => g(() => import("./rose-pine-moon-NleAzG8P.js"), [], import.meta.url),
		},
		{
			id: "slack-dark",
			displayName: "Slack Dark",
			type: "dark",
			import: () => g(() => import("./slack-dark-BthQWCQV.js"), [], import.meta.url),
		},
		{
			id: "slack-ochin",
			displayName: "Slack Ochin",
			type: "light",
			import: () => g(() => import("./slack-ochin-DqwNpetd.js"), [], import.meta.url),
		},
		{
			id: "snazzy-light",
			displayName: "Snazzy Light",
			type: "light",
			import: () => g(() => import("./snazzy-light-Bw305WKR.js"), [], import.meta.url),
		},
		{
			id: "solarized-dark",
			displayName: "Solarized Dark",
			type: "dark",
			import: () => g(() => import("./solarized-dark-DXbdFlpD.js"), [], import.meta.url),
		},
		{
			id: "solarized-light",
			displayName: "Solarized Light",
			type: "light",
			import: () => g(() => import("./solarized-light-L9t79GZl.js"), [], import.meta.url),
		},
		{
			id: "synthwave-84",
			displayName: "Synthwave '84",
			type: "dark",
			import: () => g(() => import("./synthwave-84-CbfX1IO0.js"), [], import.meta.url),
		},
		{
			id: "tokyo-night",
			displayName: "Tokyo Night",
			type: "dark",
			import: () => g(() => import("./tokyo-night-hegEt444.js"), [], import.meta.url),
		},
		{
			id: "vesper",
			displayName: "Vesper",
			type: "dark",
			import: () => g(() => import("./vesper-DU1UobuO.js"), [], import.meta.url),
		},
		{
			id: "vitesse-black",
			displayName: "Vitesse Black",
			type: "dark",
			import: () => g(() => import("./vitesse-black-Bkuqu6BP.js"), [], import.meta.url),
		},
		{
			id: "vitesse-dark",
			displayName: "Vitesse Dark",
			type: "dark",
			import: () => g(() => import("./vitesse-dark-D0r3Knsf.js"), [], import.meta.url),
		},
		{
			id: "vitesse-light",
			displayName: "Vitesse Light",
			type: "light",
			import: () => g(() => import("./vitesse-light-CVO1_9PV.js"), [], import.meta.url),
		},
	],
	b0 = Object.fromEntries(x0.map((e) => [e.id, e.import]))
class Eo extends Error {
	constructor(t) {
		super(t), (this.name = "ShikiError")
	}
}
function k0() {
	return 2147483648
}
function w0() {
	return typeof performance < "u" ? performance.now() : Date.now()
}
const E0 = (e, t) => e + ((t - (e % t)) % t)
async function v0(e) {
	let t, n
	const r = {}
	function i(p) {
		;(n = p), (r.HEAPU8 = new Uint8Array(p)), (r.HEAPU32 = new Uint32Array(p))
	}
	function o(p, f, y) {
		r.HEAPU8.copyWithin(p, f, f + y)
	}
	function s(p) {
		try {
			return t.grow((p - n.byteLength + 65535) >>> 16), i(t.buffer), 1
		} catch {}
	}
	function a(p) {
		const f = r.HEAPU8.length
		p = p >>> 0
		const y = k0()
		if (p > y) return !1
		for (let x = 1; x <= 4; x *= 2) {
			let d = f * (1 + 0.2 / x)
			d = Math.min(d, p + 100663296)
			const _ = Math.min(y, E0(Math.max(p, d), 65536))
			if (s(_)) return !0
		}
		return !1
	}
	const l = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0
	function u(p, f, y = 1024) {
		const x = f + y
		let d = f
		for (; p[d] && !(d >= x); ) ++d
		if (d - f > 16 && p.buffer && l) return l.decode(p.subarray(f, d))
		let _ = ""
		for (; f < d; ) {
			let w = p[f++]
			if (!(w & 128)) {
				_ += String.fromCharCode(w)
				continue
			}
			const I = p[f++] & 63
			if ((w & 224) === 192) {
				_ += String.fromCharCode(((w & 31) << 6) | I)
				continue
			}
			const S = p[f++] & 63
			if (
				((w & 240) === 224
					? (w = ((w & 15) << 12) | (I << 6) | S)
					: (w = ((w & 7) << 18) | (I << 12) | (S << 6) | (p[f++] & 63)),
				w < 65536)
			)
				_ += String.fromCharCode(w)
			else {
				const b = w - 65536
				_ += String.fromCharCode(55296 | (b >> 10), 56320 | (b & 1023))
			}
		}
		return _
	}
	function m(p, f) {
		return p ? u(r.HEAPU8, p, f) : ""
	}
	const c = { emscripten_get_now: w0, emscripten_memcpy_big: o, emscripten_resize_heap: a, fd_write: () => 0 }
	async function h() {
		const f = await e({ env: c, wasi_snapshot_preview1: c })
		;(t = f.memory), i(t.buffer), Object.assign(r, f), (r.UTF8ToString = m)
	}
	return await h(), r
}
var S0 = Object.defineProperty,
	I0 = (e, t, n) => (t in e ? S0(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)),
	Ie = (e, t, n) => I0(e, typeof t != "symbol" ? t + "" : t, n)
let Ae = null
function T0(e) {
	throw new Eo(e.UTF8ToString(e.getLastOnigError()))
}
class Fr {
	constructor(t) {
		Ie(this, "utf16Length"),
			Ie(this, "utf8Length"),
			Ie(this, "utf16Value"),
			Ie(this, "utf8Value"),
			Ie(this, "utf16OffsetToUtf8"),
			Ie(this, "utf8OffsetToUtf16")
		const n = t.length,
			r = Fr._utf8ByteLength(t),
			i = r !== n,
			o = i ? new Uint32Array(n + 1) : null
		i && (o[n] = r)
		const s = i ? new Uint32Array(r + 1) : null
		i && (s[r] = n)
		const a = new Uint8Array(r)
		let l = 0
		for (let u = 0; u < n; u++) {
			const m = t.charCodeAt(u)
			let c = m,
				h = !1
			if (m >= 55296 && m <= 56319 && u + 1 < n) {
				const p = t.charCodeAt(u + 1)
				p >= 56320 && p <= 57343 && ((c = (((m - 55296) << 10) + 65536) | (p - 56320)), (h = !0))
			}
			i &&
				((o[u] = l),
				h && (o[u + 1] = l),
				c <= 127
					? (s[l + 0] = u)
					: c <= 2047
						? ((s[l + 0] = u), (s[l + 1] = u))
						: c <= 65535
							? ((s[l + 0] = u), (s[l + 1] = u), (s[l + 2] = u))
							: ((s[l + 0] = u), (s[l + 1] = u), (s[l + 2] = u), (s[l + 3] = u))),
				c <= 127
					? (a[l++] = c)
					: c <= 2047
						? ((a[l++] = 192 | ((c & 1984) >>> 6)), (a[l++] = 128 | ((c & 63) >>> 0)))
						: c <= 65535
							? ((a[l++] = 224 | ((c & 61440) >>> 12)),
								(a[l++] = 128 | ((c & 4032) >>> 6)),
								(a[l++] = 128 | ((c & 63) >>> 0)))
							: ((a[l++] = 240 | ((c & 1835008) >>> 18)),
								(a[l++] = 128 | ((c & 258048) >>> 12)),
								(a[l++] = 128 | ((c & 4032) >>> 6)),
								(a[l++] = 128 | ((c & 63) >>> 0))),
				h && u++
		}
		;(this.utf16Length = n),
			(this.utf8Length = r),
			(this.utf16Value = t),
			(this.utf8Value = a),
			(this.utf16OffsetToUtf8 = o),
			(this.utf8OffsetToUtf16 = s)
	}
	static _utf8ByteLength(t) {
		let n = 0
		for (let r = 0, i = t.length; r < i; r++) {
			const o = t.charCodeAt(r)
			let s = o,
				a = !1
			if (o >= 55296 && o <= 56319 && r + 1 < i) {
				const l = t.charCodeAt(r + 1)
				l >= 56320 && l <= 57343 && ((s = (((o - 55296) << 10) + 65536) | (l - 56320)), (a = !0))
			}
			s <= 127 ? (n += 1) : s <= 2047 ? (n += 2) : s <= 65535 ? (n += 3) : (n += 4), a && r++
		}
		return n
	}
	createString(t) {
		const n = t.omalloc(this.utf8Length)
		return t.HEAPU8.set(this.utf8Value, n), n
	}
}
const jr = class ut {
	constructor(t) {
		if (
			(Ie(this, "id", ++ut.LAST_ID),
			Ie(this, "_onigBinding"),
			Ie(this, "content"),
			Ie(this, "utf16Length"),
			Ie(this, "utf8Length"),
			Ie(this, "utf16OffsetToUtf8"),
			Ie(this, "utf8OffsetToUtf16"),
			Ie(this, "ptr"),
			!Ae)
		)
			throw new Eo("Must invoke loadWasm first.")
		;(this._onigBinding = Ae), (this.content = t)
		const n = new Fr(t)
		;(this.utf16Length = n.utf16Length),
			(this.utf8Length = n.utf8Length),
			(this.utf16OffsetToUtf8 = n.utf16OffsetToUtf8),
			(this.utf8OffsetToUtf16 = n.utf8OffsetToUtf16),
			this.utf8Length < 1e4 && !ut._sharedPtrInUse
				? (ut._sharedPtr || (ut._sharedPtr = Ae.omalloc(1e4)),
					(ut._sharedPtrInUse = !0),
					Ae.HEAPU8.set(n.utf8Value, ut._sharedPtr),
					(this.ptr = ut._sharedPtr))
				: (this.ptr = n.createString(Ae))
	}
	convertUtf8OffsetToUtf16(t) {
		return this.utf8OffsetToUtf16
			? t < 0
				? 0
				: t > this.utf8Length
					? this.utf16Length
					: this.utf8OffsetToUtf16[t]
			: t
	}
	convertUtf16OffsetToUtf8(t) {
		return this.utf16OffsetToUtf8
			? t < 0
				? 0
				: t > this.utf16Length
					? this.utf8Length
					: this.utf16OffsetToUtf8[t]
			: t
	}
	dispose() {
		this.ptr === ut._sharedPtr ? (ut._sharedPtrInUse = !1) : this._onigBinding.ofree(this.ptr)
	}
}
Ie(jr, "LAST_ID", 0)
Ie(jr, "_sharedPtr", 0)
Ie(jr, "_sharedPtrInUse", !1)
let Iu = jr
class C0 {
	constructor(t) {
		if ((Ie(this, "_onigBinding"), Ie(this, "_ptr"), !Ae)) throw new Eo("Must invoke loadWasm first.")
		const n = [],
			r = []
		for (let a = 0, l = t.length; a < l; a++) {
			const u = new Fr(t[a])
			;(n[a] = u.createString(Ae)), (r[a] = u.utf8Length)
		}
		const i = Ae.omalloc(4 * t.length)
		Ae.HEAPU32.set(n, i / 4)
		const o = Ae.omalloc(4 * t.length)
		Ae.HEAPU32.set(r, o / 4)
		const s = Ae.createOnigScanner(i, o, t.length)
		for (let a = 0, l = t.length; a < l; a++) Ae.ofree(n[a])
		Ae.ofree(o), Ae.ofree(i), s === 0 && T0(Ae), (this._onigBinding = Ae), (this._ptr = s)
	}
	dispose() {
		this._onigBinding.freeOnigScanner(this._ptr)
	}
	findNextMatchSync(t, n, r) {
		let i = 0
		if ((typeof r == "number" && (i = r), typeof t == "string")) {
			t = new Iu(t)
			const o = this._findNextMatchSync(t, n, !1, i)
			return t.dispose(), o
		}
		return this._findNextMatchSync(t, n, !1, i)
	}
	_findNextMatchSync(t, n, r, i) {
		const o = this._onigBinding,
			s = o.findNextOnigScannerMatch(this._ptr, t.id, t.ptr, t.utf8Length, t.convertUtf16OffsetToUtf8(n), i)
		if (s === 0) return null
		const a = o.HEAPU32
		let l = s / 4
		const u = a[l++],
			m = a[l++],
			c = []
		for (let h = 0; h < m; h++) {
			const p = t.convertUtf8OffsetToUtf16(a[l++]),
				f = t.convertUtf8OffsetToUtf16(a[l++])
			c[h] = { start: p, end: f, length: f - p }
		}
		return { index: u, captureIndices: c }
	}
}
function A0(e) {
	return typeof e.instantiator == "function"
}
function R0(e) {
	return typeof e.default == "function"
}
function L0(e) {
	return typeof e.data < "u"
}
function P0(e) {
	return typeof Response < "u" && e instanceof Response
}
function O0(e) {
	var t
	return (
		(typeof ArrayBuffer < "u" && (e instanceof ArrayBuffer || ArrayBuffer.isView(e))) ||
		(typeof Buffer < "u" && ((t = Buffer.isBuffer) == null ? void 0 : t.call(Buffer, e))) ||
		(typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer) ||
		(typeof Uint32Array < "u" && e instanceof Uint32Array)
	)
}
let Zn
function D0(e) {
	if (Zn) return Zn
	async function t() {
		Ae = await v0(async (n) => {
			let r = e
			return (
				(r = await r),
				typeof r == "function" && (r = await r(n)),
				typeof r == "function" && (r = await r(n)),
				A0(r)
					? (r = await r.instantiator(n))
					: R0(r)
						? (r = await r.default(n))
						: (L0(r) && (r = r.data),
							P0(r)
								? typeof WebAssembly.instantiateStreaming == "function"
									? (r = await N0(r)(n))
									: (r = await M0(r)(n))
								: O0(r)
									? (r = await gi(r)(n))
									: r instanceof WebAssembly.Module
										? (r = await gi(r)(n))
										: "default" in r &&
											r.default instanceof WebAssembly.Module &&
											(r = await gi(r.default)(n))),
				"instance" in r && (r = r.instance),
				"exports" in r && (r = r.exports),
				r
			)
		})
	}
	return (Zn = t()), Zn
}
function gi(e) {
	return (t) => WebAssembly.instantiate(e, t)
}
function N0(e) {
	return (t) => WebAssembly.instantiateStreaming(e, t)
}
function M0(e) {
	return async (t) => {
		const n = await e.arrayBuffer()
		return WebAssembly.instantiate(n, t)
	}
}
async function z0(e) {
	return (
		e && (await D0(e)),
		{
			createScanner(t) {
				return new C0(t.map((n) => (typeof n == "string" ? n : n.source)))
			},
			createString(t) {
				return new Iu(t)
			},
		}
	)
}
const V0 = h0({ langs: y0, themes: b0, engine: () => z0(g(() => import("./wasm-CG6Dc4jp.js"), [], import.meta.url)) }),
	{ codeToHtml: B0 } = d0(V0, { guessEmbeddedLanguages: Lx }),
	vo = we.memo(({ language: e, value: t, className: n, ...r }) => {
		const [i, o] = we.useState(""),
			{ isCopied: s, copy: a } = ja(),
			l = we.useCallback(() => {
				s || a(t)
			}, [s, a, t])
		return (
			we.useEffect(() => {
				;(async () => {
					const m = "github-dark"
					try {
						const c = await B0(t, {
							lang: e,
							theme: m,
							transformers: [
								{
									pre(h) {
										return (h.properties.class = Ir(n, "overflow-x-auto")), h
									},
									code(h) {
										return (h.properties.style = "background-color: transparent !important;"), h
									},
								},
							],
						})
						o(c)
					} catch {
						o(t)
					}
				})()
			}, [e, t, n]),
			D.jsxs("div", {
				className: "relative",
				...r,
				children: [
					D.jsx("div", { dangerouslySetInnerHTML: { __html: i } }),
					D.jsx(_i, {
						variant: "outline",
						size: "icon",
						className: "absolute top-1 right-1 cursor-pointer bg-black/10",
						onClick: l,
						children: s
							? D.jsx(ia, { style: { width: 12, height: 12 } })
							: D.jsx(oa, { style: { width: 12, height: 12 } }),
					}),
				],
			})
		)
	})
vo.displayName = "CodeBlock"
vo.__docgenInfo = {
	description: "",
	methods: [],
	displayName: "CodeBlock",
	props: {
		language: { required: !0, tsType: { name: "string" }, description: "" },
		value: { required: !0, tsType: { name: "string" }, description: "" },
	},
	composes: ["Omit"],
}
const Tu = ({ children: e }) =>
	D.jsx("div", { className: "border-l-3 border-accent italic pl-2 py-2 mb-2", children: e })
Tu.__docgenInfo = {
	description: "",
	methods: [],
	displayName: "Blockquote",
	props: { children: { required: !0, tsType: { name: "ReactReactNode", raw: "React.ReactNode" }, description: "" } },
}
const F0 = we.memo(Sd, (e, t) => e.children === t.children && e.className === t.className)
function Cu({ content: e }) {
	return D.jsx(F0, {
		remarkPlugins: [B_],
		className: "custom-markdown break-words",
		components: {
			p({ children: t }) {
				return D.jsx("div", { className: "mb-2 last:mb-0", children: t })
			},
			hr() {
				return D.jsx(zu, {})
			},
			ol({ children: t }) {
				return D.jsx("ol", {
					className: "list-decimal pl-4 [&>li]:mb-1 [&>li:last-child]:mb-0 [&>li>ul]:mt-1 [&>li>ol]:mt-1",
					children: t,
				})
			},
			ul({ children: t }) {
				return D.jsx("ul", {
					className: "list-disc pl-4 [&>li]:mb-1 [&>li:last-child]:mb-0 [&>li>ul]:mt-1 [&>li>ol]:mt-1",
					children: t,
				})
			},
			blockquote({ children: t }) {
				return D.jsx(Tu, { children: t })
			},
			code({ className: t, children: n, ...r }) {
				var s
				if (n && Array.isArray(n) && n.length) {
					if (n[0] === "▍")
						return D.jsx("span", { className: "mt-1 animate-pulse cursor-default", children: "▍" })
					n[0] = n[0].replace("`▍`", "▍")
				}
				const i = /language-(\w+)/.exec(t || "")
				return ((s = r.node) == null ? void 0 : s.position) &&
					r.node.position.start.line === r.node.position.end.line
					? D.jsx("code", { className: t, ...r, children: n })
					: D.jsx(vo, {
							language: (i && i[1]) || "",
							value: String(n).replace(/\n$/, ""),
							className: "rounded-lg p-3 mb-2",
						})
			},
			a({ href: t, children: n }) {
				return D.jsx("a", { href: t, target: "_blank", rel: "noopener noreferrer", children: n })
			},
		},
		children: e,
	})
}
Cu.__docgenInfo = {
	description: "",
	methods: [],
	displayName: "Markdown",
	props: { content: { required: !0, tsType: { name: "string" }, description: "" } },
}
const Au = we.createContext(null),
	j0 = Au.Provider,
	So = () => {
		const e = we.useContext(Au)
		if (!e) throw new Error("useChatMessage must be used within a ChatMessageProvider")
		return e
	}
function Ru({ message: e, isLast: t, isHeaderVisible: n }) {
	const r = we.useMemo(() => {
		var i
		return (i = e.annotations) == null ? void 0 : i.filter(({ type: o }) => o === aa.BADGE).map(({ data: o }) => o)
	}, [e.annotations])
	return D.jsx(j0, {
		value: { message: e, isLast: t },
		children: D.jsxs("div", {
			className: Ir("relative group flex flex-col text-secondary-foreground", {
				"bg-vscode-input-background/50": e.role === "user",
			}),
			children: [n && D.jsx(H0, { badges: r }), D.jsx($0, { isHeaderVisible: n }), D.jsx(U0, {})],
		}),
	})
}
function H0({ badges: e }) {
	return D.jsxs("div", {
		className: "flex flex-row items-center justify-between border-t border-accent px-3 pt-3 pb-1",
		children: [
			D.jsx(G0, {}),
			e == null
				? void 0
				: e.map(({ label: t, variant: n = "outline" }) => D.jsx(Vu, { variant: n, children: t }, t)),
		],
	})
}
const Zs = { user: D.jsx(Uu, { className: "h-4 w-4" }), assistant: D.jsx(Gu, { className: "h-4 w-4" }) }
function G0() {
	const { assistantName: e } = zn(),
		{ message: t } = So()
	return Zs[t.role]
		? D.jsxs("div", {
				className: "flex flex-row items-center gap-1",
				children: [
					D.jsx("div", { className: "opacity-25 select-none", children: Zs[t.role] }),
					D.jsx("div", { className: "text-muted", children: t.role === "user" ? "You" : e }),
				],
			})
		: null
}
function $0({ isHeaderVisible: e }) {
	const { message: t } = So()
	return D.jsx("div", {
		className: Ir("flex flex-col gap-4 flex-1 min-w-0 px-4 pb-6", { "pt-4": e }),
		children: D.jsx(Cu, { content: t.content }),
	})
}
function U0() {
	const { message: e } = So(),
		{ isCopied: t, copy: n } = ja()
	return D.jsx("div", {
		className: "absolute right-2 bottom-2 opacity-0 group-hover:opacity-25 cursor-pointer",
		onClick: () => n(e.content),
		children: t ? D.jsx(ia, {}) : D.jsx(oa, {}),
	})
}
Ru.__docgenInfo = {
	description: "",
	methods: [],
	displayName: "ChatMessage",
	props: {
		message: { required: !0, tsType: { name: "Message" }, description: "" },
		isLast: { required: !0, tsType: { name: "boolean" }, description: "" },
		isHeaderVisible: { required: !0, tsType: { name: "boolean" }, description: "" },
		isLoading: { required: !1, tsType: { name: "boolean" }, description: "" },
		append: { required: !1, tsType: { name: "signature", raw: 'ChatHandler["append"]' }, description: "" },
	},
}
function Lu() {
	const { messages: e, isLoading: t, append: n } = zn(),
		r = e.length,
		i = we.useRef(null)
	return (
		we.useEffect(() => {
			i.current &&
				requestAnimationFrame(() => {
					var o
					return (o = i.current) == null
						? void 0
						: o.scrollToIndex({ index: r - 1, align: "end", behavior: "smooth" })
				})
		}, [r]),
		D.jsx(rm, {
			ref: i,
			data: e,
			totalCount: r,
			itemContent: (o, s) => {
				var a
				return D.jsx(
					Ru,
					{
						message: s,
						isHeaderVisible:
							!!((a = s.annotations) != null && a.length) || o === 0 || e[o - 1].role !== s.role,
						isLast: o === r - 1,
						isLoading: t,
						append: n,
					},
					o,
				)
			},
		})
	)
}
Lu.__docgenInfo = { description: "", methods: [], displayName: "ChatMessages" }
const Pu = we.createContext(null),
	q0 = Pu.Provider,
	Io = () => {
		const e = we.useContext(Pu)
		if (!e) throw new Error("useChatInput must be used within a ChatInputProvider")
		return e
	}
function Ou() {
	const { input: e, setInput: t, append: n, isLoading: r } = zn(),
		i = r || !e.trim(),
		o = async () => {
			e.trim() !== "" && (t(""), await n({ role: "user", content: e }))
		},
		s = async (l) => {
			l.preventDefault(), await o()
		},
		a = async (l) => {
			i || (l.key === "Enter" && !l.shiftKey && (l.preventDefault(), await o()))
		}
	return D.jsx(q0, {
		value: { isDisabled: i, handleKeyDown: a, handleSubmit: s },
		children: D.jsx("div", { className: "border-t border-vscode-editor-background p-3", children: D.jsx(W0, {}) }),
	})
}
function W0() {
	const { handleSubmit: e } = Io()
	return D.jsxs("form", { onSubmit: e, className: "relative", children: [D.jsx(K0, {}), D.jsx(Y0, {})] })
}
function K0({ placeholder: e = "Chat" }) {
	const { input: t, setInput: n } = zn(),
		{ handleKeyDown: r } = Io()
	return D.jsx(ju, {
		name: "input",
		placeholder: e,
		minHeight: 75,
		maxHeight: 200,
		value: t,
		onChange: ({ target: { value: i } }) => n(i),
		onKeyDown: r,
		className: "resize-none px-3 pt-3 pb-[50px]",
	})
}
function Y0() {
	const { isLoading: e, stop: t } = zn(),
		{ isDisabled: n } = Io(),
		r = e && !!t
	return D.jsx("div", {
		className:
			"absolute bottom-[1px] left-[1px] right-[1px] h-[40px] bg-input border-t border-vscode-editor-background rounded-b-md p-1",
		children: D.jsx("div", {
			className: "flex flex-row-reverse items-center gap-2",
			children: r
				? D.jsx(_i, {
						type: "button",
						variant: "ghost",
						size: "sm",
						onClick: t,
						children: D.jsx(Bu, { className: "text-destructive" }),
					})
				: D.jsx(_i, { type: "submit", variant: "ghost", size: "icon", disabled: n, children: D.jsx(Fu, {}) }),
		}),
	})
}
Ou.__docgenInfo = { description: "", methods: [], displayName: "ChatInput" }
const To = ({ assistantName: e, handler: t, ...n }) =>
		D.jsx(qu, { value: { assistantName: e, ...t }, children: D.jsx(X0, { ...n }) }),
	X0 = ({ className: e, children: t, ...n }) =>
		D.jsxs("div", {
			className: Ir("relative flex flex-col flex-1 min-h-0", e),
			...n,
			children: [D.jsx(Lu, {}), t, D.jsx(Ou, {})],
		})
To.__docgenInfo = {
	description: "",
	methods: [],
	displayName: "Chat",
	props: {
		assistantName: { required: !0, tsType: { name: "string" }, description: "" },
		handler: {
			required: !0,
			tsType: {
				name: "signature",
				type: "object",
				raw: `{
	isLoading: boolean
	setIsLoading: (isLoading: boolean, message?: string) => void

	loadingMessage?: string
	setLoadingMessage?: (message: string) => void

	input: string
	setInput: (input: string) => void

	messages: Message[]

	reload?: (options?: { data?: any }) => void
	stop?: () => void
	append: (message: Message, options?: { data?: any }) => Promise<string | null | undefined>
	reset?: () => void
}`,
				signature: {
					properties: [
						{ key: "isLoading", value: { name: "boolean", required: !0 } },
						{
							key: "setIsLoading",
							value: {
								name: "signature",
								type: "function",
								raw: "(isLoading: boolean, message?: string) => void",
								signature: {
									arguments: [
										{ type: { name: "boolean" }, name: "isLoading" },
										{ type: { name: "string" }, name: "message" },
									],
									return: { name: "void" },
								},
								required: !0,
							},
						},
						{ key: "loadingMessage", value: { name: "string", required: !1 } },
						{
							key: "setLoadingMessage",
							value: {
								name: "signature",
								type: "function",
								raw: "(message: string) => void",
								signature: {
									arguments: [{ type: { name: "string" }, name: "message" }],
									return: { name: "void" },
								},
								required: !1,
							},
						},
						{ key: "input", value: { name: "string", required: !0 } },
						{
							key: "setInput",
							value: {
								name: "signature",
								type: "function",
								raw: "(input: string) => void",
								signature: {
									arguments: [{ type: { name: "string" }, name: "input" }],
									return: { name: "void" },
								},
								required: !0,
							},
						},
						{
							key: "messages",
							value: { name: "Array", elements: [{ name: "Message" }], raw: "Message[]", required: !0 },
						},
						{
							key: "reload",
							value: {
								name: "signature",
								type: "function",
								raw: "(options?: { data?: any }) => void",
								signature: {
									arguments: [
										{
											type: {
												name: "signature",
												type: "object",
												raw: "{ data?: any }",
												signature: {
													properties: [{ key: "data", value: { name: "any", required: !1 } }],
												},
											},
											name: "options",
										},
									],
									return: { name: "void" },
								},
								required: !1,
							},
						},
						{
							key: "stop",
							value: {
								name: "signature",
								type: "function",
								raw: "() => void",
								signature: { arguments: [], return: { name: "void" } },
								required: !1,
							},
						},
						{
							key: "append",
							value: {
								name: "signature",
								type: "function",
								raw: "(message: Message, options?: { data?: any }) => Promise<string | null | undefined>",
								signature: {
									arguments: [
										{ type: { name: "Message" }, name: "message" },
										{
											type: {
												name: "signature",
												type: "object",
												raw: "{ data?: any }",
												signature: {
													properties: [{ key: "data", value: { name: "any", required: !1 } }],
												},
											},
											name: "options",
										},
									],
									return: {
										name: "Promise",
										elements: [
											{
												name: "union",
												raw: "string | null | undefined",
												elements: [{ name: "string" }, { name: "null" }, { name: "undefined" }],
											},
										],
										raw: "Promise<string | null | undefined>",
									},
								},
								required: !0,
							},
						},
						{
							key: "reset",
							value: {
								name: "signature",
								type: "function",
								raw: "() => void",
								signature: { arguments: [], return: { name: "void" } },
								required: !1,
							},
						},
					],
				},
			},
			description: "",
		},
	},
}
const mb = { title: "ui/Chat", component: To, parameters: { layout: "centered" }, tags: ["autodocs"] },
	er = {
		name: "Chat",
		args: { assistantName: "Assistant", handler: {} },
		render: function () {
			const t = Q0()
			return D.jsx(To, {
				assistantName: "Assistant",
				handler: t,
				className: "border w-[460px] h-[640px] bg-vscode-editor-background",
			})
		},
	},
	Q0 = () => {
		const [e, t] = we.useState(!1),
			[n, r] = we.useState(""),
			[i, o] = we.useState([])
		return {
			isLoading: e,
			setIsLoading: t,
			input: n,
			setInput: r,
			messages: i,
			append: async (a, l) => {
				const u = {
					...a,
					role: "assistant",
					content: "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
				}
				return o((m) => [...m, a, u]), Promise.resolve(null)
			},
		}
	}
var ea, ta, na
er.parameters = {
	...er.parameters,
	docs: {
		...((ea = er.parameters) == null ? void 0 : ea.docs),
		source: {
			originalSource: `{
  name: "Chat",
  args: {
    assistantName: "Assistant",
    handler: {} as ChatHandler
  },
  render: function StorybookChat() {
    const handler = useStorybookChat();
    return <Chat assistantName="Assistant" handler={handler} className="border w-[460px] h-[640px] bg-vscode-editor-background" />;
  }
}`,
			...((na = (ta = er.parameters) == null ? void 0 : ta.docs) == null ? void 0 : na.source),
		},
	},
}
const pb = ["Default"]
export { er as Default, pb as __namedExportsOrder, mb as default }
